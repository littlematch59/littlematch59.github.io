<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Windows, All fine">
    <meta name="description" content="前言简单介绍编程语言==(以上第一课内容)==

第一讲 Windows程序内部运行原理MSDN–&amp;gt;微软开发帮助文档
1.Windows编程模型
C、C++ –&amp;gt;面向过程的编程

面向对象的编程


1.警觉式(主动轮询,自身判">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Windows | Kni9hT&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Kni9hT's Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/match.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Kni9hT's Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/match.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">Kni9hT's Blog</div>
        <div class="logo-desc">
            
            JNU|ISSC|IS
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/littlematch59" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/littlematch59" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/13.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Windows</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-06-23
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    7.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    31 分
                </div>
                
				
                
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单介绍编程语言==(以上第一课内容)==</p>
<hr>
<h2 id="第一讲-Windows程序内部运行原理"><a href="#第一讲-Windows程序内部运行原理" class="headerlink" title="第一讲 Windows程序内部运行原理"></a>第一讲 Windows程序内部运行原理</h2><p>MSDN–&gt;微软开发帮助文档</p>
<h3 id="1-Windows编程模型"><a href="#1-Windows编程模型" class="headerlink" title="1.Windows编程模型"></a>1.Windows编程模型</h3><ul>
<li><p>C、C++ –&gt;面向过程的编程</p>
</li>
<li><p>面向对象的编程</p>
</li>
</ul>
<p>1.警觉式(主动轮询,自身判断,过程驱动)</p>
<p>2.宽心式</p>
<p>3.托付式(被动等待对象,取决于事件发生,事件驱动)</p>
<p>入口(WinMain) –&gt; 生命诞生</p>
<p>窗口 –&gt; 躯干、肉身</p>
<p><strong>消息循环 –&gt; 心脏</strong></p>
<p>窗口过程(回调) –&gt; 大脑(一个大的选择结构)</p>
<p>操作系统为程序建立消息队列–&gt;存放与窗口有关的消息–&gt;程序通过消息循环不断地从消息队列里取出消息并进行响应。</p>
<p>句柄(Handle) –&gt;资源的标识</p>
<p>图标句柄(HICON)、光标句柄(HCURSOR)、窗口句柄(HWND)、应用程序实例句柄(HINSTANCE)，操作系统给每个窗口指定唯一的一个标识号即窗口句柄。</p>
<p>用宏定义把消息标识号重新定义成WM_形式，方便辨识。</p>
<p>宏定义可以让变量具有语义信息。==(以上第二课内容)==</p>
<hr>
<h3 id="2-编写Windows应用程序的要素"><a href="#2-编写Windows应用程序的要素" class="headerlink" title="2.编写Windows应用程序的要素"></a>2.编写Windows应用程序的要素</h3><p><strong>1.入口WinMain</strong></p>
<pre class="line-numbers language-C"><code class="language-C">int WinAPI WinMain(

HINSTANCE hInstance, //当前应用程序实例句柄

HINSTANCE hPrevInstance, //前一个实例句柄,Win32下为NULL

LPSTR lpCmdLine, //命令行参数,char型

Int nCmdShow //窗口的显示状态(正常，隐藏，最小化等)

)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>WinAPI</code>表示<code>WinMain</code>的调用方式.</p>
<p>WinMain的四个参数和调用方式都不能省略。</p>
<p><strong>2.创建窗口</strong></p>
<p>1) 设计图纸[怎么去设计] –&gt; 窗口类</p>
<pre class="line-numbers language-C"><code class="language-C">typedef struct _WNDCLASS { 
    UINT       style;  //窗口类样式
    WNDPROC    lpfnWndProc;  //窗口过程指针
    int        cbClsExtra; //窗口类附加内存字节数，通常为0
    int        cbWndExtra; //窗口附加内存字节数，通常为0
    HINSTANCE  hInstance; //应用程序的实例句柄
    HICON      hIcon; //标题栏图标
    HCURSOR    hCursor; //光标
    HBRUSH     hbrBackground; //设置窗口背景颜色 
    LPCTSTR    lpszMenuName; //菜单资源名称
    LPCTSTR    lpszClassName; //窗口类名称
} WNDCLASS, *PWNDCLASS; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>2) 审批注册[Windows操作系统批准]</p>
<pre class="line-numbers language-C"><code class="language-C">ATOM RegisterClass(  
    CONST WNDCLASS *lpWndClass   // class data
                 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3) 生产</p>
<pre class="line-numbers language-C"><code class="language-C">HWND CreateWindow( 
    LPCTSTR lpClassName, //已注册的窗口类名称,操作系统提供了现成的图纸,也可以自己编写图纸
    LPCTSTR lpWindowName, //窗口标题栏中显示的文本,自己设定
    DWORD dwStyle, //窗口样式,个性化设定
    int x, //水平坐标
    int y, //垂直坐标
    int nWidth, //宽度
    int nHeight, //高度
    HWND hWndParent, //父窗口句柄
    HMENU hMenu, //菜单句柄
    HANDLE hInstance, //应用程序实例句柄
    PVOID lpParam //用于多文档的附加参数
); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>CreateWindow中 (0,0)默认在桌面的左上角</p>
<p><strong>菜单不是窗口！！！</strong></p>
<p>4) 发布</p>
<p>==(以上第三课内容)==</p>
<hr>
<p>Win32 Application和 Win32 console Application区别：</p>
<p>Win32:使用WinAPI</p>
<p>Console:不能使用GUI(图形)API</p>
<p>且二者入口不同</p>
<p>编写程序</p>
<pre class="line-numbers language-C"><code class="language-C">#include <windows.h>

LRESULT CALLBACK MyWndProc(

    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam                           
);
int WINAPI WinMain(
  HINSTANCE hInstance,      // handle to current instance
  HINSTANCE hPrevInstance,  // handle to previous instance
  LPSTR lpCmdLine,          // command line
  int nCmdShow              // show state
)

{    
    // 2. 创建窗口
    // 2.1 设计一个窗口类
    WNDCLASS MyWnd;
    MyWnd.cbClsExtra = NULL;
    MyWnd.cbWndExtra = NULL;
    MyWnd.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    MyWnd.hCursor = LoadCursor(NULL,IDC_CROSS);
    MyWnd.hIcon = LoadIcon(NULL,IDI_QUESTION);
    MyWnd.hInstance = hInstance;    //应用程序实例句柄
    MyWnd.lpfnWndProc = MyWndProc;//指向窗口过程的指针
    MyWnd.lpszClassName = "Hello";
    MyWnd.lpszMenuName = NULL;
    MyWnd.style = CS_HREDRAW | CS_VREDRAW;

    RegisterClass(&MyWnd); //注册图纸

    HWND hWnd;//定义窗口句柄,但是还没创建窗口
    hWnd = CreateWindow("Hello","Windows编程",WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,hInstance,NULL);

    ShowWindow(hWnd,SW_SHOW);
    UpdateWindow(hWnd);

    return 0;
}


//4.窗口过程
LRESULT CALLBACK MyWndProc(

    HWND hwnd,    //来自哪一个窗口
    UINT uMsg,    //窗口名称
    WPARAM wParam,    //附加参数
    LPARAM lParam    //附加参数                       
)
{
    return DefWindowProc(hwnd,uMsg,wParam,lParam);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上程序运行会闪退，缺少消息循环。</p>
<p><code>GetMessage</code>从线程的消息队列中取出消息,取出的消息保存在事先定义好的消息的结构体对象中。</p>
<p><strong><code>GetMessage</code>取到除WM_QUIT外的消息均返回非0，只有在接收到WM_QUIT消息时，才会返回0.</strong></p>
<p><code>GetMessage</code>从消息队列Get消息,返回值实际上有三种可能。</p>
<ul>
<li>返回0,Get到WM_QUIT消息</li>
<li>返回-1,异常.Get失败</li>
<li>返回非0,非-1(成功Get消息,且不是WM_QUIT消息)</li>
<li>当消息队列为空时,不返回！被挂起！</li>
</ul>
<p>功能:从消息队列中取出一条消息并删除它(WM_PAINT消息除外);</p>
<p><strong>回调(Callback)</strong></p>
<p>由你设计而却由操作系统调用的。</p>
<p>可以运行的程序代码如下：</p>
<pre class="line-numbers language-C"><code class="language-C">#include <windows.h>

LRESULT CALLBACK MyWndProc(

    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam                           
);
int WINAPI WinMain(
  HINSTANCE hInstance,      // handle to current instance
  HINSTANCE hPrevInstance,  // handle to previous instance
  LPSTR lpCmdLine,          // command line
  int nCmdShow              // show state
)

{    
    // 2. 创建窗口
    // 2.1 设计一个窗口类
    WNDCLASS MyWnd;
    MyWnd.cbClsExtra = NULL;
    MyWnd.cbWndExtra = NULL;
    MyWnd.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    MyWnd.hCursor = LoadCursor(NULL,IDC_CROSS);
    MyWnd.hIcon = LoadIcon(NULL,IDI_QUESTION);
    MyWnd.hInstance = hInstance;    //应用程序实例句柄
    MyWnd.lpfnWndProc = MyWndProc;//指向窗口过程的指针
    MyWnd.lpszClassName = "Hello";
    MyWnd.lpszMenuName = NULL;
    MyWnd.style = CS_HREDRAW | CS_VREDRAW;

    RegisterClass(&MyWnd); //注册图纸

    HWND hWnd;//定义窗口句柄,但是还没创建窗口
    hWnd = CreateWindow("Hello","Windows编程",WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,hInstance,NULL);

    ShowWindow(hWnd,SW_SHOW);
    UpdateWindow(hWnd);

    //消息循环
    MSG msg;
    while(GetMessage(&msg,NULL,0,0))
    {
        TranslateMessage(&msg); //消息解释,将虚拟消息转换为字符消息
        DispatchMessage(&msg);    //将消息发送到"窗口过程"
    }



    return 0;
}


//4.窗口过程
LRESULT CALLBACK MyWndProc(

    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam                           
)
{
    return DefWindowProc(hwnd,uMsg,wParam,lParam);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>DefWindowProc(hwnd,uMsg,wParam,lParam)</code>位移不能接管的就是不能WM_QUIT消息。(==以上第四课内容==)</p>
<hr>
<p><strong>GetMessage</strong></p>
<pre class="line-numbers language-C"><code class="language-C">Bool GetMessage(

        LPMSG lpMsg,    //消息结构体指针
        HWND hWnd,    //窗口句柄，通常设为NULL,表示接收所有窗口消息
        UINT wMsgFilterMin,    //消息过滤最小值
        UINT wMsgFilterMax    //消息过滤最大值
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C"><code class="language-C">    switch(uMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hwnd,uMsg,wParam,lParam);
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>总结:</p>
<ul>
<li>用户自己不响应的消息要交给操作系统调用DefWindowProc窗口过程！</li>
<li>窗口过程中一定要出现PostQuitMessage(),只有调用这个，消息队列才会出现QUIT消息，程序才能正常退出</li>
</ul>
<p><strong>消息是怎么产生的？</strong></p>
<ol>
<li>交互产生,比如鼠标、键盘</li>
<li>由API产生</li>
</ol>
<p>CreateWindow –&gt;WM_CREATE</p>
<p>UpdateWindow –&gt; WM_PAINT</p>
<p>DestroyWindow –&gt; WM_DESTROY</p>
<p>  交互产生: </p>
<blockquote>
<p>点击”文件”-“退出”–&gt;消息队列产生WM_CLOSE消息–&gt;DefWindowProc响应WM_CLOSE消息–&gt;调用DestroyWindow–&gt;产生WM_DESTROY消息–&gt;自己的WinProc响应–&gt;调用PostQuitMessage–&gt;产生WM_QUIT消息–&gt;GetMessage返回0–&gt;消息循环结束</p>
</blockquote>
<p><strong>DefWindowProc</strong></p>
<blockquote>
<p>DefWindowProc这个是默认的窗口处理，我们可以把不关心的消息都丢给它来处理。</p>
</blockquote>
<p>在switch里面继续增添case框架:</p>
<pre class="line-numbers language-C"><code class="language-C">switch(uMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
        if(IDYES == MessageBox(hwnd,"真的要退出吗?","退出",MB_YESNO))
        DestroyWindow(hwnd);
        break;

    case WM_CHAR:
        char str[255];
        sprintf(str,"char is %d",wParam);
        MessageBox(hwnd,str,"按键响应",0);
        break;

    case WM_LBUTTONDOWN:
        HDC hDC;//句柄资源
        hDC = GetDC(hwnd);
        TextOut(hDC,255,100,"Hello World!",strlen("Hello world!"));
        ReleaseDC(hwnd,hDC);//防止内存泄露
        break;
    default:
        return DefWindowProc(hwnd,uMsg,wParam,lParam);
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上代码可以产生一个窗口，点击出现”Hello world!”字样，但是拉伸窗口尺寸，文字就会消失。</p>
<blockquote>
<p>窗口变为无效的时候–&gt;消息队列产生WM_PAINT消息–&gt;窗口重绘–&gt;文字消失</p>
</blockquote>
<p><strong>窗口什么时候变成无效？</strong></p>
<ol>
<li>最初建立窗口的时候(CreateWindow时)</li>
<li>改变窗口尺寸的时候(在注册窗口类的时候自己定义的)</li>
<li>最小化–&gt;恢复</li>
<li>移动出屏幕或者被其它窗口覆盖的时候</li>
<li>使用滚动条的时候</li>
<li>Invalidate(调用，人为使窗口变成无效)</li>
</ol>
<p>自己来响应WM_PAINT消息：</p>
<pre class="line-numbers language-C"><code class="language-C">    case WM_PAINT:
        HDC hpaintDC;
        PAINTSTRUCT ps;
        hpaintDC=BeginPaint(hwnd,&ps);
        TextOut(hpaintDC,255,50,"Hello World!",strlen("Hello World!"));
        EndPaint(hwnd,&ps);
        break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>(==以上第五课内容==)</p>
<hr>
<h3 id="3-自行发送消息的两种方式"><a href="#3-自行发送消息的两种方式" class="headerlink" title="3.自行发送消息的两种方式"></a>3.自行发送消息的两种方式</h3><p>大多数消息是由操作系统产生和发送，此外我们也可以人为调用<code>SendMessage</code>和<code>PostMessage</code>来自行发送消息。</p>
<ul>
<li><code>SendMessage</code>将消息直接发送给窗口,并调用该窗口过程进行处理。在窗口过程对消息处理完毕之后,该才返回。</li>
<li><code>PostMessage</code>将消息放入与创建窗口的线程相关联的消息队列后立即返回。</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">case WM_RBUTTONDOWN:
SendMessage(hwnd,WM_SETTEXT,0,(LPARAM)"WZY!!");    //鼠标右键点击改变任务栏名称    SendMessage(FindWindow("Notepad",NULL),WM_SETTEXT,0,(LPARAM)"WZY!!");
//SendMessage(FindWindow("计算器",NULL),WM_SETTEXT,0,(LPARAM)"WZY!!");
break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以用<code>Spy++</code>程序来查找软件对应的窗口名称。</p>
<p><strong>DefWindowProc怎么对WM_PAINT消息进行响应？</strong></p>
<pre><code>(1)BeginPaint(4个功能):
1.获得一个设备描述表(Get DC)
2.重绘背景
3.窗口状态由无效重新变为有效(有效状态下PAINT消息不再产生)
4.删除消息队列中已有的WM_PAINT消息
(2)EndPaint
(3)Release DC

自己响应WM_PAINT消息,一定要配合BeginPaint来使用,不能使用Get DC</code></pre><p><strong>队列化消息</strong></p>
<blockquote>
<p>进入消息队列–&gt;GetMessage获得</p>
<p>一般是由用户交互操作产生的消息、定时器WM_TIMER、WM_QUIT</p>
<p>用户可以使用PostMessage或SendMessage发送消息</p>
</blockquote>
<p><strong>非队列化消息</strong></p>
<blockquote>
<p>进入窗口过程,不进消息队列</p>
<p>一般是由WindowsAPI产生，但其中WM_PAINT有时也可以被当作是队列化消息。但WM_SETTEXT一定是非队列化消息。</p>
<p>用户只能用SendMessage发送消息</p>
</blockquote>
<p>第一讲的最后设计程序代码如下</p>
<pre class="line-numbers language-C"><code class="language-C">#include <windows.h>
#include <stdio.h>

LRESULT CALLBACK MyWndProc(

    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam                           
);
int WINAPI WinMain(
  HINSTANCE hInstance,      // handle to current instance
  HINSTANCE hPrevInstance,  // handle to previous instance
  LPSTR lpCmdLine,          // command line
  int nCmdShow              // show state
)

{    
    // 2. 创建窗口
    // 2.1 设计一个窗口类
    WNDCLASS MyWnd;
    MyWnd.cbClsExtra = NULL;
    MyWnd.cbWndExtra = NULL;
    MyWnd.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    MyWnd.hCursor = LoadCursor(NULL,IDC_CROSS);
    MyWnd.hIcon = LoadIcon(NULL,IDI_QUESTION);
    MyWnd.hInstance = hInstance;    //应用程序实例句柄
    MyWnd.lpfnWndProc = MyWndProc;//指向窗口过程的指针
    MyWnd.lpszClassName = "Hello";
    MyWnd.lpszMenuName = NULL;
    MyWnd.style = CS_HREDRAW | CS_VREDRAW;

    RegisterClass(&MyWnd); //注册图纸

    HWND hWnd;//定义窗口句柄,但是还没创建窗口
    hWnd = CreateWindow("Hello","Windows编程",WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,hInstance,NULL);

    ShowWindow(hWnd,SW_SHOW);
    UpdateWindow(hWnd);

    //消息循环
    MSG msg;
    while(GetMessage(&msg,NULL,0,0))
    {
        TranslateMessage(&msg); //消息解释,将虚拟消息转换为字符消息

        DispatchMessage(&msg);    //将消息发送到"窗口过程"
    }



    return 0;
}


//4.窗口过程
LRESULT CALLBACK MyWndProc(

    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam                           
)
{    
    switch(uMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_CLOSE:
        if(IDYES == MessageBox(hwnd,"真的要退出吗?","退出",MB_YESNO))
        DestroyWindow(hwnd);
        break;

    case WM_CHAR:
        char str[255];
        sprintf(str,"char is %d",wParam);
        MessageBox(hwnd,str,"按键响应",0);
        break;

    case WM_LBUTTONDOWN:
        HDC hDC;//句柄资源
        hDC = GetDC(hwnd);
        TextOut(hDC,255,100,"Hello World!",strlen("Hello World!"));
        ReleaseDC(hwnd,hDC);//防止内存泄露
        break;

    case WM_PAINT:
        HDC hpaintDC;
        PAINTSTRUCT ps;
        hpaintDC=BeginPaint(hwnd,&ps);
        TextOut(hpaintDC,255,50,"Hello World!",strlen("Hello World!"));
        EndPaint(hwnd,&ps);
        break;
    case WM_RBUTTONDOWN:
        SendMessage(hwnd,WM_SETTEXT,0,(LPARAM)"WZY!!");
        SendMessage(FindWindow("Notepad",NULL),WM_SETTEXT,0,(LPARAM)"WZY!!");
        //SendMessage(FindWindow("计算器",NULL),WM_SETTEXT,0,(LPARAM)"WZY!!");
        break;

    default:
        return DefWindowProc(hwnd,uMsg,wParam,lParam);
    }

    return 0;//DefWindowProc(hwnd,uMsg,wParam,lParam);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里有一个需要注意的就是，我原来设计的程序，点击退出，有一个提示框，问是否确认退出,我选择否结果它也退出了，困惑了很长时间。</p>
<p><img src="1-1.gif" alt=""></p>
<p>今天发现是switch选择结构外的return出了点错.</p>
<p><img src="1-1.jpg" alt=""></p>
<p>我原来写的是<code>return DefWindowProc()</code>,那这应该就相当于还是DefWindowProc()响应了WM_CLOSE消息,而不是我们写的<code>case WM_CLOSE</code>部分。</p>
<p>修改代码之后,运行结果如下:</p>
<p><img src="1-2.gif" alt=""></p>
<p>(==以上第六课内容&amp;&amp;第一节结束==)</p>
<hr>
<hr>
<h2 id="第二讲-掌握C"><a href="#第二讲-掌握C" class="headerlink" title="第二讲 掌握C++"></a>第二讲 掌握C++</h2><h3 id="1-派生类的生与死问题"><a href="#1-派生类的生与死问题" class="headerlink" title="1.派生类的生与死问题"></a>1.派生类的生与死问题</h3><pre class="line-numbers language-C++"><code class="language-C++">#include <iostream.h>

class father
{
public:
    father()
    {
        cout<<"father construct."<<endl;
    }
    ~father()
    {
        cout<<"father destruct."<<endl;
    }

};

class son: public father
{
public:
    son()
    {
        cout<<"son construct."<<endl;
    }
    ~son()
    {
        cout<<"son destruct."<<endl;
    }
};

void main()
{
    son s;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>顺序:父类创建–&gt;子类创建–&gt;子类析构–&gt;父类析构</p>
</blockquote>
<h3 id="2-四种不同对象的生与死"><a href="#2-四种不同对象的生与死" class="headerlink" title="2.四种不同对象的生与死"></a>2.四种不同对象的生与死</h3><pre class="line-numbers language-C"><code class="language-C">//1.一般局部对象,在stack之中产生
void MyFunc()
{
    CObject ob;//栈上产生的对象自动释放
}

//2.new局部对象,在heap中产生
void MyFunc()
{
    CObject* pOb = new CObject;//堆上产生的对象需要用delete手动释放
}

//3.全局对象(静态对象)
CObject ob //在任何范围之外做此操作

//4.局部静态对象，在范围内的一个静态对象
void MyFunc()
{
    static CObject ob;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>构造顺序:</p>
<p>全局对象–&gt;Main–&gt;一般局部对象–&gt;new局部对象–&gt;静态局部对象</p>
</blockquote>
<blockquote>
<p>析构顺序:</p>
<p>一般局部对象–&gt;new局部对象–&gt;静态局部对象–&gt;全局对象</p>
</blockquote>
<h3 id="3-重载"><a href="#3-重载" class="headerlink" title="3.重载"></a>3.重载</h3><pre><code>重载条件:两个的名相同,的参数类型、参数个数不同，才能构成的重载。

1.只有的返回类型不同是不能构成的重载的。
如：void output() 与 int output()
2.要注意带有默认参数的这种情况，也不能构成重载。
如：void output(int a,int b=5)与void output(int a)</code></pre><h3 id="4-引用与指针的比较"><a href="#4-引用与指针的比较" class="headerlink" title="4.引用与指针的比较"></a>4.引用与指针的比较</h3><pre><code>引用是C++中的概念。
int m;
int &amp;n = m;
则n是对m的引用，注意：n既不是m的拷贝，也不是指向m的指针，n就是m自己。
对比指针：
int m;
int *pM =&amp;m;</code></pre><pre><code>不同点:
1.引用被创建的同时必须被初始化;指针则可以在任何时候被初始化。
2.不能有NULL引用,引用必须与合法的存储单元关联;指针则可以是NULL;
3.一旦引用被初始化,就不能改变引用的关系;指针则可以随时改变所指的对象。
引用其实可以看做是削减权限版的指针。</code></pre><p>(==以上第七课内容&amp;第二讲结束==)</p>
<hr>
<hr>
<h2 id="第三讲-MFC框架程序"><a href="#第三讲-MFC框架程序" class="headerlink" title="第三讲 MFC框架程序"></a>第三讲 MFC框架程序</h2><h3 id="1-什么是MFC框架程序"><a href="#1-什么是MFC框架程序" class="headerlink" title="1.什么是MFC框架程序"></a>1.什么是MFC框架程序</h3><p>利用MFC AppWizard生成的Windows应用程序</p>
<p>1.新建MFC工程文件</p>
<p>CWinThread–&gt;CWinApp–&gt;ColeControlModule</p>
<p>CWind–&gt;CFrameWnd</p>
<p>控件也是从窗口类派生出来的</p>
<p>==注意：==</p>
<p><strong>文档类不是窗口！！！</strong></p>
<p><strong>菜单也不是窗口！！！菜单属于文本资源！！</strong></p>
<p>在MFC工程中新建.cpp源文件，要记得添加头文件:<code>#include "stdafx.h"</code>,表示这是MFC的源文件。</p>
<p><code>Source Files/View.cpp</code>文件中找到 View::OnDraw()，用pDC-&gt;TextOut()来输出字符串。</p>
<p><img src="3-1.gif" alt=""></p>
<p>以Afx开头的，如<code>AfxWinMain</code>，都是WinMain下面的全局。</p>
<p>对于MFC框架程序，WinMain不一定是最先执行的。全局对象的构造最先执行。</p>
<p>MFC里面调用底层API，前面要加上作用域::,比如<code>::RegisterClass(lpWndClass)</code></p>
<p>==(以上第八课内容)==</p>
<hr>
<h3 id="2-MFC框架程序剖析"><a href="#2-MFC框架程序剖析" class="headerlink" title="2.MFC框架程序剖析"></a>2.MFC框架程序剖析</h3><p><strong>窗口类</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">class CWnd
{
public:
    BOOL CreateEx(DWORD dwExStyle,    // extended window style
                LPCTSTR lpClassName,  // registered class name
                LPCTSTR lpWindowName, // window name
                DWORD dwStyle,        // window style
                int x,                // horizontal position of window
                int y,                // vertical position of window
                int nWidth,           // window width
                int nHeight,          // window height
                HWND hWndParent,      // handle to parent or owner window
                HMENU hMenu,          // menu handle or child identifier
                HINSTANCE hInstance,  // handle to application instance
                LPVOID lpParam);      // window-creation data
    BOOL ShowWindow(int nCmdShow);
    BOOL UpdateWindow();
public:
    HWND m_hWnd;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>MFC中窗口类对象(CWnd)和窗口并不是一回事,窗口是资源。窗口销毁时，与之对应的C++窗口类对象不一定销毁(具体要看其生命周期是否结束);C++窗口类对象销毁时,与之相关的窗口也将销毁。</strong></p>
<hr>
<h2 id="第四讲-绘图与文本"><a href="#第四讲-绘图与文本" class="headerlink" title="第四讲 绘图与文本"></a>第四讲 绘图与文本</h2><p><img src="4-1.jpg" alt=""></p>
<pre class="line-numbers language-C++"><code class="language-C++">#ifndef afx_msg
#define afx_msg         // intentional placeholder
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>afx_msg</code>这个宏定义为空，相当于注释。</p>
<p><strong>消息映射宏</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">BEGIN_MESSAGE_MAP(CMFC_testView, CView)
    //{{AFX_MSG_MAP(CMFC_testView)
	ON_WM_LBUTTONDOWN()
	//}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="1-画线"><a href="#1-画线" class="headerlink" title="1.画线"></a>1.画线</h3><ol>
<li><p>在public中添加 m_PrOrigin定义</p>
<pre class="line-numbers language-C++"><code class="language-C++">public:
    CMFC_testDoc* GetDocument();
    CPoint m_ptOrigin;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>调用设备描述表和底层API</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMFC_testView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    // TODO: Add your message handler code here and/or call default

    m_ptOrigin = point;
    CView::OnLButtonDown(nFlags, point);
}

void CMFC_testView::OnLButtonUp(UINT nFlags, CPoint point) 
{
    // TODO: Add your message handler code here and/or call default

    HDC hdc;    //设备描述表
    hdc = ::GetDC(m_hWnd);    //调用底层API
    ::MoveToEx(hdc, m_ptOrigin.x, m_ptOrigin.y, NULL);
    ::LineTo(hdc, point.x, point.y);
    ::ReleaseDC(m_hWnd, hdc);
    CView::OnLButtonUp(nFlags, point);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>利用CDC类实现画线功能</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMFC_testView::OnLButtonUp(UINT nFlags, CPoint point) 
{
    CDC* pDC = GetDC();
    pDC->MoveTo(m_ptOrigin);
    pDC->LineTo(point);
    ReleaseDC(pDC);
    CView::OnLButtonUp(nFlags, point);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>利用CClientDC类实现画线功能</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMFC_testView::OnLButtonUp(UINT nFlags, CPoint point) 
{

    CClientDC dc(this); //this指针指向当前的视类
    dc.MoveTo(m_ptOrigin);
    dc.LineTo(point);

    CView::OnLButtonUp(nFlags, point);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="4-3.jpg" alt=""></p>
</li>
<li><p>利用CWindowDC类实现画线功能</p>
<p>(可以把线画到菜单上,菜单是主框架的非客户区)</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMFC_testView::OnLButtonUp(UINT nFlags, CPoint point) 
{
    CWindowDC dc(GetParent()); //GetParent指针指向当前窗口的父类
    dc.MoveTo(m_ptOrigin);
    dc.LineTo(point);

    CView::OnLButtonUp(nFlags, point);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>绘制彩色线条——使用CPen类</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMFC_testView::OnLButtonUp(UINT nFlags, CPoint point) 
{
    CPen pen(PS_SOLID,5,RGB(255,0,0));//设置画笔,RGB来确定色彩
    CClientDC dc(this);
    CPen* pOldPen = dc.SelectObject(&pen);//返回值是旧的笔,先保存起来
    dc.MoveTo(m_ptOrigin);
    dc.LineTo(point);
    dc.SelectObject(pOldPen);//旧笔再放回去

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<pre><code>   CView::OnLButtonUp(nFlags, point);</code></pre><p>   }</p>
<pre><code>
7. 用画刷CBrush类绘图

   ```C++
   void CMFC_testView::OnLButtonUp(UINT nFlags, CPoint point) 
   {
       CBrush brush(RGB(255,0,0));
       CClientDC dc(this);
       dc.FillRect(CRect(m_ptOrigin,point), &amp;brush);
   //绘制矩形

       CView::OnLButtonUp(nFlags, point);
   }</code></pre><p>   <strong>添加位图资源</strong></p>
<p>   <img src="4-4.jpg" alt=""></p>
<pre class="line-numbers language-C++"><code class="language-C++">   void CMFC_testView::OnLButtonUp(UINT nFlags, CPoint point) 
   {
       CBitmap bmp;
       bmp.LoadBitmap(IDB_BITMAP1);
       CBrush brush(&bmp);
       CClientDC dc(this);
       dc.FillRect(CRect(m_ptOrigin,point), &brush);
   //添加位图资源
       CView::OnLButtonUp(nFlags, point);
   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>   灵魂画手上线!!!</p>
<p>   <img src="4-5.jpg" alt=""></p>
<p>==(以上第九课内容)==</p>
<hr>
<ol start="8">
<li><p>绘制连续线条</p>
<p>(捕获鼠标move消息,画若干个首尾连续的短直线)</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMFC_testView::OnMouseMove(UINT nFlags, CPoint point) 
{
    // TODO: Add your message handler code here and/or call default

    CPen pen(PS_SOLID,5,RGB(255,0,0));//设置画笔
    CClientDC dc(this);
    CPen* pOldPen = dc.SelectObject(&pen);
    //OnMouseMove
    if (nFlags == MK_LBUTTON  )//表示鼠标左键一直没有松开
    {
        dc.MoveTo(m_ptOrigin);
        dc.LineTo(point);    //记录move
        m_ptOrigin = point;    //更改下一次的画线坐标起点为本次画线的终点
    }

    dc.SelectObject(pOldPen);
    CView::OnMouseMove(nFlags, point);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>橡皮筋技术</p>
<p>(通过背景取反擦除上一次的线条)</p>
<pre class="line-numbers language-C++"><code class="language-C++">BOOL CMFC_testView::OnEraseBkgnd(CDC* pDC) 
{
    // TODO: Add your message handler code here and/or call default
    CRect rect;
    GetClientRect(&rect);//获得当前窗口的参数

    CBitmap bmp;
    bmp.LoadBitmap(IDB_BITMAP1);
    CBrush brush(&bmp);
    CClientDC dc(this);
    dc.FillRect(rect, &brush);

    //return CView::OnEraseBkgnd(pDC);
    return TRUE;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h3 id="2-文本编程"><a href="#2-文本编程" class="headerlink" title="2.文本编程"></a>2.文本编程</h3><pre class="line-numbers language-C++"><code class="language-C++">void CTEXTView::OnDraw(CDC* pDC)
{
    CTEXTDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    // TODO: add draw code for native data here
    pDC->TextOut(100,100,"Hello World!");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++"><code class="language-C++">void CTEXTView::OnDraw(CDC* pDC)
{
    CTEXTDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    // TODO: add draw code for native data here
    CString str("Hello world!");    
    pDC->TextOut(100,100,str);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>添加字符串资源</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CTEXTView::OnDraw(CDC* pDC)
{
    CTEXTDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    // TODO: add draw code for native data here
    CString str;
    str.LoadString(IDS_MYSTRING);

    pDC->TextOut(100,100,str);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>创建记事本</strong></p>
<ol>
<li><p>创建插入符</p>
<pre class="line-numbers language-C++"><code class="language-C++">int CTEXTView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CView::OnCreate(lpCreateStruct) == -1)
        return -1;

    // TODO: Add your specialized creation code here
/*    CreateSolidCaret(20,200);//插入符大小
    ShowCaret();
*/    

    CClientDC dc(this);
    TEXTMETRIC tm;
    dc.GetTextMetrics(&tm);
    CreateSolidCaret(tm.tmAveCharWidth/8, tm.tmHeight);//根据字符大小设置插入符大小
    ShowCaret();

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<pre><code>   return 0;</code></pre><p>   }</p>
<pre><code>
2. 创建位图插入符

   ```C++
   int CTEXTView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
   {
       if (CView::OnCreate(lpCreateStruct) == -1)
           return -1;

       CClientDC dc(this);
       TEXTMETRIC tm;
       dc.GetTextMetrics(&amp;tm);
       CBitmap bmp; //局部变量
       bmp.LoadBitmap(IDB_BITMAP1);//对象和资源绑定在一起,对象释放掉之后资源也释放掉了
       CBrush brush(&amp;bmp);
       CreateCaret(&amp;bmp);
       ShowCaret();
       bmp.Detach();//解除C++对象和资源的绑定关系,C++对象释放,资源还在。
       return 0;
   }</code></pre><p>   <img src="4-6.jpg" alt=""></p>
<p>==(以上第十课内容)==</p>
<hr>
<ol start="3">
<li><p>插入符位置随鼠标单击移动</p>
<pre class="line-numbers language-C++"><code class="language-C++">//先在头文件里面定义全局变量
/*
public:
    CString m_strLine;
    CPoint m_ptOrigin;
*/

void CTEXTView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    // TODO: Add your message handler code here and/or call default
    SetCaretPos(point);//光标随鼠标单击移动
    m_strLine.Empty();//之前存储的字符清空,不重复输出
    m_ptOrigin =point;//保存鼠标点击的位置

    CView::OnLButtonDown(nFlags, point);
}

void CTEXTView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
    // TODO: Add your message handler code here and/or call default
    CClientDC dc(this);//设备描述表,以下用于输出
    m_strLine += nChar;
    dc.TextOut(m_ptOrigin.x, m_ptOrigin.y, m_strLine);

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<pre><code>   CView::OnChar(nChar, nRepCnt, nFlags);</code></pre><p>   }</p>
<pre><code>
4. 回车键和退格键

   ```C++
   void CTEXTView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
   {
       // TODO: Add your message handler code here and/or call default
       CClientDC dc(this);//设备描述表,以下用于输出

       if (13 == nChar)     //回车键的ASCII码为13
       {
           TEXTMETRIC tm;
           dc.GetTextMetrics(&amp;tm);//取得字体的高度
           m_strLine.Empty();
           m_ptOrigin.y += tm.tmHeight;
       }

       else if (8 == nChar)     //退格键的ASCII码为8
       {
           COLORREF clr = dc.SetTextColor(dc.GetBkColor());//文本设置成背景色
           dc.TextOut(m_ptOrigin.x, m_ptOrigin.y, m_strLine);//再输出一次
           m_strLine = m_strLine.Left(m_strLine.GetLength() - 1) ;//最右边删掉一个字符
           dc.SetTextColor(clr);//还原颜色
       }
       else
           m_strLine += nChar;


       dc.TextOut(m_ptOrigin.x, m_ptOrigin.y, m_strLine);


       CView::OnChar(nChar, nRepCnt, nFlags);
   }</code></pre><ol start="5">
<li><p>插入符随之字符输入后移</p>
<pre class="line-numbers language-C++"><code class="language-C++">CSize sz = dc.GetTextExtent(m_strLine);//得到x,y参数
    CPoint pt;
    pt.x = m_ptOrigin.x + sz.cx;//插入符宽度后移
    pt.y = m_ptOrigin.y;
    SetCaretPos(pt);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>设置字体</p>
<pre class="line-numbers language-C++"><code class="language-C++">    CClientDC dc(this);//设备描述表,以下用于输出

    CFont font;
    font.CreatePointFont(200, "华文琥珀"); //设置字体
    CFont* pOldFont = dc.SelectObject(&font);
    dc.SetTextColor(RGB(255,0,0));//设置颜色
······
    dc.SelectObject(pOldFont);//把字体换回来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>模拟卡拉OK的字幕变色功能</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CTEXTView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
    // TODO: Add your message handler code here and/or call default

    CClientDC dc(this);//设备描述表,以下用于输出

    CFont font;
    font.CreatePointFont(400,"华文行楷",NULL); //设置字体
    CFont* pOldFont = dc.SelectObject(&font);
    dc.SetTextColor(RGB(255,0,0));

    if (13 == nChar)     //回车键的ASCII码为13
    {
        TEXTMETRIC tm;
        dc.GetTextMetrics(&tm);//取得字体的高度
        m_strLine.Empty();
        m_ptOrigin.y += tm.tmHeight;
    }

    else if (8 == nChar)     //退格键的ASCII码为8
    {
        COLORREF clr = dc.SetTextColor(dc.GetBkColor());//文本设置成背景色
        dc.TextOut(m_ptOrigin.x, m_ptOrigin.y, m_strLine);//再输出一次
        m_strLine = m_strLine.Left(m_strLine.GetLength() - 1) ;//最右边删掉一个字符
        dc.SetTextColor(clr);//还原颜色
    }
    else
        m_strLine += nChar;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<pre><code>   CSize sz = dc.GetTextExtent(m_strLine);//得到x,y参数
   CPoint pt;
   pt.x = m_ptOrigin.x + sz.cx;//插入符宽度后移
   pt.y = m_ptOrigin.y;
   SetCaretPos(pt);

   dc.TextOut(m_ptOrigin.x, m_ptOrigin.y, m_strLine);


   dc.SelectObject(pOldFont);//把字体换回来
   CView::OnChar(nChar, nRepCnt, nFlags);</code></pre><p>   }<br>   int nWidth = 0;<br>   void CTEXTView::OnTimer(UINT nIDEvent)<br>   {<br>       // TODO: Add your message handler code here and/or call default<br>       nWidth += 3;//宽度每秒加3<br>       CClientDC dc(this);<br>       TEXTMETRIC tm;<br>       dc.GetTextMetrics(&amp;tm);<br>       CRect rect;<br>       rect.left = 0;<br>       rect.top = 200;<br>       rect.right = rect.left + nWidth;//往右增长<br>       rect.bottom = rect.top + tm.tmHeight;</p>
<pre><code>   dc.SetTextColor(RGB(255,0,0));
   CString str;
   str.LoadString(IDS_MYSTRING);
   dc.DrawText(str,rect,DT_LEFT);//字符串,矩形框,从左往右

   CSize sz = dc.GetTextExtent(str);
   if (nWidth &gt; sz.cx)    //超出矩形框范围就变色
   {
       nWidth = 0;
       dc.SetTextColor(RGB(0,0,255));
       dc.TextOut(rect.left,rect.top,str);
   }


   CView::OnTimer(nIDEvent);</code></pre><p>   }</p>
<pre><code>


**新建MFC工程(CRichEditView基类有现成的记事本)**

![](4-7.jpg)

***

## 第五讲 菜单编程

### 1.菜单响应

![](5-1.jpg)

当然，也可以自定义顶级菜单设置响应。

![](5-2.jpg)

定义菜单并设置ID号后,在四个类里面都可以设置ID_TEST。

但是点击test，只会响应视类的定义，其它三个类的定义都不响应。

(==以上第十一课内容==)

弹出式菜单没有ID号,只有菜单项才有ID号

**Windows消息分类**

- 标准消息

     除`WM_COMMAND`之外，所有以`WM_`开头的消息。从`CWnd`派生的类，都可以接收到这类消息。

- 命令消息

  **来自菜单、快捷键或工具栏按钮的消息。**这类消息都以`WM_COMMAND`呈现。在MFC中,通过菜单项的标识(ID)来区分不同的命令消息;在从`CCmdTarget`派生的类,都可以接收到这类消息。

- 通告消息

  由控件产生的消息,例如，按钮的单击，列表框的选择等均产生此类消息,为的是向其父窗口(通常是对话框)通知时间的发生。这类消息也是以`WM_COMMAND`形式呈现。

  从`CCmdTarget`派生的类,都可以接收到这类消息。

**菜单响应命令与响应顺序**

在视图、文档、主框架、应用程序类中都添加菜单响应命令ON_TEST，最后只有View类响应。

![](5-3.jpg)

**把视类菜单响应删除,轮到文档类响应。**

**响应顺序：**

&gt; CMenuView--&gt;CMenuDoc--&gt;CMainFrame--&gt;CMenuApp



- 当点击某菜单项时，最先接收到这个菜单命令消息的是框架类。

- 框架类把接收到的这个消息传给它的子窗口，即视类。视类根据命令消息映射机制查找自身是否对这个消息进行了响应，如果响应了，则调用自身相应响应。 

- 如果视类没有对此命令消息作出响应，就交由文档类，文档类同样查找自身是否这个消息进行了响应，如果响应了，则调用自身相应响应。

- 如果文档类也未做出响应，就把这个命令消息交还给视类，后者再交还给框架类。

- 框架类查看自己是否对这个命令消息进行了响应，如果它也没有相应，就把这个菜单命令消息交给应用程序类，由后者来处理。

### 2.基本菜单操作

**菜单的结构**

![](5-4.jpg)

**标记菜单**

&gt; Source Files--&gt;MainFrm.cpp中

```C++
GetMenu()-&gt;GetSubMenu(0)-&gt;CheckMenuItem(0, MF_BYPOSITION | MF_CHECKED);
//通过楼层号来访问
//获得顶级菜单--&gt;子菜单(0)--&gt;0号菜单项前面打勾</code></pre><pre class="line-numbers language-C++"><code class="language-C++">GetMenu()->GetSubMenu(0)-> CheckMenuItem(ID_FILE_NEW, MF_CHECKED);
//用ID号访问<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>使用图形标记菜单</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">    GetMenu()->GetSubMenu(0)->CheckMenuItem(0, MF_BYPOSITION | MF_CHECKED);
    //获得顶级菜单-->子菜单(0)-->0号菜单项前面打勾

    GetMenu()->GetSubMenu(0)-> CheckMenuItem(ID_FILE_NEW, MF_CHECKED);
    //用ID号访问
    CBitmap bmp1,bmp2;
    bmp1.LoadBitmap(IDB_BITMAP2);//对应checked
    bmp2.LoadBitmap(IDB_BITMAP3);//对应unchecked
    GetMenu()->GetSubMenu(0)->SetMenuItemBitmaps(0, MF_BYPOSITION, &bmp1, &bmp2);

    bmp1.Detach();//解除绑定
    bmp2.Detach();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>禁用菜单项</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">CMainFrame::CMainFrame()
{
    // TODO: add member initialization code here
    m_bAutoMenuEnable = FALSE;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>该要生效，必须在CMainFrame类的构造中把成员变量m_bAutoMenuEnable设置为FALSE。要使用菜单命令更新机制（后面有讲），则该变量应设置为TRUE（缺省值）</p>
</blockquote>
<pre class="line-numbers language-C++"><code class="language-C++">GetMenu()->GetSubMenu(0)->EnableMenuItem(0, MF_BYPOSITION | MF_GRAYED | MF_DISABLED);//变灰和失效通常一起使用。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>移除和加载菜单</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">SetMenu(NULL);//移除菜单

CMenu menu;//加载菜单
menu.LoadMenu(IDR_MAINFRAME);
SetMenu(&menu);
menu.Detach();//解除menu资源和对象的关系,否则return 0后资源会被释放;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-MFC菜单命令更新机制"><a href="#3-MFC菜单命令更新机制" class="headerlink" title="3.MFC菜单命令更新机制"></a>3.MFC菜单命令更新机制</h3><p><img src="5-5.jpg" alt=""></p>
<p><code>ID_EDIT_CUT</code>是剪切的ID号</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMainFrame::OnUpdateEditCut(CCmdUI* pCmdUI) 
{
    // TODO: Add your command update UI handler code here
    pCmdUI->Enable(TRUE);
    pCmdUI->SetCheck();
    pCmdUI->SetText("123");
}//MFC菜单命令更新机制<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-制作一个快捷菜单"><a href="#4-制作一个快捷菜单" class="headerlink" title="4.制作一个快捷菜单"></a>4.制作一个快捷菜单</h3><p>再次强调菜单并不是窗口,菜单从<code>CObject</code>派生而来,属于资源。</p>
<ol>
<li><p>添加新的菜单资源</p>
<p>resource界面在Menu上右键插入Menu命令,为这个菜单资源添加菜单项。</p>
</li>
<li><p>给视类添加WM_RBUTTONDOWN消息响应</p>
<p><code>Ctrl</code>+<code>w</code>快捷键的方式去添加一个响应<code>WM_RBUTTONDOWN</code>,注意一定是在视类里面添加。</p>
</li>
<li><p>调用<code>TrackPopupMenu</code></p>
<p>先给这两个快捷菜单项设置一下ID号,ID_FTEST1和ID_FTEST2。</p>
<p><img src="5-6.jpg" alt=""></p>
</li>
<li><p>添加响应</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CTEXTView::OnFtest1() 
{
    // TODO: Add your command handler code here
    MessageBox("test1");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意一定要添加到视类。(添加到Frame类里面,视类也能用。但是View类,Frame类里面就不能响应了)</p>
<p>==(以上第十二课内容)==</p>
</li>
</ol>
<h3 id="5-动态菜单操作"><a href="#5-动态菜单操作" class="headerlink" title="5.动态菜单操作"></a>5.动态菜单操作</h3><p>​    <strong>添加菜单项目</strong></p>
<blockquote>
<p>放在Frame::OnCreate里面</p>
</blockquote>
<pre class="line-numbers language-C++"><code class="language-C++">    CMenu my_menu;//添加顶层菜单
    my_menu.CreateMenu();
    GetMenu()->AppendMenu( MF_POPUP,  (UINT) my_menu.m_hMenu, "my_menu");
    GetMenu()->GetSubMenu(0)->AppendMenu(MF_STRING, 777, "Hello");//添加顶层菜单下的菜单项,在(0)号菜单下添加
    //AppendMenu()的第一个参数决定了菜单的类型
    my_menu.Detach();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>插入菜单项目</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">    CMenu my_menu;
    my_menu.CreateMenu();
    GetMenu()->InsertMenu(2, MF_BYPOSITION | MF_POPUP, (UINT)my_menu.m_hMenu,"my_menu");//在2号位置插入顶级菜单    
    GetMenu()->GetSubMenu(0)->InsertMenu (0, MF_STRING | MF_BYPOSITION, 777, "Hello");//插入顶层菜单项

    my_menu.Detach();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>删除菜单项目</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">    GetMenu()->DeleteMenu(1, MF_BYPOSITION );//删除顶级菜单
    GetMenu()->GetSubMenu(0)->DeleteMenu (0, MF_BYPOSITION);//删除顶级菜单的菜单项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>动态添加的菜单命令响应</strong></p>
<p>动态菜单不能用<code>Ctrl+w</code>快捷键来响应,因为VC找不到动态,选择手动在以下三处添加响应代码。</p>
<ol>
<li><p>MainFrm.h</p>
<pre class="line-numbers language-C++"><code class="language-C++">protected:
    //{{AFX_MSG(CMainFrame)
   	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
   	afx_msg void OnTest();
   	afx_msg void OnTest1();
   	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
   	//}}AFX_MSG

    void OnHello();//定义响应OnHello(),放在Afx外面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>MainFrm.cpp</p>
<pre class="line-numbers language-C++"><code class="language-C++">//在消息宏映射里面增加消息映射宏
BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
   	ON_WM_CREATE()
   	ON_COMMAND(ID_TEST1, OnTest1)
   	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
   	//}}AFX_MSG_MAP
    ON_COMMAND(777, OnHello)//放在BEGIN和END中间,ID号为777
END_MESSAGE_MAP()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++"><code class="language-C++">void CMainFrame::OnHello() 
{
    // TODO: Add your command handler code here
    MessageBox("Hello");
}//添加定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h2 id="第六讲-对话框编程"><a href="#第六讲-对话框编程" class="headerlink" title="第六讲 对话框编程"></a>第六讲 对话框编程</h2><h3 id="1-对话框的基本知识"><a href="#1-对话框的基本知识" class="headerlink" title="1.对话框的基本知识"></a>1.对话框的基本知识</h3><p>对话框是一个窗口,与对话框资源相关的类为<code>CDialog</code>,由<code>CWnd</code>类派生而来。可以将对话框看成是一个大容器,在它上面能够放置各种标准的扩展控件，是用户与程序进行交互的重要手段。<strong>在MFC中,所有的控件都是由CWnd派生而来,因此,控件实际上也是窗口。</strong></p>
<p><strong>对话框种类</strong></p>
<ul>
<li><p>模式对话框</p>
<blockquote>
<p>当期显示的时候,程序会暂停执行,直到关闭这个对话框后,才能继续执行程序中其他任务,如”文件/打开”对话框。</p>
</blockquote>
</li>
<li><p>无模式对话框</p>
<blockquote>
<p>当其显示时,允许转而执行程序中其它任务,而不用关闭这个对话框。该类型对话框不会垄断用户的操作,用户仍可以与其他界面对象进行交互。例如,”查找”对话框。</p>
</blockquote>
</li>
</ul>
<h3 id="2-创建模式对话框"><a href="#2-创建模式对话框" class="headerlink" title="2.创建模式对话框"></a>2.创建模式对话框</h3><ol>
<li>在Menu里面添加一个对话框</li>
<li>在Frame里面为其添加响应</li>
<li>在位图资源里面新建一个CMyDlg</li>
</ol>
<p><img src="6-1.jpg" alt=""></p>
<p>添加位图之后再File里面会自动添加<code>MyDlg.cpp</code>和<code>MyDlg.h</code></p>
<blockquote>
<p>在主框架内添加头文件#include “MyDlg.h”</p>
</blockquote>
<pre class="line-numbers language-C++"><code class="language-C++">void CMainFrame::OnMydlg() 
{
    // TODO: Add your command handler code here
    CMyDlg Dlg;
    Dlg.DoModal();
}
/*
    DoModal功能:
    1.创建对话框
    2.显示对话框
    3.暂停运行

    DoModal何时返回?
点击 "确定" --> IDOK
    "取消"-->IDCANCEL
    "关闭"-->IDCANCEL
    调用EndDialog()的时候,DoModal返回。
*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>EndDialog()功能</strong></p>
<ol>
<li>通知DoModal结束暂停,可以返回</li>
<li>隐藏对话框(并没有kill)</li>
</ol>
<h3 id="3-创建无模式对话框"><a href="#3-创建无模式对话框" class="headerlink" title="3.创建无模式对话框"></a>3.创建无模式对话框</h3><pre class="line-numbers language-C++"><code class="language-C++">void CMainFrame::OnMydlg() 
{
    // TODO: Add your command handler code here
//    CMyDlg Dlg; //模式对话框
//    Dlg.DoModal();

    CMyDlg Dlg;    //无模式对话框
    Dlg.Create(IDD_DIALOG1, this);
    Dlg.ShowWindow(SW_SHOW);//将无模式对话框显示出来

    /*以上代码会导致对话框闪退,加上Detach()解除局部对象绑定*/
    Dlg.Detach();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>在这里加上Detach()之后会导致程序异常退出。</p>
<p>Detach()曾用于CBitmap、CMenu</p>
</blockquote>
<p>==(以上第十三课内容)==</p>
<p><strong>Detach()失效原因</strong></p>
<blockquote>
<p>窗口这个资源和普通资源不一样,解除了C++对象和窗口的绑定关系,窗口的所有特征都会失效,则会导致程序崩溃。</p>
</blockquote>
<p><strong>解决方法</strong></p>
<ol>
<li><p>把<code>CMyDlg Dlg;</code>放到主框架的头文件中,定义为全局变量。但是用这种方法Create只能被执行一次,因为第一次Create之后还没有被销毁，第二次再执行就会报错。</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMainFrame::OnMydlg() 
{
    static BOOL bFlag = FALSE;
    if (FALSE == bFlag)
    {
        Dlg.Create(IDD_DIALOG1, this); 
        bFlag = TRUE;
    }
    Dlg.ShowWindow(SW_SHOW);//将无模式对话框显示出来
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><strong>为什么模式对话框可以用局部变量,而无模式对话框不能？</strong></p>
<blockquote>
<p>原因在于DoModal()有暂停功能,调用DoModal时线程都被暂停,并没有返回,之后被释放掉也不会受到影响。</p>
</blockquote>
<ol start="2">
<li><p>把对话框对象定义为指针，在堆上分配内存。</p>
<pre class="line-numbers language-C++"><code class="language-C++">    void CMainFrame::OnMydlg() 
{
    CMyDlg* pDlg = new CMyDlg;
    pDlg->Create(IDD_DIALOG1, this);
    pDlg->ShowWindow(SW_SHOW);
}//在堆上new一个指针,但是这种方法会导致内存泄露<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><img src="6-2.jpg" alt=""></p>
<p>在<code>MyDlg.cpp</code>中添加如下代码:</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMyDlg::PostNcDestroy() 
{
    // TODO: Add your specialized code here and/or call the base class
    //非客户区被销毁的时候
    delete this;//防止内存泄露
    CDialog::PostNcDestroy();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>销毁无模式对话框</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">static BOOL bFlag = FALSE;
    if (FALSE == bFlag)
    {
        Dlg.Create(IDD_DIALOG1, this);
        Dlg.ShowWindow(SW_SHOW);
        bFlag = TRUE;
    }
    else
    {
        Dlg.DestroyWindow();
        bFlag = FALSE;
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-控件访问的七种方法"><a href="#4-控件访问的七种方法" class="headerlink" title="4.控件访问的七种方法"></a>4.控件访问的七种方法</h3><p><img src="6-3.jpg" alt=""></p>
<ol>
<li>MFC的DDX数据交换——控件和整型变量关联</li>
</ol>
<p><img src="6-4.jpg" alt=""></p>
<p>此时<code>MyDlg.cpp</code>中DDX部分代码如下:</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMyDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMyDlg)
	DDX_Text(pDX, IDC_EDIT1, m_Num1);
	DDX_Text(pDX, IDC_EDIT2, m_Num2);
	DDX_Text(pDX, IDC_EDIT3, m_Num3);
	//}}AFX_DATA_MAP
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接着设置Button1，</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMyDlg::OnButton1() 
{
    // TODO: Add your control notification handler code here
    m_Num3 = m_Num1 + m_Num2;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是这样结果并不能如我们期望中正常显示，原因在于成员变量和对话框控件中的数据并不能够双向流通。</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMyDlg::OnButton1() 
{
    // TODO: Add your control notification handler code here
    UpdateData();    //成员变量从对话框控件中获取数据
    m_Num3 = m_Num1 + m_Num2;
    UpdateData(FALSE);    //以成员变量的值初始化对话框控件
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="6-5.jpg" alt=""></p>
<ol start="2">
<li><p>MFC的DDX数据交换——控件和控件变量关联</p>
<p>和1中类似,改变控件的类型为<code>Control</code></p>
<p><img src="6-6.jpg" alt=""></p>
</li>
</ol>
<pre class="line-numbers language-C++"><code class="language-C++">void CMyDlg::OnButton1() 
{
    int num1, num2, num3;
    char c1[10], c2[10], c3[10];
    m_Edit1.GetWindowText(c1, 10);//获得对应的字符串
    m_Edit2.GetWindowText(c2, 10);
    num1 = atoi(c1);//字符串转为整型
    num2 = atoi(c2);
    num3 = num1 + num2;
    itoa(num3,c3,10);
    m_Edit3.SetWindowText(c3);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="6-7.jpg" alt=""></p>
<p><strong>3-1. GetDlgItem + Get/SetWindowText【使用频率较高】</strong></p>
<p><strong>重要：CWnd* GetDlgItem(int nID) const; 该返回一个指向由参数nID指定的控件对象的指针。</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMyDlg::OnButton1() 
{
    //使用GetDlgItem
    int num1, num2, num3;
    char c1[10], c2[10], c3[10];
    GetDlgItem(IDC_EDIT1)->GetWindowText(c1, 10);
    GetDlgItem(IDC_EDIT2)->GetWindowText(c2, 10);    
    num1 = atoi(c1);
    num2 = atoi(c2);
    num3 = num1 + num2;
    itoa(num3,c3,10);
    GetDlgItem(IDC_EDIT3)->SetWindowText(c3);

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3-2. 利用GetDlgItem改变控件文本内容</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMyDlg::OnNumber1() 
{
    // TODO: Add your control notification handler code here
    CString str;
    GetDlgItem(IDC_Number1)->GetWindowText(str);//在中英文之间转变
    if (str == "Number1:")
        GetDlgItem(IDC_Number1)->SetWindowText("数值1：");
    else
        GetDlgItem(IDC_Number1)->SetWindowText("Number1:");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="6-8.jpg" alt=""></p>
<blockquote>
<p>注意,要在控件属性中勾选通知表示接收通告消息</p>
</blockquote>
<p>3-3. 利用GetDlgItem在控件中绘图</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMyDlg::OnNumber2() 
{
    // TODO: Add your control notification handler code here
    CWnd* pWnd = GetDlgItem(IDC_Number2);

    CRect rc;
    pWnd->GetClientRect(&rc);
    CBrush brush(RGB(255,0,0));

    CDC* pDC = pWnd->GetDC();
    pDC->FillRect(&rc,&brush);
    pDC->SetBkMode(TRANSPARENT);
    pDC->TextOut(10,1,"啦啦啦");    
    ReleaseDC(pDC);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我做到这一步的时候突然发现,我一旦使用MyDlg菜单,位图插入符就会消失…但是调用其他菜单就不会。</p>
<p><img src="6-1.gif" alt=""></p>
<h3 id="5-改变对话框-窗口外观"><a href="#5-改变对话框-窗口外观" class="headerlink" title="5.改变对话框/窗口外观"></a>5.改变对话框/窗口外观</h3><ol>
<li><p>设置窗口的位置与大小</p>
<pre class="line-numbers language-C++"><code class="language-C++">BOOL CMyDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();

    // TODO: Add extra initialization here
    SetWindowPos(&wndTopMost,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>设置窗口的形状</p>
<pre class="line-numbers language-C++"><code class="language-C++">BOOL CMyDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();
    CRect rc;
    GetClientRect(rc);
    CRgn rgn;
    rgn.CreateEllipticRgn(0, 0, rc.Width(), rc.Height());//设置椭圆矩形框
    SetWindowRgn((HRGN) rgn.m_hObject, TRUE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><img src="6-10.jpg" alt=""></p>
<p>==(以上第十四课内容)==</p>
<hr>
<h2 id="第七讲-界面编程"><a href="#第七讲-界面编程" class="headerlink" title="第七讲 界面编程"></a>第七讲 界面编程</h2><h3 id="1-更改窗口大小、标题、风格"><a href="#1-更改窗口大小、标题、风格" class="headerlink" title="1.更改窗口大小、标题、风格"></a>1.更改窗口大小、标题、风格</h3><blockquote>
<p>如果希望在应用程序窗口创建之前修改它的大小、标题和风格，应该在CMainFrame类的PreCreateWindow成员进行。</p>
</blockquote>
<blockquote>
<p>该有个类型是CREATESTRUCT结构的参数，如果在修改了这个参数中的成员变量的值，那么这种改变会反映到MFC底层代码中，当MFC底层代码调用CreateWindowEx去创建窗口时，它就会使用改变后的参数值去创建这个窗口。</p>
</blockquote>
<pre class="line-numbers language-C++"><code class="language-C++">//在窗口创建之前进行修改
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    cs.cx = 300;//更改窗口长和宽
    cs.cy = 200;

    cs.lpszName = "SA作品";//更改标题栏名字
    cs.style = cs.style & ~FWS_ADDTOTITLE;  //让窗口显示出自己设置的标题

    return TRUE;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>在窗口创建之后更改其风格</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">    SetWindowLong(m_hWnd, GWL_STYLE, GetWindowLong(m_hWnd,GWL_STYLE) & ~WS_MAXIMIZEBOX);//窗口创建之后去掉最大化选项,在OnCreate里面添加<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="7-1.jpg" alt=""></p>
<h3 id="2-更改光标、标题图标、窗口背景"><a href="#2-更改光标、标题图标、窗口背景" class="headerlink" title="2.更改光标、标题图标、窗口背景"></a>2.更改光标、标题图标、窗口背景</h3><pre class="line-numbers language-C++"><code class="language-C++">BOOL CTEXTView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs
    cs.lpszClass = "hello";//在视类要调用"hello"这个图纸
    return CView::PreCreateWindow(cs);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++"><code class="language-C++">BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;    
    //自己注册窗口类
    WNDCLASS MyWnd;
    MyWnd.cbClsExtra = NULL; MyWnd.cbWndExtra = NULL;
    MyWnd.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    MyWnd.hCursor = LoadCursor(NULL, IDC_CROSS);
    MyWnd.hIcon = LoadIcon(NULL, IDI_WARNING);
    MyWnd.hInstance = AfxGetInstanceHandle();
    MyWnd.lpfnWndProc = ::DefWindowProc;
    MyWnd.lpszClassName = "Hello";
    MyWnd.lpszMenuName = NULL;
    MyWnd.style = CS_HREDRAW | CS_VREDRAW;
    RegisterClass(&MyWnd);    //注册
    cs.lpszClass = "hello";

    return TRUE;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="7-2.jpg" alt=""></p>
<p><strong>使用一个简单的修改</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // TODO: Modify the Window class or styles here by modifying

    //一个简单的修改
    cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW | CS_VREDRAW, 0, 0, LoadIcon(NULL, IDI_WARNING));

    return TRUE;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++"><code class="language-C++">BOOL CTEXTView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs
    //cs.lpszClass = "hello";
    cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW | CS_VREDRAW, LoadCursor(NULL,IDC_CROSS),(HBRUSH)GetStockObject(BLACK_BRUSH),0);
    return CView::PreCreateWindow(cs);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>SetClassLong实例</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">int CTEXTView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CView::OnCreate(lpCreateStruct) == -1)
        return -1;
    SetClassLong(m_hWnd, GCL_HBRBACKGROUND,(LONG)GetStockObject(BLACK_BRUSH));
    SetClassLong(m_hWnd, GCL_HCURSOR,(LONG) LoadCursor(NULL,IDC_CROSS));

    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++"><code class="language-C++">int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
        | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    // TODO: Delete these three lines if you don't want the toolbar to
    //  be dockable
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);

    GetMenu()->GetSubMenu(0)->CheckMenuItem(0, MF_BYPOSITION | MF_CHECKED);
    //获得顶级菜单-->子菜单(0)-->0号菜单项前面打勾

    GetMenu()->GetSubMenu(0)-> CheckMenuItem(ID_FILE_NEW, MF_CHECKED);
    //用ID号访问
    CBitmap bmp1,bmp2;
    bmp1.LoadBitmap(IDB_BITMAP2);//对应checked
    bmp2.LoadBitmap(IDB_BITMAP3);//对应unchecked
    GetMenu()->GetSubMenu(0)->SetMenuItemBitmaps(0, MF_BYPOSITION, &bmp1, &bmp2);

    bmp1.Detach();//解除绑定
    bmp2.Detach();

    GetMenu()->GetSubMenu(0)->EnableMenuItem(0, MF_BYPOSITION | MF_GRAYED | MF_DISABLED);//变灰和失效通常一起使用。

    SetMenu(NULL);//移除菜单

    CMenu menu;//加载菜单
    menu.LoadMenu(IDR_MAINFRAME);
    SetMenu(&menu);
    menu.Detach();//解除menu资源和对象的关系,否则return 0后资源会被释放;

    CMenu my_menu;//添加顶层菜单
    my_menu.CreateMenu();
    GetMenu()->AppendMenu( MF_POPUP,  (UINT) my_menu.m_hMenu, "my_menu");
    GetMenu()->GetSubMenu(0)->AppendMenu(MF_STRING, 777, "Hello");//添加顶层菜单下的菜单项,在(0)号菜单下添加
    //AppendMenu()的第一个参数决定了菜单的类型
    my_menu.Detach();


    SetClassLong(m_hWnd, GCL_HICON,(LONG)LoadIcon(NULL,IDI_WARNING));//设置标题栏图标

    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>动画图标</strong></p>
<p>先在资源面板添加Icon图形(4个)</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMainFrame::OnTimer(UINT nIDEvent) //添加定时器代码
{
    // TODO: Add your message handler code here and/or call default
    static int index = 1;
    SetClassLong(m_hWnd, GCL_HICON,(LONG)m_hIcon[index]);
    index = ++index % 4;
    //切换图标
    CFrameWnd::OnTimer(nIDEvent);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++"><code class="language-C++">//在CMainFrame::OnCreate()类添加代码如下
m_hIcon[0] = ::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_ICON1));
m_hIcon[1] = ::LoadIcon(theApp.m_hInstance, MAKEINTRESOURCE(IDI_ICON2));
m_hIcon[2] = ::LoadIcon(AfxGetApp()->m_hInstance, MAKEINTRESOURCE(IDI_ICON3));
m_hIcon[3] = AfxGetApp()->LoadIcon(IDI_ICON4);
SetClassLong(m_hWnd, GCL_HICON,(LONG)m_hIcon[0]);
SetTimer(1,1000, NULL);//启动定时器(编号,间隔时间,NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-工具栏编程"><a href="#3-工具栏编程" class="headerlink" title="3.工具栏编程"></a>3.工具栏编程</h3><p><strong>增加、删除工具栏按钮;响应按钮命令</strong></p>
<blockquote>
<p>工具栏是把常用的菜单命令集合起来，以按钮的形式提供给用户使用，目的是方便用户的操作。       </p>
<p>工具按钮的添加、删除都在资源编辑器窗口中的工具栏编辑窗口中完成。       </p>
<p>添加按钮响应命令的方法与菜单相同。通常工具栏与其对应的菜单项ID相同，这样，在程序运行时。可以通过单击工具栏上的按钮来调用相应菜单项的命令。</p>
</blockquote>
<p><strong>创建工具栏</strong></p>
<ol>
<li>创建工具栏资源</li>
</ol>
<p>TOOLBAR里面画几个工具栏图标</p>
<ol start="2">
<li>构造ToolBar对象</li>
</ol>
<blockquote>
<p>CToolBar m_newToolBar; //主框类头文件</p>
</blockquote>
<ol start="3">
<li>调用Create或CreateEx创建Window工具栏（工具栏也是窗口）</li>
</ol>
<pre class="line-numbers language-C++"><code class="language-C++">if (!m_newToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
        | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
        !m_newToolBar.LoadToolBar(IDR_TOOLBAR1))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="4">
<li><p>调用LoadToolBar加载工具栏资源</p>
<pre class="line-numbers language-C++"><code class="language-C++">    m_newToolBar.EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_newToolBar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ol>
<p><strong>显示和隐藏工具栏</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMainFrame::OnNewtoolbar() 
{
    // TODO: Add your command handler code here
    if (m_newToolBar.IsWindowVisible())
        m_newToolBar.ShowWindow(SW_HIDE);
    else
        m_newToolBar.ShowWindow(SW_SHOW);
    RecalcLayout();//重新布局
    DockControlBar(&m_newToolBar);//完成停靠操作

}

void CMainFrame::OnUpdateNewtoolbar(CCmdUI* pCmdUI) 
{
    // TODO: Add your command update UI handler code here
    pCmdUI->SetCheck(m_newToolBar.IsWindowVisible());
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>简介代码在下面:</p>
<pre class="line-numbers language-C++"><code class="language-C++">void CMainFrame::OnNewtoolbar() 
{
ShowControlBar(&m_newToolBar,!m_newToolBar.IsWindowVisible(), FALSE);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-状态栏编程"><a href="#4-状态栏编程" class="headerlink" title="4.状态栏编程"></a>4.状态栏编程</h3><blockquote>
<p>状态栏最多只有一个,也可以没有状态栏。工具栏的个数不做限制</p>
</blockquote>
<p><strong>状态栏的提示行与显示器</strong></p>
<blockquote>
<p>状态栏分为两部分：提示行与指示器。<br>左边最长的部分为提示行，通常用于显示菜单项或工具按钮的提示信息。右边由若干窗格组成的部分为状态栏指示器，通常用来显示大小写键、数字锁定键等信息。<br>框架程序专门提供了一个indicators数组来管理提示行与指示器。如果要修改状态栏的外观，则只需在indicators数组中添加或减少相应的字符串资源ID即可。</p>
</blockquote>
<p><strong>在指定的窗格中添加时钟显示</strong></p>
<ol>
<li><p>在资源编辑器中新增字符串资源ID:IDS_TIMER</p>
</li>
<li><p>将新的字符串资源ID添加到indicators数组中</p>
<pre class="line-numbers language-C++"><code class="language-C++">static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    IDS_TIMER,//在状态栏上增加时间信息
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>获得系统时间并调整窗口大小以及动态改变</p>
<pre class="line-numbers language-C++"><code class="language-C++">    CTime t = CTime::GetCurrentTime();//获得系统时间
    CString str = t.Format("%H:%M:%:%S");
    CClientDC dc(this);
    CSize sz = dc.GetTextExtent(str);
    m_wndStatusBar.SetPaneInfo(1, IDS_TIMER,SBPS_NORMAL, sz.cx);//为指定的窗格设置新的ID、样式、宽度
    m_wndStatusBar.SetPaneText(1, str);//TIMER在数组中的下标为1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++"><code class="language-C++">void CMainFrame::OnTimer(UINT nIDEvent) 
{    
    ......
    CTime t = CTime::GetCurrentTime();//每过1s重新设置时间,让时间能够动态更新
    CString str = t.Format("%H:%M:%:%S");
    m_wndStatusBar.SetPaneText(1, str);

    CFrameWnd::OnTimer(nIDEvent);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>==(以上第十五课内容)==</p>
<p><strong>在提示行中添加坐标显示</strong></p>
<ol>
<li>方法一</li>
</ol>
<pre class="line-numbers language-C++"><code class="language-C++">//在视图类中加上
//#include "MainFrm.h"
//#include "MyDlg.h"

void CTEXTView::OnMouseMove(UINT nFlags, CPoint point) 
{
    // TODO: Add your message handler code here and/or call default

    CString str;
    str.Format("x=%d, y=%d", point.x, point.y);
    ((CMainFrame*)GetParent())->m_wndStatusBar.SetWindowText(str);
    //主框架是视类的父窗口,通过GetParent()去拿到父窗口的指针
    CView::OnMouseMove(nFlags, point);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过我用这个会有报错提醒</p>
<p><img src="7-3.jpg" alt=""></p>
<p>我也不知道这个报错怎么来的…最后一个报错是保护权限报错,把<code>CStatusBar  m_wndStatusBar;</code>从protect放到public下就可以了。</p>
<p>找了半个小时发现我一在视图类里面添加<code>#include "MainFrm.h"</code>就会报错。</p>
<p><a href="https://www.cnblogs.com/qiernonstop/p/3717808.html" target="_blank" rel="noopener">参考链接</a></p>
<p>我觉得应该就是这个问题,C++中的嵌套类定义检查的问题，在 include 之后要声明一下才能使用这个类。</p>
<p>大概又过了二十分钟,我终于搞定了这个问题。</p>
<p>我在<code>MainFrm.h</code>中加入以下代码</p>
<pre class="line-numbers language-C++"><code class="language-C++">#include "MyDlg.h"
class CMyDlg;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="7-4.jpg" alt=""></p>
</li>
<li><p>其他方法</p>
</li>
</ol>
<pre class="line-numbers language-C++"><code class="language-C++">void CTEXTView::OnMouseMove(UINT nFlags, CPoint point) 
{
    // TODO: Add your message handler code here and/or call default
    CString str;
    str.Format("x=%d, y=%d", point.x, point.y);
//    ((CMainFrame*)GetParent())->m_wndStatusBar.SetWindowText(str);    //方法一:调用SetWindowText设置状态栏提示行文本
    ((CMainFrame*)GetParent())->SetMessageText(str);//方法二:利用CFrameWnd类的成员SetMessageText实现，该的作用是在状态栏的提示行中设置文本。
//    ((CMainFrame*)GetParent())->GetMessageBar()-> SetWindowText(str);//方法三:利用CFrameWnd类的成员GetMessageBar可以返回状态栏对象的指针，这样也不用再访问CMainFrame类的保护成员变量：m_wndStatusBar。
    CView::OnMouseMove(nFlags, point);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>在提示行中显示位图</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">CBitmapButton m_bmp;  //位图对象 MainFrm.h

    //建立位图按钮 MainFrm.cpp
CRect rc(100,4,120,20);//定义矩形框
if (!m_bmp.Create("", WS_CHILD|WS_VISIBLE|BS_OWNERDRAW, rc, &m_wndStatusBar, 789))
    return FALSE;
if (!m_bmp.LoadBitmaps(IDB_BITMAP2, IDB_BITMAP2, NULL, NULL))//四种情况对应四种位图
    return FALSE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>可以设置提示行的位图按钮点击产生效果,不过是动态资源,要手动设置三处:MainFrm.h中的声明、MainFrm.cpp中添加位图按钮响应、MainFrm.cpp中加上定义。</p>
</blockquote>
<ol>
<li>MainFrm.h中的声明</li>
</ol>
<p><img src="7-5.jpg" alt=""></p>
<ol start="2">
<li>MainFrm.cpp中添加位图按钮响应</li>
</ol>
<p><img src="7-6.jpg" alt=""></p>
<ol start="3">
<li>MainFrm.cpp中加上定义</li>
</ol>
<p><img src="7-7.jpg" alt=""></p>
<p>==(以上第十六课内容)==</p>
<hr>
<h2 id="第八讲-多线程与线程同步"><a href="#第八讲-多线程与线程同步" class="headerlink" title="第八讲 多线程与线程同步"></a>第八讲 多线程与线程同步</h2><h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h3><p><strong>程序</strong></p>
<blockquote>
<p>计算机指令的集合，它以文件的形式存储在磁盘上。</p>
</blockquote>
<p><strong>进程</strong></p>
<blockquote>
<p>通常被定义为一个正在运行的程序的实例，是一个程序在其自身的地址空间中的一次执行活动。 </p>
</blockquote>
<blockquote>
<p>进程是活的，是资源申请、调度和独立运行的单位，因此，它使用系统中的运行资源；而程序是死的，它不占用系统的运行资源。</p>
</blockquote>
<p>进程由两个部分组成：</p>
<p> 1、操作系统用来管理进程的<strong>内核对象</strong>。内核对象也是系统用来存放关于进程的统计信息的地方。（注意：内核对象不是进程本身） </p>
<p>2、地址空间。它包含所有可执行模块或DLL模块的代码和数据。它还包含动态内存分配的空间。如线程堆栈和堆分配空间。</p>
<p><strong>线程</strong></p>
<p>线程由两个部分组成：</p>
<p> 1、<strong>线程的内核对象</strong>，操作系统用它来对线程实施管理。内核对象也是系统用来存放线程统计信息的地方。</p>
<p> 2、<strong>线程堆栈</strong>，它用于维护线程在执行代码时需要的所有参数和局部变量。</p>
<p>当创建线程时，系统创建一个线程内核对象。该线程内核对象不是线程本身，而是操作系统用来管理线程的较小的数据结构。可以将线程内核对象视为由关于线程的统计信息组成的一个小型数据结构。 </p>
<p><strong>线程–&gt;相互之间通信容易、所需要的内存开销少</strong></p>
<h3 id="2-简单多线程示例"><a href="#2-简单多线程示例" class="headerlink" title="2.简单多线程示例"></a>2.简单多线程示例</h3><pre class="line-numbers language-C++"><code class="language-C++">#include <windows.h>
#include <iostream.h>

DWORD WINAPI ThreadProc( LPVOID lpParameter); 

void main()
{
    HANDLE hThread;
    hThread = CreateThread(NULL,0,ThreadProc,NULL,0,NULL);
    CloseHandle(hThread);
    cout << "main thread is running" << endl;
}

DWORD WINAPI ThreadProc( LPVOID lpParameter)
{
    cout << "thread1 is running" << endl;
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="8-1.jpg" alt=""></p>
<p><strong>注意1:</strong></p>
<p>Main函数中<strong>调用 CloseHandle 语句没有终止新创建的线程，只是表示在主线程中对新创建的线程的引用不感兴趣，因此将其句柄关闭</strong>。        </p>
<p>另一方面，当关闭该句柄时，系统会递减该线程内核对象的使用计数。当使用计数为0时，系统就会释放该线程内核对象。如果没有关闭线程句柄，系统就会一直保持着对线程内核对象的引用，这样，即使该线程执行完毕，它的引用计数仍不会为0。这样该线程内核对象也就不会被释放，只有等到进程终止时，系统才会清理这些残留的对象。        </p>
<p>因此，在程序中，<strong>当不再需要线程句柄时，应将其关闭</strong>，让这个线程内核对象的引用计数减1。</p>
<blockquote>
<p>问题:为什么上述程序线程1没有运行？</p>
</blockquote>
<p>在主线程运行时,主线程已经执行完毕了,但是分配给主线程的时间片还没有执行完,这时候主线程返回,程序结束了,Thread1自然就不会执行。</p>
<blockquote>
<p>解决办法:</p>
</blockquote>
<ol>
<li>增加主线程的耗时,比如说让主线程执行一个长的循环语句,执行完这个时间片之后,系统会自动终止并跳转到Thread1.(浪费资源)</li>
<li>在主线程中调用Sleep()函数。通过调用API函数 Sleep()，线程可以让自己睡眠指定的一段时间。正在睡眠的线程将暂停自己的运行，放弃执行的权利，而且睡眠的时候不占用处理器时间。一旦放弃了执行权力，操作系统就会从等待运行的其他线程队列中选择一个线程来执行。</li>
</ol>
<pre class="line-numbers language-C++"><code class="language-C++">#include <windows.h>
#include <iostream.h>

DWORD WINAPI ThreadProc( LPVOID lpParameter); 

void main()
{
    HANDLE hThread;
    hThread = CreateThread(NULL,0,ThreadProc,NULL,0,NULL);
    CloseHandle(hThread);
    cout << "main thread is running" << endl;
    Sleep(20);
}

DWORD WINAPI ThreadProc( LPVOID lpParameter)
{
    cout << "thread1 is running" << endl;
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="8-2.jpg" alt=""></p>
<p>==(以上第十七课内容)==</p>
<h3 id="3-线程同步"><a href="#3-线程同步" class="headerlink" title="3.线程同步"></a>3.线程同步</h3><p><strong>火车站售票系统模拟</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">#include <windows.h>
#include <iostream.h>

DWORD WINAPI ThreadProc1( LPVOID lpParameter); //售票窗口1
DWORD WINAPI ThreadProc2( LPVOID lpParameter); //售票窗口2

int tickets = 1; //票号，从第一张票票号为1

void main()
{
    HANDLE hThread1;
    HANDLE hThread2;
    hThread1 = CreateThread(NULL,0,ThreadProc1,NULL,0,NULL);
    hThread2 = CreateThread(NULL,0,ThreadProc2,NULL,0,NULL);
    CloseHandle(hThread1);
    CloseHandle(hThread2);

    Sleep(5000);
}
//线程1的入口函数（售票窗口1）
DWORD WINAPI ThreadProc1(LPVOID lpParameter)
{
    while (TRUE) 
    {
        if (tickets <= 100)//卖超过100张就结束
        {
                    cout << "thread1 sell ticket : " << tickets ++ << endl;
        }
        else
                break;
    }
    return 0;
}
//线程2的入口函数（售票窗口2）
DWORD WINAPI ThreadProc2(LPVOID lpParameter)
{
    while (TRUE) 
    {
        if (tickets <= 100)
        {
                    cout << "thread2 sell ticket : " << tickets ++ << endl;
        }
        else
                break;
    }
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>程序隐患：</p>
<p>事实上，上述程序存在隐患，比如以下情况：         </p>
<p>当tickets为100时，线程1函数进入 if 语句块后，正好该线程的时间片到了，操作系统就会选择线程2让其进行，而这时变量tickets的值还没有加1，因此这时变量tickets的值仍是100，线程2进入它的if 语句块中，于是线程2执行卖票操作，打印票号100，然后tickets变量加1，其值变为101。如果当线程2执行完成上述操作之后，正好又轮到线程1开始运行了。而这时线程1将从原先的if 语句块开始执行，于是它输出当前的票号，而此时tickets变量的值已经是101了，也就是说，我们会看到线程1卖了号码为101的票。显然这种情况时不允许的。</p>
</blockquote>
<blockquote>
<p>上述问题的出现主要原因就是两个线程访问了同一个全局变量：ticket。为了避免这种问题的发生，就要求在多个线程之间进行一个同步处理，保证一个线程访问共享资源时，其他线程不能访问该资源。</p>
</blockquote>
<p>线程需要在下面两种情况下互相通信，以实现同步：</p>
<ol>
<li>当有多个线程访问共享资源，而不使资源被破坏时。 </li>
<li>当一个线程需要将某个任务已经完成的情况通知另一个或多个线程时。</li>
</ol>
<p><strong>线程同步原理</strong></p>
<p><img src="8-3.jpg" alt=""></p>
<h3 id="4-利用互斥对象实现线程同步"><a href="#4-利用互斥对象实现线程同步" class="headerlink" title="4.利用互斥对象实现线程同步"></a>4.利用互斥对象实现线程同步</h3><blockquote>
<p>互斥对象（Mutex）属于内核对象，它能够确保线程拥有对单个资源的互斥访问权。 创建互斥对象需要调用函数：CreateMutex</p>
<p>互斥对象就相当于上图的那把锁。</p>
</blockquote>
<pre class="line-numbers language-C++"><code class="language-C++">HANDLE CreateMutex(
     LPSECURITY_ATTRIBUTES lpMutexAttributes, //通常设为NULL，该线程使用默认的安全性
     BOOL bInitialOwner,//可设为FALSE，创建这个互斥对象的线程不获得其所有权。
     LPCTSTR lpName//指定互斥对象的名称。如果此参数为NULL，则创建一个匿名的互斥对象。

); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>获得互斥对象的所有权</strong></p>
<p>线程<strong>必须主动请求共享对象的使用权</strong>才能获得该所有权，这可以通过调用<code>WaitForSingleObject</code>函数实现。</p>
<pre class="line-numbers language-C++"><code class="language-C++">DWORD WatiForSingleObject(HANDLE hHandle, DWORD dwMillisecond); //(锁定+等待)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p><code>HANDLE hHandle</code><br>所请求对象的句柄。本例为互斥对象句柄：hMutex。一旦互斥对象处于有信号状态，则该函数返回，接着，操作系统会将这个互斥对象设为无信号状态。<strong>如果该互斥对象处于无信号状态，则该函数会一直等待，这样会暂停线程的执行。</strong></p>
</blockquote>
<blockquote>
<p><code>DWORD dwMillisecond</code><br>指定等待的时间，如果指定的时间间隔已过，即使所请求的对象处于无信号状态，该函数也返回。<strong>如果该参数为0，该函数立即返回。如果该参数为INFINTE，则该函数永远等待，直到互斥对象处于有信号状态才返回。</strong></p>
</blockquote>
<p><strong>释放互斥对象的所有权</strong></p>
<p>当线程对共享资源访问结束后，应释放互斥对象的所有权，让该对象处于有信号状态。这时需要调用函数：<code>ReleaseMutex</code></p>
<pre class="line-numbers language-C++"><code class="language-C++">BOOL ReleaseMutex(HANDLE hMutex);//(解锁) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>完整的卖票程序代码:</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">#include <windows.h>
#include <iostream.h>

DWORD WINAPI ThreadProc1( LPVOID lpParameter); 
DWORD WINAPI ThreadProc2( LPVOID lpParameter); 

int tickets = 1;
HANDLE hMutex;//锁定义为全局对象
void main()
{
    HANDLE hThread1;
    HANDLE hThread2;
    hThread1 = CreateThread(NULL,0,ThreadProc1,NULL,0,NULL);
    hThread2 = CreateThread(NULL,0,ThreadProc2,NULL,0,NULL);
    CloseHandle(hThread1);
    CloseHandle(hThread2);
    hMutex = CreateMutex(NULL, FALSE, NULL);//创建锁的对象不具有锁的所有权,注意第二个参数一定要设为False
    Sleep(5000);
}
//线程1的入口函数（售票窗口1）
DWORD WINAPI ThreadProc1(LPVOID lpParameter)
{
    while (TRUE) 
    {
        WaitForSingleObject(hMutex,INFINITE);//(锁上 + 等待)
        if (tickets <= 100)
        {
            Sleep(1);
            cout << "thread1 sell ticket : " << tickets ++ << endl;
        }
        else
            break;
        ReleaseMutex(hMutex);//(解锁)
    }
    return 0;
}
//线程2的入口函数（售票窗口2）
DWORD WINAPI ThreadProc2(LPVOID lpParameter)
{
    while (TRUE) 
    {
        WaitForSingleObject(hMutex,INFINITE);//(锁上 + 等待)
        if (tickets <= 100)
        {
            Sleep(1);
            cout << "thread2 sell ticket : " << tickets ++ << endl;
        }
        else
            break;
        ReleaseMutex(hMutex);//(解锁)
    }
    return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-利用临界区实现线程同步"><a href="#5-利用临界区实现线程同步" class="headerlink" title="5.利用临界区实现线程同步"></a>5.利用临界区实现线程同步</h3><p><strong>临界区对象</strong></p>
<blockquote>
<p>临界区，也称关键代码段，它是指一个小代码段，在代码能够执行前，它必须独占对某些资源的访问权。         </p>
<p>通常把多线程中访问统一资源的那部分代码当作临界区，从而达到线程同步的目的。</p>
</blockquote>
<p><strong>相关API函数</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">初始化临界区对象：
void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSetion);
 获得临界区对象所有权：
void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSetion);
 释放临界区对象所有权：
void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSetion);
 释放临界区对象：
void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSetion);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>利用临界区完成上述售票系统</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">#include <windows.h>
#include <iostream.h>

DWORD WINAPI ThreadProc1( LPVOID lpParameter); 
DWORD WINAPI ThreadProc2( LPVOID lpParameter); 

int tickets = 1;
CRITICAL_SECTION cs;//创建一把锁
void main()
{
    HANDLE hThread1;
    HANDLE hThread2;
    hThread1 = CreateThread(NULL,0,ThreadProc1,NULL,0,NULL);
    hThread2 = CreateThread(NULL,0,ThreadProc2,NULL,0,NULL);
    CloseHandle(hThread1);
    CloseHandle(hThread2);
    InitializeCriticalSection(&cs);//把这把锁初始化
    Sleep(5000);
}
//线程1的入口函数（售票窗口1）
DWORD WINAPI ThreadProc1(LPVOID lpParameter)
{
    while (TRUE) 
    {
        EnterCriticalSection(&cs);//获取临界区对象所有权
        if (tickets <= 100)
        {
            Sleep(1);
            cout << "thread1 sell ticket : " << tickets ++ << endl;
        }
        else
            break;
        LeaveCriticalSection(&cs);//释放临界区对象所有权
    }
    return 0;
}

//线程2的入口函数（售票窗口2）
DWORD WINAPI ThreadProc2(LPVOID lpParameter)
{
    while (TRUE) 
    {
        EnterCriticalSection(&cs);//获取临界区对象所有权
        if (tickets <= 100)
        {
            Sleep(1);
            cout << "thread2 sell ticket : " << tickets ++ << endl;
        }
        else
            break;
        LeaveCriticalSection(&cs);//释放临界区对象所有权
    }

    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>互斥对象与临界区的比较</strong></p>
<blockquote>
<p>互斥对象属于内核对象，利用内核对象进行线程同步，速度较慢，但利用互斥对象这样的内核对象，可以在多个进程中的各个线程间进行同步。</p>
<p> 临界区只能在同一进程内的线程间进行同步，但使用最简单，同步速度较快，因此是实现同步化的<strong>首选方法</strong>。<strong>在使用临界区时，由于在等待进入关键代码段时无法设定超时值，容易进入死锁状态。</strong></p>
</blockquote>
<hr>
<h3 id="第九讲-动态链接库"><a href="#第九讲-动态链接库" class="headerlink" title="第九讲 动态链接库"></a>第九讲 动态链接库</h3><h3 id="1-动态链接库概述"><a href="#1-动态链接库概述" class="headerlink" title="1.动态链接库概述"></a>1.动态链接库概述</h3><p><strong>动态链接库不能直接运行，不能接收消息。</strong>它们是一些独立的文件，其中包含能被可执行程序或其它DLL调用来完成某项工作的函数。只有在其它模块调用动态链接库中的函数时，它才发挥作用。  </p>
<p>微软任何一个版本的Windows操作系统，动态链接库（DLL）都是其核心和基础。  </p>
<p>Windows API中的所有函数都包含在DLL中。其中有3个最重要的DLL，Kernel32.dll，它包含用于管理内存、进程和线程的各个函数；User32.dll，它包含用于执行用户界面任务（如窗口的创建和消息的传送）的各个函数；GDI32.dll，它包含用于画图和显示文本的各个函数。</p>
<p><strong>静态库(LIB)和动态库(DLL)</strong></p>
<blockquote>
<p>静态库：函数和数据被编译进一个二进制文件（通常扩展名为.LIB）。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据，并把它们和应用程序的其它模块组合起来创建最终的可执行文件（.EXE文件）。  </p>
</blockquote>
<blockquote>
<p>在使用动态库的时候，往往提供两个文件：一个引入库和一个DLL。引入库包含被DLL导出的函数和变量的符号名，DLL包含实际的函数和数据。在编译链接可执行文件时，只需要链接引入库，DLL中的函数代码和数据并不复制到可执行文件中，在运行的时候，再去加载DLL，访问DLL中导出的函数。</p>
</blockquote>
<p><strong>使用动态链接库的好处</strong></p>
<ul>
<li>增强程序的扩展性 </li>
<li>可以采用多种编程语言来写 </li>
<li>提供二次开发的平台 </li>
<li>简化项目管理 </li>
<li>节省磁盘空间和内存 </li>
<li>有助于资源共享</li>
</ul>
<h3 id="2-Win32-DLL的创建"><a href="#2-Win32-DLL的创建" class="headerlink" title="2.Win32 DLL的创建"></a>2.Win32 DLL的创建</h3><p><img src="9-1.jpg" alt=""></p>
<pre class="line-numbers language-C++"><code class="language-C++">_declspec (dllexport) int add(int a, int b)
{
    return a + b;
}
_declspec (dllexport) int subtract(int a, int b)
{
    return a - b;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注意：应用程序如果想要访问 DLL中的函数，那么该函数必须是已经被导出的函数。_declspec (dllexport)就是导出标识符。</p>
</blockquote>
<h3 id="3-隐式链接方式加载DLL"><a href="#3-隐式链接方式加载DLL" class="headerlink" title="3.隐式链接方式加载DLL"></a>3.隐式链接方式加载DLL</h3><ol>
<li>利用<code>extern</code>或者<code>_declspec (dllimport)</code>声明外部函数</li>
<li>使用引入库文件</li>
</ol>
<h3 id="4-显式加载方式加载DLL"><a href="#4-显式加载方式加载DLL" class="headerlink" title="4.显式加载方式加载DLL"></a>4.显式加载方式加载DLL</h3><p><strong>LoadLibrary函数</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">HMODULE LoadLibrary( LPCTSTR lpFileName);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>该函数的作用是将指定的可执行模块映射到调用进程的地址空间。LoadLibrary不仅能够加载DLL，还可以加载可执行模块（*.exe），当加载可执行模块时，主要是为了访问该模块内的资源，例如对话框资源、图标或位图资源。<br>当获取到动态链接库模块的句柄后，接下来需要获取该动态链接库中导出函数的地址。</p>
</blockquote>
<p><strong>GetProcAddress函数</strong></p>
<pre class="line-numbers language-C++"><code class="language-C++">FARPROC GetProcAddress( HMOUDLE hModule, LPCSTR lpProcName);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>该函数的作用是用来获取DLL导出函数的地址。<br>hModule：指定DLL模块的句柄，即LoadLibrary函数的返回值。<br>LpProcName：字符指针，指定DLL导出函数的名字或函数的序号。</p>
</blockquote>
<h3 id="5-DllMain函数介绍"><a href="#5-DllMain函数介绍" class="headerlink" title="5.DllMain函数介绍"></a>5.DllMain函数介绍</h3><blockquote>
<p>一个Win32程序，对可执行模块来说，其入口函数是WinMain；而对DLL来说，其入口函数是DllMain，该函数是可选的。也就是说，在编写DLL程序时，可以提供也可以不提供DllMain函数。</p>
</blockquote>
<p>==(以上十八课内容)==</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://github.com/littlematch59/littlematch59.github.io" rel="external nofollow noreferrer">Kni9hT</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://github.com/littlematch59/littlematch59.github.io/2020/06/23/windows/">https://github.com/littlematch59/littlematch59.github.io/2020/06/23/windows/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://github.com/littlematch59/littlematch59.github.io" target="_blank">Kni9hT</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'a0abed830299632b89e7',
        clientSecret: 'c1d97fd201167e15659e1cf04ccf782455654d45',
        repo: 'littlematch59.github.io',
        owner: 'littlematch59',
        admin: "littlematch59",
        id: '2020-06-23T11-30-30',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/08/27/win10-jia-ting-ban-ji-huo-win10-jia-ting-ban-sheng-ji-zhuan-ye-ban/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="Win10版本激活&Win10家庭版升级专业版">
                        
                        <span class="card-title">Win10版本激活&Win10家庭版升级专业版</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            背景
Windows操作系统在中国的使用占比目前还是市场最高，作为专业的计算机从业者，有时候家庭版的Win10会不太方便，比如BitLocker驱动器加密，或者计算机虚拟化(这个在配置虚拟机的时候可能会用到。今天突然发现了一个比较不错的工具
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-08-27
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Windows/" class="post-category">
                                    Windows
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/">
                        <span class="chip bg-color">奇技淫巧</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/05/27/canary/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="Linux pwn|Canary">
                        
                        <span class="card-title">Linux pwn|Canary</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            介绍Canary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。
我们知道，通常栈溢出的利用方式
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-05-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/pwn/" class="post-category">
                                    pwn
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://github.com/littlematch59/littlematch59.github.io" target="_blank">Kni9hT</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">71.1k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "3";
                    var startDate = "5";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/littlematch59/littlematch59.github.io" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:w1282626975@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1282626975" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1282626975" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    
	
	<!-- 雪花特效 -->
    
	
	
    <script type="text/javascript"> var OriginTitile = document.title, st;
	document.addEventListener("visibilitychange", function () { document.hidden ? 
	(document.title = "页面关闭倒计时:3...2...", clearTimeout(st)) : (document.title = 
	"倒计时结束！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) }) 
	</script>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>
